class CB_WST {
    constructor() {
        this.tlc = 0;
        this.pm = "";
        this.dpdid = 0;
        this.cb_clientId;
        this.cb_clientId2;
        this.sessionId;
        this.sessionNumber;
        this.ascItemIdResult = 0;
        this.ascPageTypeResult = 0;
        this.ascItemNumberResult = 0;
        this.tracking_domain = "//tracking.callmeasurement.com/tracking.cfm"
        this.tracking_update_domain = "//tracking.callmeasurement.com/tracking.cfc?method=updateDPDGASessionData"
        this.requestData;
        this.responseData;
        this.numbers = [];
    }

    async init() {
        try {
            await this.getGoogleData(500, 'client_id', 'G-XXXXXXXX').then((id) => { this.cb_clientId2 = id });
        } catch (e) {
            console.warn(`CB_WST: init clientId unable to get, will try cookie. May negatively impact rotation. Error: ${e}`)
        }
        const CB_gaCookie = this.getGoogleClientId('_ga');
        if (CB_gaCookie && !this.cb_clientId2) {
            this.cb_clientId2 = CB_gaCookie;
        }
        this.getASCData();
        this.pullPhoneNumbers();
        this.requestData = this.getRequestData();
        this.responseData = await this.makeRequest(this.requestData);
        const poolNumber = this.responseData.poolnumber;
        // Pool number returned
        const dpdid = this.responseData.dpdid;
        // Numbers to rotate over returned
        const numbersToRotate = this.responseData.numbersToChange;
        const numbersToRotateGroup = this.responseData.numbersToChange2;
        const changeNumbersTo = this.responseData.changeNumbersTo;
        if (numbersToRotateGroup && numbersToRotateGroup.length > 0) {
            for (let i = 0; i < numbersToRotateGroup.length; i++) {
                this.rotateNumbers(changeNumbersTo[i], numbersToRotateGroup[i]);
            }
        } else {
            this.rotateNumbers(poolNumber, numbersToRotate);
        }
        try {
            // Gtag GA4 Session data pulls
            await new Promise(resolve => setTimeout(resolve, 1000));
            if (gtag) {
                const gaDatabool = await this.gtagDataFunction(this.responseData.measurementid);
                // Send this data in to update DPD
                const urlParamString = `&dpdid=${dpdid}&sessionID=${this.sessionId}&sessionNumber=${this.sessionNumber}&clientID=${this.cb_clientId}`
                if (gaDatabool) {
                    await fetch(this.tracking_update_domain + urlParamString, {
                        method: "POST",
                        headers: {
                            "Content-type": "application/json; charset=UTF-8"
                        }
                    })
                }
            } else {
                console.warn('CB_WST: gtag not defined on page, session data not being pulled')
            }
        } catch (e) {
            console.warn(`CB_WST: Encoutered error handling gtag data. This does not affect rotation but some data may be missing for google events. Error: ${e}`)
        }
    }

    getASCData() {
        if (typeof asc_datalayer !== 'undefined') {
            const ascItemId = [];
            const ascPageType = [];
            const ascItemNumber = [];

            for (const key in asc_datalayer) {
                if (asc_datalayer.hasOwnProperty(key)) {
                    if (key === 'page_type' && asc_datalayer[key].indexOf("|") == -1) {
                        ascPageType.push(asc_datalayer[key].toLowerCase());
                    }
                    if (key === 'item_number' && asc_datalayer[key].indexOf("|") == -1) {
                        ascItemNumber.push(asc_datalayer[key].toUpperCase());
                    }
                    if (key === 'item_id' && asc_datalayer[key].indexOf("|") == -1) {
                        ascItemId.push(asc_datalayer[key].toUpperCase());
                    }
                    if (typeof asc_datalayer[key] === 'object' && asc_datalayer[key].length > 0 && (key === 'items' || key === 'events')) {
                        for (const a of asc_datalayer[key]) {
                            for (const k in a) {
                                if (a.hasOwnProperty(k)) {
                                    if (k === 'page_type') {
                                        ascPageType.push(a[k].toLowerCase());
                                    }
                                    if (k === 'item_number') {
                                        ascItemNumber.push(a[k].toUpperCase());
                                    }
                                    if (k === 'item_id') {
                                        ascItemId.push(a[k].toUpperCase());
                                    }
                                }
                            }
                        }
                    }
                }
            }

            const uniqueValue = (arr) => {
                if (arr.length > 1) {
                    return arr.every((item) => item === arr[0]) ? arr[0] : 0;
                }
                return arr[0];
            };

            this.ascItemIdResult = uniqueValue(ascItemId);
            this.ascPageTypeResult = uniqueValue(ascPageType);
            this.ascItemNumberResult = uniqueValue(ascItemNumber);
        }
    }

    pullPhoneNumbers() {
        var c = document.documentElement;
        const regNum = (/((\(\d{3}\) ?)|(\d{3}(-|\.)))?\d{3}(-|\.)\d{4}(?!([^<]*>)|(((?!<a).)*<\/a>))/gm)
        this.numbers = c.innerHTML.match(regNum);
        if (!this.numbers) {
            this.numbers = c.innerText.match(regNum);
        } else if (!!this.numbers && !!c.innerText.match(regNum)) {
            this.numbers = this.numbers.concat(c.innerText.match(regNum))
        }
        if (this.numbers != null) {
            this.numbers = this.numbers.filter(function (el) { return el != null; });
            this.numbers = this.numbers.filter(function (elem, index, self) { return index === self.indexOf(elem) })
            for (var i = 0; i < this.numbers.length; i++) { var temp = this.numbers[i].replace(/[\. ,:\(\)-]+/gi, ""); this.numbers[i] = temp; }
        }
    }


    async gtagPull(g, m) {
        return new Promise(resolve => {
            gtag('get', m, g, resolve)
        })
    }

    getGoogleData(t, g, m) {

        return new Promise((resolve, reject) => {

            // start timeout
            const timeoutID = setTimeout(
                () => reject(-1),
                t
            );

            // start calculation
            this.gtagPull(g, m).then(result => {
                clearTimeout(timeoutID);
                resolve(result);
            });
        });

    }

    getCookie(b) {
        // Same function from old script
        // Grabs cookies from doc
        // Do we even need cookie data anymore?
        var c = document.cookie.split(b + "=");
        if (2 == c.length) return c.pop().split(";").shift()
    }

    setCookie(b, c) {
        // Same function from old script
        // sets cookies
        // Do we even need cookie data anymore?
        var f = "";
        document.cookie = b + "=" + c + f + "; path=/"
    }

    getRequestData() {
        // Create large request block
        // Mostly copied over from old version with little change
        // could probably clean this up more, what data do we actually need. That would require more work in tracking.cfm as well though
        let request = {}
        request.c = encodeURIComponent(document.URL)
        request.p = encodeURIComponent(document.referrer)
        request.ascItemId = this.ascItemIdResult
        request.ascPageType = this.ascPageTypeResult
        request.ascItemNumber = this.ascItemNumberResult
        request.clientId = this.cb_clientId2
        request.numbers = this.numbers
        request.cookies = {}
        request.cookies.wtk = this.getCookie("utm_wtk")
        request.cookies.google = {}
        request.cookies.google.utma = this.getCookie("__utma")
        request.cookies.google.utmz = this.getCookie("__utmz")
        request.cookies.ci = {}
        request.cookies.ci.dpd = this.getCookie("__dpd")
        request.cookies.ci.gclid = this.getCookie("__gclid")
        let gclid = this.getURLParam("gclid")
        if (typeof gclid != 'undefined') this.setCookie("__gclid", gclid, 90)
        if (typeof external_id != 'undefined') request.external_id = external_id
        if (typeof favlocation != 'undefined' && typeof favlocation.location_id != 'undefined') request.locationid = favlocation.location_id
        return request;
    }

    async makeRequest() {
        // Uses fetch to make request to tracking domain, returns the response from the endpoint
        let response;
        await fetch(this.tracking_domain, {
            method: "POST",
            body: JSON.stringify(this.requestData),
            headers: {
                "Content-type": "application/json; charset=UTF-8"
            }
        })
            .then((response) => response.json())
            .then((json) => response = json);
        return response
    }

    getGoogleClientId() {
        const cookies = document.cookie.split('; ');
        const gaCookie = cookies.find(cookie => cookie.startsWith('_ga='));
        
        if (gaCookie) {
            const gaValue = gaCookie.split('=')[1];
            const clientId = gaValue.split('.').slice(2).join('.');
            return clientId;
        }
        
        return null;
    }

    getURLParam(a) {
        return (a = location.search.match(RegExp("[?&]" + a + "=([^&]*)(&?)", "i"))) ? a[1] : a
    }

    getUrlVars() {
        var vars = {};
        var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
            vars[key] = value;
        });
        return vars;
    }

    formatPhoneNumber(phoneNumber) {
        // Remove all non-digit characters
        const digitsOnly = phoneNumber.replace(/\D/g, '');

        // If the number starts with '1', remove it to make it 10 digits
        if (digitsOnly.length === 11 && digitsOnly.charAt(0) === '1') {
            return digitsOnly.substring(1);
        }

        // If the number has exactly 10 digits, keep it as is
        if (digitsOnly.length === 10) {
            return digitsOnly;
        }

        // Otherwise, return null for invalid numbers
        return null;
    }

    async gtagDataFunction(measurementid) {
        try {
            await this.getGoogleData(1000, 'client_id', measurementid).then((id) => { this.cb_clientId = id });
            await this.getGoogleData(1000, 'session_number', measurementid).then((id) => { this.sessionNumber = id });
            await this.getGoogleData(1000, 'session_id', measurementid).then((id) => { this.sessionId = id });
            return true;
        } catch (e) {
            console.warn(`CB_WST: gtag not compelted in time. This does not affect rotation but some data may be missing for google events. Error: ${e}`)
            return false;
        }
    }

    replacePhoneNumberInElement(element, poolNumber, htmlMatches, phoneRegex, i) {
        element.childNodes.forEach(child => {
            if (child.nodeType === Node.TEXT_NODE) {
                if (child.nodeValue.match(phoneRegex)) {
                    if (child.parentNode.hasAttribute("title")) {
                        child.parentNode.setAttribute("title", poolNumber);
                    }
                    if (Array.isArray(htmlMatches)) {
                        child.nodeValue = child.nodeValue.replace(htmlMatches[i], poolNumber)
                    } else {
                        //is this block still needed?
                        child.nodeValue = child.nodeValue.replace(phoneRegex, poolNumber)
                    }
                }
            }
        })
    }

    rotateNumbers(poolNumber, numbersToRotate) {
        const phoneRegex = /(\(?\d{3}\)?[-.\s]?)?\d{3}[-.\s]?\d{4}/g;
        const myNumsOnly = /\+?\d{10,11}/;
        const elementsWithPhoneNumbers = document.querySelectorAll('a, span, p, li, h1, h2, h3, h4, div, b, i, td');
        elementsWithPhoneNumbers.forEach(element => {
            let phoneNumber;
            let hrefMatches;
            const innerHTML = element.innerHTML
            const htmlMatches = innerHTML.match(phoneRegex)
            if (element.href && element.href.length > 0) {
                const innerHREF = element.href
                hrefMatches = innerHREF.match(myNumsOnly)
            }
            if (htmlMatches && htmlMatches.length > 0) {

                for (let i = 0; i < htmlMatches.length; i++) {
                    phoneNumber = htmlMatches[i];
                    const formattedNumber = this.formatPhoneNumber(phoneNumber);
                    if (formattedNumber && numbersToRotate && numbersToRotate.includes(formattedNumber)) {
                        if (element.hasAttribute("label")) {
                            element.setAttribute("label", poolNumber);
                        }
                        //This logic currently overrides the aria-label attribute with the pool number, so we loose country codes and other info.
                        if (element.getAttribute("aria-label")?.match(phoneRegex)) {
                            element.setAttribute("aria-label", poolNumber);
                        }
                        if (element.hasAttribute("data-click-to-call-phone")) {
                            element.setAttribute("data-click-to-call-phone", poolNumber);
                        }
                        if (element.tagName === "A") {
                            if (element.href.includes('tel:')) {
                                element.href = `tel:${poolNumber}`;
                            }
                            if (element.href.includes('sms:')) {
                                element.href = `sms:${poolNumber}`;
                            }
                        } else if (element.hasChildNodes()) {
                            const children = element.childNodes;
                            for (const child of children) {
                                if (child.href?.includes('tel:')) {
                                    child.href = `tel:${poolNumber}`;
                                }
                                if (child.href?.includes('sms:')) {
                                    child.href = `sms:${poolNumber}`;
                                }
                            }
                        }
                        this.replacePhoneNumberInElement(element, poolNumber, htmlMatches, phoneRegex, i)
                    }
                }
            }
        });
    }
}

const cb_rotate = new CB_WST()
window.addEventListener("load", cb_rotate.init())