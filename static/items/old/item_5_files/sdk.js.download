;(function () {
    const W = (window.CarviaWidgets = window.CarviaWidgets || {});
    const instances = new Map();
    const ORIGIN = "https://widgets.carvia.ai"; // https://widgets.carvia.ai"
  
    function createIframe(mountEl, url) {
      const f = document.createElement("iframe");
      f.src = url; f.loading="lazy"; f.title="Carvia Widget";
      f.style.width="100%"; f.style.border="0"; f.style.display="block";
      f.setAttribute("sandbox","allow-scripts allow-forms allow-same-origin");
      mountEl.appendChild(f);
      return f;
    }
  
    async function exchangePK(publishableKey, widget) {
      const res = await fetch(`${ORIGIN}/api/sessions-pk`, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ publishableKey, widget })
      });
      if (!res.ok) throw new Error("session_exchange_failed");
      return res.json(); // { iframeUrl, expiresIn }
    }
  
    function mount(selectorOrEl, opts) {
      const el = typeof selectorOrEl === "string" ? document.querySelector(selectorOrEl) : selectorOrEl;
      if (!el) throw new Error("mount_element_not_found");
      const { widget, publishableKey, inputs, onReady, onError } = opts || {};
      if (!widget || !publishableKey) throw new Error("missing_widget_or_key");
  
      const io = new IntersectionObserver(async (entries) => {
        if (!entries.some(e => e.isIntersecting)) return;
        io.disconnect();
        try {
          const { iframeUrl } = await exchangePK(publishableKey, widget);
          const f = createIframe(el, `${ORIGIN}${iframeUrl}`);
  
          function onMessage(e) {
            if (e.source !== f.contentWindow) return;
            if (!e.data || e.data.__carvia !== true) return;
            if (e.data.type === "ready") {
              onReady && onReady();
              f.contentWindow.postMessage({ __carvia: true, type: "setProps", payload: inputs || {} }, "*");
            } else if (e.data.type === "resize") {
              f.style.height = (e.data.h || 0) + "px";
            } else if (e.data.type === "error") {
              onError && onError(e.data.error);
            }
          }
          window.addEventListener("message", onMessage);
          instances.set(el, { f, onMessage });
        } catch (e) { onError && onError(e); }
      }, { rootMargin: "200px" });
  
      io.observe(el);
    }
  
    function setProps(selectorOrEl, payload) {
      const el = typeof selectorOrEl === "string" ? document.querySelector(selectorOrEl) : selectorOrEl;
      const inst = [...instances.entries()].find(([k]) => k === el)?.[1];
      if (!inst) return;
      inst.f.contentWindow.postMessage({ __carvia: true, type: "setProps", payload }, "*");
    }
  
    function destroy(selectorOrEl) {
      const el = typeof selectorOrEl === "string" ? document.querySelector(selectorOrEl) : selectorOrEl;
      const inst = [...instances.entries()].find(([k]) => k === el)?.[1];
      if (!inst) return;
      window.removeEventListener("message", inst.onMessage);
      inst.f.remove();
      instances.delete(el);
    }
  
    W.mount = mount;
    W.setProps = setProps;
    W.destroy = destroy;
  })();
  