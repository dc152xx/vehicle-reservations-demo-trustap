/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 6088:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.multiInject = void 0;
var METADATA_KEY = __webpack_require__(94725);
var metadata_1 = __webpack_require__(88390);
var decorator_utils_1 = __webpack_require__(50040);
function multiInject(serviceIdentifier) {
  return function (target, targetKey, index) {
    var metadata = new metadata_1.Metadata(METADATA_KEY.MULTI_INJECT_TAG, serviceIdentifier);
    if (typeof index === "number") {
      decorator_utils_1.tagParameter(target, targetKey, index, metadata);
    } else {
      decorator_utils_1.tagProperty(target, targetKey, metadata);
    }
  };
}
exports.multiInject = multiInject;

/***/ }),

/***/ 6566:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BindingToSyntax = void 0;
var ERROR_MSGS = __webpack_require__(27718);
var literal_types_1 = __webpack_require__(27802);
var binding_in_when_on_syntax_1 = __webpack_require__(12437);
var binding_when_on_syntax_1 = __webpack_require__(33341);
var BindingToSyntax = function () {
  function BindingToSyntax(binding) {
    this._binding = binding;
  }
  BindingToSyntax.prototype.to = function (constructor) {
    this._binding.type = literal_types_1.BindingTypeEnum.Instance;
    this._binding.implementationType = constructor;
    return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
  };
  BindingToSyntax.prototype.toSelf = function () {
    if (typeof this._binding.serviceIdentifier !== "function") {
      throw new Error("" + ERROR_MSGS.INVALID_TO_SELF_VALUE);
    }
    var self = this._binding.serviceIdentifier;
    return this.to(self);
  };
  BindingToSyntax.prototype.toConstantValue = function (value) {
    this._binding.type = literal_types_1.BindingTypeEnum.ConstantValue;
    this._binding.cache = value;
    this._binding.dynamicValue = null;
    this._binding.implementationType = null;
    return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax.prototype.toDynamicValue = function (func) {
    this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
    this._binding.cache = null;
    this._binding.dynamicValue = func;
    this._binding.implementationType = null;
    return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
  };
  BindingToSyntax.prototype.toConstructor = function (constructor) {
    this._binding.type = literal_types_1.BindingTypeEnum.Constructor;
    this._binding.implementationType = constructor;
    return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax.prototype.toFactory = function (factory) {
    this._binding.type = literal_types_1.BindingTypeEnum.Factory;
    this._binding.factory = factory;
    return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax.prototype.toFunction = function (func) {
    if (typeof func !== "function") {
      throw new Error(ERROR_MSGS.INVALID_FUNCTION_BINDING);
    }
    var bindingWhenOnSyntax = this.toConstantValue(func);
    this._binding.type = literal_types_1.BindingTypeEnum.Function;
    return bindingWhenOnSyntax;
  };
  BindingToSyntax.prototype.toAutoFactory = function (serviceIdentifier) {
    this._binding.type = literal_types_1.BindingTypeEnum.Factory;
    this._binding.factory = function (context) {
      var autofactory = function () {
        return context.container.get(serviceIdentifier);
      };
      return autofactory;
    };
    return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax.prototype.toProvider = function (provider) {
    this._binding.type = literal_types_1.BindingTypeEnum.Provider;
    this._binding.provider = provider;
    return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax.prototype.toService = function (service) {
    this.toDynamicValue(function (context) {
      return context.container.get(service);
    });
  };
  return BindingToSyntax;
}();
exports.BindingToSyntax = BindingToSyntax;

/***/ }),

/***/ 7324:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ UrlHelpers)
/* harmony export */ });
class UrlHelpers {
    static mapArrayToQueryString(searchParams) {
        return searchParams.map(param => param.value ? `${param.key}=${param.value}` : `${param.key}`).join('&');
    }
    static queryStringToArray(queryString) {
        // Remove leading '?' if present
        if (queryString === null || queryString === void 0 ? void 0 : queryString.startsWith('?')) {
            queryString = queryString.slice(1);
        }
        if (!queryString) {
            return []; // Return empty array if no query string
        }
        const keyValuePairs = queryString.split('&');
        const params = keyValuePairs.map((pair) => {
            // Split the key and value (with potential trailing =)
            const [key, ...valueParts] = pair.split('=');
            // Join the value parts (keeping trailing =)
            const value = valueParts.join('=');
            //we can't use decodeURIComponent because we allow dealers to use unsafe characters
            return {
                key: key,
                value: value
            };
        });
        return params;
    }
}
UrlHelpers.setQueryParam = (paramName, paramValue, searchParams) => {
    //update an existing value if the key exists
    const existingParam = searchParams.findIndex(param => param.key === paramName);
    if (existingParam > -1) {
        searchParams.splice(existingParam, 1);
    }
    searchParams.push({ "key": paramName, "value": paramValue });
};


/***/ }),

/***/ 9523:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.tagged = void 0;
var metadata_1 = __webpack_require__(88390);
var decorator_utils_1 = __webpack_require__(50040);
function tagged(metadataKey, metadataValue) {
  return function (target, targetKey, index) {
    var metadata = new metadata_1.Metadata(metadataKey, metadataValue);
    if (typeof index === "number") {
      decorator_utils_1.tagParameter(target, targetKey, index, metadata);
    } else {
      decorator_utils_1.tagProperty(target, targetKey, metadata);
    }
  };
}
exports.tagged = tagged;

/***/ }),

/***/ 9708:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
  // Metadata Proposal
  // https://rbuckton.github.io/reflect-metadata/
  (function (factory) {
    var root = typeof __webpack_require__.g === "object" ? __webpack_require__.g : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
    var exporter = makeExporter(Reflect);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect;
    } else {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter);
    function makeExporter(target, previous) {
      return function (key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, {
            configurable: true,
            writable: true,
            value: value
          });
        }
        if (previous) previous(key, value);
      };
    }
  })(function (exporter) {
    var hasOwn = Object.prototype.hasOwnProperty;
    // feature test for Symbol support
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
    var supportsProto = {
      __proto__: []
    } instanceof Array; // feature test for __proto__ support
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function () {
        return MakeDictionary(Object.create(null));
      } : supportsProto ? function () {
        return MakeDictionary({
          __proto__: null
        });
      } : function () {
        return MakeDictionary({});
      },
      has: downLevel ? function (map, key) {
        return hasOwn.call(map, key);
      } : function (map, key) {
        return key in map;
      },
      get: downLevel ? function (map, key) {
        return hasOwn.call(map, key) ? map[key] : undefined;
      } : function (map, key) {
        return map[key];
      }
    };
    // Load global or shim versions of Map, Set, and WeakMap
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process["env" + ""] && process["env" + ""]["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    // [[Metadata]] internal slot
    // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
    var Metadata = new _WeakMap();
    /**
     * Applies a set of decorators to a property of a target object.
     * @param decorators An array of decorators.
     * @param target The target object.
     * @param propertyKey (Optional) The property key to decorate.
     * @param attributes (Optional) The property descriptor for the target key.
     * @remarks Decorators are applied in reverse order.
     * @example
     *
     *     class Example {
     *         // property declarations are not part of ES6, though they are valid in TypeScript:
     *         // static staticProperty;
     *         // property;
     *
     *         constructor(p) { }
     *         static staticMethod(p) { }
     *         method(p) { }
     *     }
     *
     *     // constructor
     *     Example = Reflect.decorate(decoratorsArray, Example);
     *
     *     // property (on constructor)
     *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
     *
     *     // property (on prototype)
     *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
     *
     *     // method (on constructor)
     *     Object.defineProperty(Example, "staticMethod",
     *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
     *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
     *
     *     // method (on prototype)
     *     Object.defineProperty(Example.prototype, "method",
     *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
     *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
     *
     */
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators)) throw new TypeError();
        if (!IsObject(target)) throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError();
        if (IsNull(attributes)) attributes = undefined;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators)) throw new TypeError();
        if (!IsConstructor(target)) throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
    // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
    /**
     * A default metadata decorator factory that can be used on a class, class member, or parameter.
     * @param metadataKey The key for the metadata entry.
     * @param metadataValue The value for the metadata entry.
     * @returns A decorator function.
     * @remarks
     * If `metadataKey` is already defined for the target and target key, the
     * metadataValue for that key will be overwritten.
     * @example
     *
     *     // constructor
     *     @Reflect.metadata(key, value)
     *     class Example {
     *     }
     *
     *     // property (on constructor, TypeScript only)
     *     class Example {
     *         @Reflect.metadata(key, value)
     *         static staticProperty;
     *     }
     *
     *     // property (on prototype, TypeScript only)
     *     class Example {
     *         @Reflect.metadata(key, value)
     *         property;
     *     }
     *
     *     // method (on constructor)
     *     class Example {
     *         @Reflect.metadata(key, value)
     *         static staticMethod() { }
     *     }
     *
     *     // method (on prototype)
     *     class Example {
     *         @Reflect.metadata(key, value)
     *         method() { }
     *     }
     *
     */
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    /**
     * Define a unique metadata entry on the target.
     * @param metadataKey A key used to store and retrieve metadata.
     * @param metadataValue A value that contains attached metadata.
     * @param target The target object on which to define metadata.
     * @param propertyKey (Optional) The property key for the target.
     * @example
     *
     *     class Example {
     *         // property declarations are not part of ES6, though they are valid in TypeScript:
     *         // static staticProperty;
     *         // property;
     *
     *         constructor(p) { }
     *         static staticMethod(p) { }
     *         method(p) { }
     *     }
     *
     *     // constructor
     *     Reflect.defineMetadata("custom:annotation", options, Example);
     *
     *     // property (on constructor)
     *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
     *
     *     // property (on prototype)
     *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
     *
     *     // method (on constructor)
     *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
     *
     *     // method (on prototype)
     *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
     *
     *     // decorator factory as metadata-producing annotation.
     *     function MyAnnotation(options): Decorator {
     *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
     *     }
     *
     */
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    /**
     * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
     * @param metadataKey A key used to store and retrieve metadata.
     * @param target The target object on which the metadata is defined.
     * @param propertyKey (Optional) The property key for the target.
     * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
     * @example
     *
     *     class Example {
     *         // property declarations are not part of ES6, though they are valid in TypeScript:
     *         // static staticProperty;
     *         // property;
     *
     *         constructor(p) { }
     *         static staticMethod(p) { }
     *         method(p) { }
     *     }
     *
     *     // constructor
     *     result = Reflect.hasMetadata("custom:annotation", Example);
     *
     *     // property (on constructor)
     *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
     *
     *     // property (on prototype)
     *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
     *
     *     // method (on constructor)
     *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
     *
     *     // method (on prototype)
     *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
     *
     */
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    /**
     * Gets a value indicating whether the target object has the provided metadata key defined.
     * @param metadataKey A key used to store and retrieve metadata.
     * @param target The target object on which the metadata is defined.
     * @param propertyKey (Optional) The property key for the target.
     * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
     * @example
     *
     *     class Example {
     *         // property declarations are not part of ES6, though they are valid in TypeScript:
     *         // static staticProperty;
     *         // property;
     *
     *         constructor(p) { }
     *         static staticMethod(p) { }
     *         method(p) { }
     *     }
     *
     *     // constructor
     *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
     *
     *     // property (on constructor)
     *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
     *
     *     // property (on prototype)
     *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
     *
     *     // method (on constructor)
     *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
     *
     *     // method (on prototype)
     *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
     *
     */
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    /**
     * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
     * @param metadataKey A key used to store and retrieve metadata.
     * @param target The target object on which the metadata is defined.
     * @param propertyKey (Optional) The property key for the target.
     * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
     * @example
     *
     *     class Example {
     *         // property declarations are not part of ES6, though they are valid in TypeScript:
     *         // static staticProperty;
     *         // property;
     *
     *         constructor(p) { }
     *         static staticMethod(p) { }
     *         method(p) { }
     *     }
     *
     *     // constructor
     *     result = Reflect.getMetadata("custom:annotation", Example);
     *
     *     // property (on constructor)
     *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
     *
     *     // property (on prototype)
     *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
     *
     *     // method (on constructor)
     *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
     *
     *     // method (on prototype)
     *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
     *
     */
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    /**
     * Gets the metadata value for the provided metadata key on the target object.
     * @param metadataKey A key used to store and retrieve metadata.
     * @param target The target object on which the metadata is defined.
     * @param propertyKey (Optional) The property key for the target.
     * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
     * @example
     *
     *     class Example {
     *         // property declarations are not part of ES6, though they are valid in TypeScript:
     *         // static staticProperty;
     *         // property;
     *
     *         constructor(p) { }
     *         static staticMethod(p) { }
     *         method(p) { }
     *     }
     *
     *     // constructor
     *     result = Reflect.getOwnMetadata("custom:annotation", Example);
     *
     *     // property (on constructor)
     *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
     *
     *     // property (on prototype)
     *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
     *
     *     // method (on constructor)
     *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
     *
     *     // method (on prototype)
     *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
     *
     */
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    /**
     * Gets the metadata keys defined on the target object or its prototype chain.
     * @param target The target object on which the metadata is defined.
     * @param propertyKey (Optional) The property key for the target.
     * @returns An array of unique metadata keys.
     * @example
     *
     *     class Example {
     *         // property declarations are not part of ES6, though they are valid in TypeScript:
     *         // static staticProperty;
     *         // property;
     *
     *         constructor(p) { }
     *         static staticMethod(p) { }
     *         method(p) { }
     *     }
     *
     *     // constructor
     *     result = Reflect.getMetadataKeys(Example);
     *
     *     // property (on constructor)
     *     result = Reflect.getMetadataKeys(Example, "staticProperty");
     *
     *     // property (on prototype)
     *     result = Reflect.getMetadataKeys(Example.prototype, "property");
     *
     *     // method (on constructor)
     *     result = Reflect.getMetadataKeys(Example, "staticMethod");
     *
     *     // method (on prototype)
     *     result = Reflect.getMetadataKeys(Example.prototype, "method");
     *
     */
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    /**
     * Gets the unique metadata keys defined on the target object.
     * @param target The target object on which the metadata is defined.
     * @param propertyKey (Optional) The property key for the target.
     * @returns An array of unique metadata keys.
     * @example
     *
     *     class Example {
     *         // property declarations are not part of ES6, though they are valid in TypeScript:
     *         // static staticProperty;
     *         // property;
     *
     *         constructor(p) { }
     *         static staticMethod(p) { }
     *         method(p) { }
     *     }
     *
     *     // constructor
     *     result = Reflect.getOwnMetadataKeys(Example);
     *
     *     // property (on constructor)
     *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
     *
     *     // property (on prototype)
     *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
     *
     *     // method (on constructor)
     *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
     *
     *     // method (on prototype)
     *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
     *
     */
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    /**
     * Deletes the metadata entry from the target object with the provided key.
     * @param metadataKey A key used to store and retrieve metadata.
     * @param target The target object on which the metadata is defined.
     * @param propertyKey (Optional) The property key for the target.
     * @returns `true` if the metadata entry was found and deleted; otherwise, false.
     * @example
     *
     *     class Example {
     *         // property declarations are not part of ES6, though they are valid in TypeScript:
     *         // static staticProperty;
     *         // property;
     *
     *         constructor(p) { }
     *         static staticMethod(p) { }
     *         method(p) { }
     *     }
     *
     *     // constructor
     *     result = Reflect.deleteMetadata("custom:annotation", Example);
     *
     *     // property (on constructor)
     *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
     *
     *     // property (on prototype)
     *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
     *
     *     // method (on constructor)
     *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
     *
     *     // method (on prototype)
     *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
     *
     */
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
      var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/false);
      if (IsUndefined(metadataMap)) return false;
      if (!metadataMap.delete(metadataKey)) return false;
      if (metadataMap.size > 0) return true;
      var targetMetadata = Metadata.get(target);
      targetMetadata.delete(propertyKey);
      if (targetMetadata.size > 0) return true;
      Metadata.delete(target);
      return true;
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated)) throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated)) throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      var targetMetadata = Metadata.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create) return undefined;
        targetMetadata = new _Map();
        Metadata.set(O, targetMetadata);
      }
      var metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create) return undefined;
        metadataMap = new _Map();
        targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn) return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent)) return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
      if (IsUndefined(metadataMap)) return false;
      return ToBoolean(metadataMap.has(MetadataKey));
    }
    // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P);
      return undefined;
    }
    // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
      if (IsUndefined(metadataMap)) return undefined;
      return metadataMap.get(MetadataKey);
    }
    // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/true);
      metadataMap.set(MetadataKey, MetadataValue);
    }
    // 3.1.6.1 OrdinaryMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null) return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0) return ownKeys;
      if (ownKeys.length <= 0) return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
    function OrdinaryOwnMetadataKeys(O, P) {
      var keys = [];
      var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
      if (IsUndefined(metadataMap)) return keys;
      var keysObj = metadataMap.keys();
      var iterator = GetIterator(keysObj);
      var k = 0;
      while (true) {
        var next = IteratorStep(iterator);
        if (!next) {
          keys.length = k;
          return keys;
        }
        var nextValue = IteratorValue(next);
        try {
          keys[k] = nextValue;
        } catch (e) {
          try {
            IteratorClose(iterator);
          } finally {
            throw e;
          }
        }
        k++;
      }
    }
    // 6 ECMAScript Data Typ0es and Values
    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
    function Type(x) {
      if (x === null) return 1 /* Null */;
      switch (typeof x) {
        case "undefined":
          return 0 /* Undefined */;
        case "boolean":
          return 2 /* Boolean */;
        case "string":
          return 3 /* String */;
        case "symbol":
          return 4 /* Symbol */;
        case "number":
          return 5 /* Number */;
        case "object":
          return x === null ? 1 /* Null */ : 6 /* Object */;
        default:
          return 6 /* Object */;
      }
    }
    // 6.1.1 The Undefined Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
    function IsUndefined(x) {
      return x === undefined;
    }
    // 6.1.2 The Null Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
    function IsNull(x) {
      return x === null;
    }
    // 6.1.5 The Symbol Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    // 6.1.7 The Object Type
    // https://tc39.github.io/ecma262/#sec-object-type
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    // 7.1 Type Conversion
    // https://tc39.github.io/ecma262/#sec-type-conversion
    // 7.1.1 ToPrimitive(input [, PreferredType])
    // https://tc39.github.io/ecma262/#sec-toprimitive
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0 /* Undefined */:
          return input;
        case 1 /* Null */:
          return input;
        case 2 /* Boolean */:
          return input;
        case 3 /* String */:
          return input;
        case 4 /* Symbol */:
          return input;
        case 5 /* Number */:
          return input;
      }
      var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== undefined) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result)) throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    // 7.1.1.1 OrdinaryToPrimitive(O, hint)
    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result)) return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result)) return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result)) return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result)) return result;
        }
      }
      throw new TypeError();
    }
    // 7.1.2 ToBoolean(argument)
    // https://tc39.github.io/ecma262/2016/#sec-toboolean
    function ToBoolean(argument) {
      return !!argument;
    }
    // 7.1.12 ToString(argument)
    // https://tc39.github.io/ecma262/#sec-tostring
    function ToString(argument) {
      return "" + argument;
    }
    // 7.1.14 ToPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-topropertykey
    function ToPropertyKey(argument) {
      var key = ToPrimitive(argument, 3 /* String */);
      if (IsSymbol(key)) return key;
      return ToString(key);
    }
    // 7.2 Testing and Comparison Operations
    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
    // 7.2.2 IsArray(argument)
    // https://tc39.github.io/ecma262/#sec-isarray
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    // 7.2.3 IsCallable(argument)
    // https://tc39.github.io/ecma262/#sec-iscallable
    function IsCallable(argument) {
      // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
      return typeof argument === "function";
    }
    // 7.2.4 IsConstructor(argument)
    // https://tc39.github.io/ecma262/#sec-isconstructor
    function IsConstructor(argument) {
      // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
      return typeof argument === "function";
    }
    // 7.2.7 IsPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-ispropertykey
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3 /* String */:
          return true;
        case 4 /* Symbol */:
          return true;
        default:
          return false;
      }
    }
    // 7.3 Operations on Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-objects
    // 7.3.9 GetMethod(V, P)
    // https://tc39.github.io/ecma262/#sec-getmethod
    function GetMethod(V, P) {
      var func = V[P];
      if (func === undefined || func === null) return undefined;
      if (!IsCallable(func)) throw new TypeError();
      return func;
    }
    // 7.4 Operations on Iterator Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method)) throw new TypeError(); // from Call
      var iterator = method.call(obj);
      if (!IsObject(iterator)) throw new TypeError();
      return iterator;
    }
    // 7.4.4 IteratorValue(iterResult)
    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    // 7.4.5 IteratorStep(iterator)
    // https://tc39.github.io/ecma262/#sec-iteratorstep
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    // 7.4.6 IteratorClose(iterator, completion)
    // https://tc39.github.io/ecma262/#sec-iteratorclose
    function IteratorClose(iterator) {
      var f = iterator["return"];
      if (f) f.call(iterator);
    }
    // 9.1 Ordinary Object Internal Methods and Internal Slots
    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
    // 9.1.1.1 OrdinaryGetPrototypeOf(O)
    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype) return proto;
      // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
      // Try to determine the superclass constructor. Compatible implementations
      // must either set __proto__ on a subclass constructor to the superclass constructor,
      // or ensure each class has a valid `constructor` property on its prototype that
      // points back to the constructor.
      // If this is not the same as Function.[[Prototype]], then this is definately inherited.
      // This is the case when in ES6 or when using __proto__ in a compatible browser.
      if (proto !== functionPrototype) return proto;
      // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
      var prototype = O.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype) return proto;
      // If the constructor was not a function, then we cannot determine the heritage.
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function") return proto;
      // If we have some kind of self-reference, then we cannot determine the heritage.
      if (constructor === O) return proto;
      // we have a pretty good guess at the heritage.
      return constructor;
    }
    // naive Map shim
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = /** @class */function () {
        function MapIterator(keys, values, selector) {
          this._index = 0;
          this._keys = keys;
          this._values = values;
          this._selector = selector;
        }
        MapIterator.prototype["@@iterator"] = function () {
          return this;
        };
        MapIterator.prototype[iteratorSymbol] = function () {
          return this;
        };
        MapIterator.prototype.next = function () {
          var index = this._index;
          if (index >= 0 && index < this._keys.length) {
            var result = this._selector(this._keys[index], this._values[index]);
            if (index + 1 >= this._keys.length) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            } else {
              this._index++;
            }
            return {
              value: result,
              done: false
            };
          }
          return {
            value: undefined,
            done: true
          };
        };
        MapIterator.prototype.throw = function (error) {
          if (this._index >= 0) {
            this._index = -1;
            this._keys = arraySentinel;
            this._values = arraySentinel;
          }
          throw error;
        };
        MapIterator.prototype.return = function (value) {
          if (this._index >= 0) {
            this._index = -1;
            this._keys = arraySentinel;
            this._values = arraySentinel;
          }
          return {
            value: value,
            done: true
          };
        };
        return MapIterator;
      }();
      return /** @class */function () {
        function Map() {
          this._keys = [];
          this._values = [];
          this._cacheKey = cacheSentinel;
          this._cacheIndex = -2;
        }
        Object.defineProperty(Map.prototype, "size", {
          get: function () {
            return this._keys.length;
          },
          enumerable: true,
          configurable: true
        });
        Map.prototype.has = function (key) {
          return this._find(key, /*insert*/false) >= 0;
        };
        Map.prototype.get = function (key) {
          var index = this._find(key, /*insert*/false);
          return index >= 0 ? this._values[index] : undefined;
        };
        Map.prototype.set = function (key, value) {
          var index = this._find(key, /*insert*/true);
          this._values[index] = value;
          return this;
        };
        Map.prototype.delete = function (key) {
          var index = this._find(key, /*insert*/false);
          if (index >= 0) {
            var size = this._keys.length;
            for (var i = index + 1; i < size; i++) {
              this._keys[i - 1] = this._keys[i];
              this._values[i - 1] = this._values[i];
            }
            this._keys.length--;
            this._values.length--;
            if (key === this._cacheKey) {
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            return true;
          }
          return false;
        };
        Map.prototype.clear = function () {
          this._keys.length = 0;
          this._values.length = 0;
          this._cacheKey = cacheSentinel;
          this._cacheIndex = -2;
        };
        Map.prototype.keys = function () {
          return new MapIterator(this._keys, this._values, getKey);
        };
        Map.prototype.values = function () {
          return new MapIterator(this._keys, this._values, getValue);
        };
        Map.prototype.entries = function () {
          return new MapIterator(this._keys, this._values, getEntry);
        };
        Map.prototype["@@iterator"] = function () {
          return this.entries();
        };
        Map.prototype[iteratorSymbol] = function () {
          return this.entries();
        };
        Map.prototype._find = function (key, insert) {
          if (this._cacheKey !== key) {
            this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
          }
          if (this._cacheIndex < 0 && insert) {
            this._cacheIndex = this._keys.length;
            this._keys.push(key);
            this._values.push(undefined);
          }
          return this._cacheIndex;
        };
        return Map;
      }();
      function getKey(key, _) {
        return key;
      }
      function getValue(_, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    // naive Set shim
    function CreateSetPolyfill() {
      return /** @class */function () {
        function Set() {
          this._map = new _Map();
        }
        Object.defineProperty(Set.prototype, "size", {
          get: function () {
            return this._map.size;
          },
          enumerable: true,
          configurable: true
        });
        Set.prototype.has = function (value) {
          return this._map.has(value);
        };
        Set.prototype.add = function (value) {
          return this._map.set(value, value), this;
        };
        Set.prototype.delete = function (value) {
          return this._map.delete(value);
        };
        Set.prototype.clear = function () {
          this._map.clear();
        };
        Set.prototype.keys = function () {
          return this._map.keys();
        };
        Set.prototype.values = function () {
          return this._map.values();
        };
        Set.prototype.entries = function () {
          return this._map.entries();
        };
        Set.prototype["@@iterator"] = function () {
          return this.keys();
        };
        Set.prototype[iteratorSymbol] = function () {
          return this.keys();
        };
        return Set;
      }();
    }
    // naive WeakMap shim
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return /** @class */function () {
        function WeakMap() {
          this._key = CreateUniqueKey();
        }
        WeakMap.prototype.has = function (target) {
          var table = GetOrCreateWeakMapTable(target, /*create*/false);
          return table !== undefined ? HashMap.has(table, this._key) : false;
        };
        WeakMap.prototype.get = function (target) {
          var table = GetOrCreateWeakMapTable(target, /*create*/false);
          return table !== undefined ? HashMap.get(table, this._key) : undefined;
        };
        WeakMap.prototype.set = function (target, value) {
          var table = GetOrCreateWeakMapTable(target, /*create*/true);
          table[this._key] = value;
          return this;
        };
        WeakMap.prototype.delete = function (target) {
          var table = GetOrCreateWeakMapTable(target, /*create*/false);
          return table !== undefined ? delete table[this._key] : false;
        };
        WeakMap.prototype.clear = function () {
          // NOTE: not a real clear, just makes the previous data unreachable
          this._key = CreateUniqueKey();
        };
        return WeakMap;
      }();
      function CreateUniqueKey() {
        var key;
        do key = "@@WeakMap@@" + CreateUUID(); while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create) return undefined;
          Object.defineProperty(target, rootKey, {
            value: HashMap.create()
          });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i) buffer[i] = Math.random() * 0xff | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined") return crypto.getRandomValues(new Uint8Array(size));
          if (typeof msCrypto !== "undefined") return msCrypto.getRandomValues(new Uint8Array(size));
          return FillRandomBytes(new Uint8Array(size), size);
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        // mark as random - RFC 4122  4.4
        data[6] = data[6] & 0x4f | 0x40;
        data[8] = data[8] & 0xbf | 0x80;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8) result += "-";
          if (byte < 16) result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
    function MakeDictionary(obj) {
      obj.__ = undefined;
      delete obj.__;
      return obj;
    }
  });
})(Reflect || (Reflect = {}));

/***/ }),

/***/ 10810:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   nY: () => (/* binding */ defineStore)
/* harmony export */ });
/* unused harmony exports MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, disposePinia, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, shouldHydrate, skipHydrate, storeToRefs */
/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12189);
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */



/**
 * setActivePinia must be called to handle SSR at the top of functions like
 * `fetch`, `setup`, `serverPrefetch` and others
 */
let activePinia;
/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
// @ts-expect-error: cannot constrain the type of the return
const setActivePinia = (pinia) => (activePinia = pinia);
/**
 * Get the currently active pinia if there is any.
 */
const getActivePinia = () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia;
const piniaSymbol = (( false) ? 0 : /* istanbul ignore next */ Symbol());

function isPlainObject(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
o) {
    return (o &&
        typeof o === 'object' &&
        Object.prototype.toString.call(o) === '[object Object]' &&
        typeof o.toJSON !== 'function');
}
// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }
// TODO: can we change these to numbers?
/**
 * Possible types for SubscriptionCallback
 */
var MutationType;
(function (MutationType) {
    /**
     * Direct mutation of the state:
     *
     * - `store.name = 'new name'`
     * - `store.$state.name = 'new name'`
     * - `store.list.push('new item')`
     */
    MutationType["direct"] = "direct";
    /**
     * Mutated the state with `$patch` and an object
     *
     * - `store.$patch({ name: 'newName' })`
     */
    MutationType["patchObject"] = "patch object";
    /**
     * Mutated the state with `$patch` and a function
     *
     * - `store.$patch(state => state.name = 'newName')`
     */
    MutationType["patchFunction"] = "patch function";
    // maybe reset? for $state = {} and $reset
})(MutationType || (MutationType = {}));

const IS_CLIENT = typeof window !== 'undefined';

/*
 * FileSaver.js A saveAs() FileSaver implementation.
 *
 * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin
 * Morote.
 *
 * License : MIT
 */
// The one and only way of getting global scope in all environments
// https://stackoverflow.com/q/3277182/1008999
const _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window
    ? window
    : typeof self === 'object' && self.self === self
        ? self
        : typeof global === 'object' && global.global === global
            ? global
            : typeof globalThis === 'object'
                ? globalThis
                : { HTMLElement: null })();
function bom(blob, { autoBom = false } = {}) {
    // prepend BOM for UTF-8 XML and text/* types (including HTML)
    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
    if (autoBom &&
        /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });
    }
    return blob;
}
function download(url, name, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.responseType = 'blob';
    xhr.onload = function () {
        saveAs(xhr.response, name, opts);
    };
    xhr.onerror = function () {
        console.error('could not download file');
    };
    xhr.send();
}
function corsEnabled(url) {
    const xhr = new XMLHttpRequest();
    // use sync to avoid popup blocker
    xhr.open('HEAD', url, false);
    try {
        xhr.send();
    }
    catch (e) { }
    return xhr.status >= 200 && xhr.status <= 299;
}
// `a.click()` doesn't work for all browsers (#465)
function click(node) {
    try {
        node.dispatchEvent(new MouseEvent('click'));
    }
    catch (e) {
        const evt = document.createEvent('MouseEvents');
        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
        node.dispatchEvent(evt);
    }
}
const _navigator = typeof navigator === 'object' ? navigator : { userAgent: '' };
// Detect WebView inside a native macOS app by ruling out all browsers
// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too
// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos
const isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&
    /AppleWebKit/.test(_navigator.userAgent) &&
    !/Safari/.test(_navigator.userAgent))();
const saveAs = !IS_CLIENT
    ? () => { } // noop
    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
        typeof HTMLAnchorElement !== 'undefined' &&
            'download' in HTMLAnchorElement.prototype &&
            !isMacOSWebView
            ? downloadSaveAs
            : // Use msSaveOrOpenBlob as a second approach
                'msSaveOrOpenBlob' in _navigator
                    ? msSaveAs
                    : // Fallback to using FileReader and a popup
                        fileSaverSaveAs;
function downloadSaveAs(blob, name = 'download', opts) {
    const a = document.createElement('a');
    a.download = name;
    a.rel = 'noopener'; // tabnabbing
    // TODO: detect chrome extensions & packaged apps
    // a.target = '_blank'
    if (typeof blob === 'string') {
        // Support regular links
        a.href = blob;
        if (a.origin !== location.origin) {
            if (corsEnabled(a.href)) {
                download(blob, name, opts);
            }
            else {
                a.target = '_blank';
                click(a);
            }
        }
        else {
            click(a);
        }
    }
    else {
        // Support blobs
        a.href = URL.createObjectURL(blob);
        setTimeout(function () {
            URL.revokeObjectURL(a.href);
        }, 4e4); // 40s
        setTimeout(function () {
            click(a);
        }, 0);
    }
}
function msSaveAs(blob, name = 'download', opts) {
    if (typeof blob === 'string') {
        if (corsEnabled(blob)) {
            download(blob, name, opts);
        }
        else {
            const a = document.createElement('a');
            a.href = blob;
            a.target = '_blank';
            setTimeout(function () {
                click(a);
            });
        }
    }
    else {
        // @ts-ignore: works on windows
        navigator.msSaveOrOpenBlob(bom(blob, opts), name);
    }
}
function fileSaverSaveAs(blob, name, opts, popup) {
    // Open a popup immediately do go around popup blocker
    // Mostly only available on user interaction and the fileReader is async so...
    popup = popup || open('', '_blank');
    if (popup) {
        popup.document.title = popup.document.body.innerText = 'downloading...';
    }
    if (typeof blob === 'string')
        return download(blob, name, opts);
    const force = blob.type === 'application/octet-stream';
    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&
        typeof FileReader !== 'undefined') {
        // Safari doesn't allow downloading of blob URLs
        const reader = new FileReader();
        reader.onloadend = function () {
            let url = reader.result;
            if (typeof url !== 'string') {
                popup = null;
                throw new Error('Wrong reader.result type');
            }
            url = isChromeIOS
                ? url
                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');
            if (popup) {
                popup.location.href = url;
            }
            else {
                location.assign(url);
            }
            popup = null; // reverse-tabnabbing #460
        };
        reader.readAsDataURL(blob);
    }
    else {
        const url = URL.createObjectURL(blob);
        if (popup)
            popup.location.assign(url);
        else
            location.href = url;
        popup = null; // reverse-tabnabbing #460
        setTimeout(function () {
            URL.revokeObjectURL(url);
        }, 4e4); // 40s
    }
}

/**
 * Shows a toast or console.log
 *
 * @param message - message to log
 * @param type - different color of the tooltip
 */
function toastMessage(message, type) {
    const piniaMessage = ' ' + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {
        // No longer available :(
        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    }
    else if (type === 'error') {
        console.error(piniaMessage);
    }
    else if (type === 'warn') {
        console.warn(piniaMessage);
    }
    else {
        console.log(piniaMessage);
    }
}
function isPinia(o) {
    return '_a' in o && 'install' in o;
}

/**
 * This file contain devtools actions, they are not Pinia actions.
 */
// ---
function checkClipboardAccess() {
    if (!('clipboard' in navigator)) {
        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');
        return true;
    }
}
function checkNotFocusedError(error) {
    if (error instanceof Error &&
        error.message.toLowerCase().includes('document is not focused')) {
        toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', 'warn');
        return true;
    }
    return false;
}
async function actionGlobalCopyState(pinia) {
    if (checkClipboardAccess())
        return;
    try {
        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
        toastMessage('Global state copied to clipboard.');
    }
    catch (error) {
        if (checkNotFocusedError(error))
            return;
        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');
        console.error(error);
    }
}
async function actionGlobalPasteState(pinia) {
    if (checkClipboardAccess())
        return;
    try {
        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));
        toastMessage('Global state pasted from clipboard.');
    }
    catch (error) {
        if (checkNotFocusedError(error))
            return;
        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');
        console.error(error);
    }
}
async function actionGlobalSaveState(pinia) {
    try {
        saveAs(new Blob([JSON.stringify(pinia.state.value)], {
            type: 'text/plain;charset=utf-8',
        }), 'pinia-state.json');
    }
    catch (error) {
        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');
        console.error(error);
    }
}
let fileInput;
function getFileOpener() {
    if (!fileInput) {
        fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';
    }
    function openFile() {
        return new Promise((resolve, reject) => {
            fileInput.onchange = async () => {
                const files = fileInput.files;
                if (!files)
                    return resolve(null);
                const file = files.item(0);
                if (!file)
                    return resolve(null);
                return resolve({ text: await file.text(), file });
            };
            // @ts-ignore: TODO: changed from 4.3 to 4.4
            fileInput.oncancel = () => resolve(null);
            fileInput.onerror = reject;
            fileInput.click();
        });
    }
    return openFile;
}
async function actionGlobalOpenStateFile(pinia) {
    try {
        const open = getFileOpener();
        const result = await open();
        if (!result)
            return;
        const { text, file } = result;
        loadStoresState(pinia, JSON.parse(text));
        toastMessage(`Global state imported from "${file.name}".`);
    }
    catch (error) {
        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');
        console.error(error);
    }
}
function loadStoresState(pinia, state) {
    for (const key in state) {
        const storeState = pinia.state.value[key];
        // store is already instantiated, patch it
        if (storeState) {
            Object.assign(storeState, state[key]);
        }
        else {
            // store is not instantiated, set the initial state
            pinia.state.value[key] = state[key];
        }
    }
}

function formatDisplay(display) {
    return {
        _custom: {
            display,
        },
    };
}
const PINIA_ROOT_LABEL = ' Pinia (root)';
const PINIA_ROOT_ID = '_root';
function formatStoreForInspectorTree(store) {
    return isPinia(store)
        ? {
            id: PINIA_ROOT_ID,
            label: PINIA_ROOT_LABEL,
        }
        : {
            id: store.$id,
            label: store.$id,
        };
}
function formatStoreForInspectorState(store) {
    if (isPinia(store)) {
        const storeNames = Array.from(store._s.keys());
        const storeMap = store._s;
        const state = {
            state: storeNames.map((storeId) => ({
                editable: true,
                key: storeId,
                value: store.state.value[storeId],
            })),
            getters: storeNames
                .filter((id) => storeMap.get(id)._getters)
                .map((id) => {
                const store = storeMap.get(id);
                return {
                    editable: false,
                    key: id,
                    value: store._getters.reduce((getters, key) => {
                        getters[key] = store[key];
                        return getters;
                    }, {}),
                };
            }),
        };
        return state;
    }
    const state = {
        state: Object.keys(store.$state).map((key) => ({
            editable: true,
            key,
            value: store.$state[key],
        })),
    };
    // avoid adding empty getters
    if (store._getters && store._getters.length) {
        state.getters = store._getters.map((getterName) => ({
            editable: false,
            key: getterName,
            value: store[getterName],
        }));
    }
    if (store._customProperties.size) {
        state.customProperties = Array.from(store._customProperties).map((key) => ({
            editable: true,
            key,
            value: store[key],
        }));
    }
    return state;
}
function formatEventData(events) {
    if (!events)
        return {};
    if (Array.isArray(events)) {
        // TODO: handle add and delete for arrays and objects
        return events.reduce((data, event) => {
            data.keys.push(event.key);
            data.operations.push(event.type);
            data.oldValue[event.key] = event.oldValue;
            data.newValue[event.key] = event.newValue;
            return data;
        }, {
            oldValue: {},
            keys: [],
            operations: [],
            newValue: {},
        });
    }
    else {
        return {
            operation: formatDisplay(events.type),
            key: formatDisplay(events.key),
            oldValue: events.oldValue,
            newValue: events.newValue,
        };
    }
}
function formatMutationType(type) {
    switch (type) {
        case MutationType.direct:
            return 'mutation';
        case MutationType.patchFunction:
            return '$patch';
        case MutationType.patchObject:
            return '$patch';
        default:
            return 'unknown';
    }
}

// timeline can be paused when directly changing the state
let isTimelineActive = true;
const componentStateTypes = (/* unused pure expression or super */ null && ([]));
const MUTATIONS_LAYER_ID = 'pinia:mutations';
const INSPECTOR_ID = 'pinia';
const { assign: assign$1 } = Object;
/**
 * Gets the displayed name of a store in devtools
 *
 * @param id - id of the store
 * @returns a formatted string
 */
const getStoreType = (id) => ' ' + id;
/**
 * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab
 * as soon as it is added to the application.
 *
 * @param app - Vue application
 * @param pinia - pinia instance
 */
function registerPiniaDevtools(app, pinia) {
    setupDevtoolsPlugin({
        id: 'dev.esm.pinia',
        label: 'Pinia ',
        logo: 'https://pinia.vuejs.org/logo.svg',
        packageName: 'pinia',
        homepage: 'https://pinia.vuejs.org',
        componentStateTypes,
        app,
    }, (api) => {
        if (typeof api.now !== 'function') {
            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');
        }
        api.addTimelineLayer({
            id: MUTATIONS_LAYER_ID,
            label: `Pinia `,
            color: 0xe5df88,
        });
        api.addInspector({
            id: INSPECTOR_ID,
            label: 'Pinia ',
            icon: 'storage',
            treeFilterPlaceholder: 'Search stores',
            actions: [
                {
                    icon: 'content_copy',
                    action: () => {
                        actionGlobalCopyState(pinia);
                    },
                    tooltip: 'Serialize and copy the state',
                },
                {
                    icon: 'content_paste',
                    action: async () => {
                        await actionGlobalPasteState(pinia);
                        api.sendInspectorTree(INSPECTOR_ID);
                        api.sendInspectorState(INSPECTOR_ID);
                    },
                    tooltip: 'Replace the state with the content of your clipboard',
                },
                {
                    icon: 'save',
                    action: () => {
                        actionGlobalSaveState(pinia);
                    },
                    tooltip: 'Save the state as a JSON file',
                },
                {
                    icon: 'folder_open',
                    action: async () => {
                        await actionGlobalOpenStateFile(pinia);
                        api.sendInspectorTree(INSPECTOR_ID);
                        api.sendInspectorState(INSPECTOR_ID);
                    },
                    tooltip: 'Import the state from a JSON file',
                },
            ],
            nodeActions: [
                {
                    icon: 'restore',
                    tooltip: 'Reset the state (with "$reset")',
                    action: (nodeId) => {
                        const store = pinia._s.get(nodeId);
                        if (!store) {
                            toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, 'warn');
                        }
                        else if (typeof store.$reset !== 'function') {
                            toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, 'warn');
                        }
                        else {
                            store.$reset();
                            toastMessage(`Store "${nodeId}" reset.`);
                        }
                    },
                },
            ],
        });
        api.on.inspectComponent((payload, ctx) => {
            const proxy = (payload.componentInstance &&
                payload.componentInstance.proxy);
            if (proxy && proxy._pStores) {
                const piniaStores = payload.componentInstance.proxy._pStores;
                Object.values(piniaStores).forEach((store) => {
                    payload.instanceData.state.push({
                        type: getStoreType(store.$id),
                        key: 'state',
                        editable: true,
                        value: store._isOptionsAPI
                            ? {
                                _custom: {
                                    value: toRaw(store.$state),
                                    actions: [
                                        {
                                            icon: 'restore',
                                            tooltip: 'Reset the state of this store',
                                            action: () => store.$reset(),
                                        },
                                    ],
                                },
                            }
                            : // NOTE: workaround to unwrap transferred refs
                                Object.keys(store.$state).reduce((state, key) => {
                                    state[key] = store.$state[key];
                                    return state;
                                }, {}),
                    });
                    if (store._getters && store._getters.length) {
                        payload.instanceData.state.push({
                            type: getStoreType(store.$id),
                            key: 'getters',
                            editable: false,
                            value: store._getters.reduce((getters, key) => {
                                try {
                                    getters[key] = store[key];
                                }
                                catch (error) {
                                    // @ts-expect-error: we just want to show it in devtools
                                    getters[key] = error;
                                }
                                return getters;
                            }, {}),
                        });
                    }
                });
            }
        });
        api.on.getInspectorTree((payload) => {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                let stores = [pinia];
                stores = stores.concat(Array.from(pinia._s.values()));
                payload.rootNodes = (payload.filter
                    ? stores.filter((store) => '$id' in store
                        ? store.$id
                            .toLowerCase()
                            .includes(payload.filter.toLowerCase())
                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))
                    : stores).map(formatStoreForInspectorTree);
            }
        });
        // Expose pinia instance as $pinia to window
        globalThis.$pinia = pinia;
        api.on.getInspectorState((payload) => {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                const inspectedStore = payload.nodeId === PINIA_ROOT_ID
                    ? pinia
                    : pinia._s.get(payload.nodeId);
                if (!inspectedStore) {
                    // this could be the selected store restored for a different project
                    // so it's better not to say anything here
                    return;
                }
                if (inspectedStore) {
                    // Expose selected store as $store to window
                    if (payload.nodeId !== PINIA_ROOT_ID)
                        globalThis.$store = toRaw(inspectedStore);
                    payload.state = formatStoreForInspectorState(inspectedStore);
                }
            }
        });
        api.on.editInspectorState((payload, ctx) => {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                const inspectedStore = payload.nodeId === PINIA_ROOT_ID
                    ? pinia
                    : pinia._s.get(payload.nodeId);
                if (!inspectedStore) {
                    return toastMessage(`store "${payload.nodeId}" not found`, 'error');
                }
                const { path } = payload;
                if (!isPinia(inspectedStore)) {
                    // access only the state
                    if (path.length !== 1 ||
                        !inspectedStore._customProperties.has(path[0]) ||
                        path[0] in inspectedStore.$state) {
                        path.unshift('$state');
                    }
                }
                else {
                    // Root access, we can omit the `.value` because the devtools API does it for us
                    path.unshift('state');
                }
                isTimelineActive = false;
                payload.set(inspectedStore, path, payload.state.value);
                isTimelineActive = true;
            }
        });
        api.on.editComponentState((payload) => {
            if (payload.type.startsWith('')) {
                const storeId = payload.type.replace(/^\s*/, '');
                const store = pinia._s.get(storeId);
                if (!store) {
                    return toastMessage(`store "${storeId}" not found`, 'error');
                }
                const { path } = payload;
                if (path[0] !== 'state') {
                    return toastMessage(`Invalid path for store "${storeId}":\n${path}\nOnly state can be modified.`);
                }
                // rewrite the first entry to be able to directly set the state as
                // well as any other path
                path[0] = '$state';
                isTimelineActive = false;
                payload.set(store, path, payload.state.value);
                isTimelineActive = true;
            }
        });
    });
}
function addStoreToDevtools(app, store) {
    if (!componentStateTypes.includes(getStoreType(store.$id))) {
        componentStateTypes.push(getStoreType(store.$id));
    }
    setupDevtoolsPlugin({
        id: 'dev.esm.pinia',
        label: 'Pinia ',
        logo: 'https://pinia.vuejs.org/logo.svg',
        packageName: 'pinia',
        homepage: 'https://pinia.vuejs.org',
        componentStateTypes,
        app,
        settings: {
            logStoreChanges: {
                label: 'Notify about new/deleted stores',
                type: 'boolean',
                defaultValue: true,
            },
            // useEmojis: {
            //   label: 'Use emojis in messages ',
            //   type: 'boolean',
            //   defaultValue: true,
            // },
        },
    }, (api) => {
        // gracefully handle errors
        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;
        store.$onAction(({ after, onError, name, args }) => {
            const groupId = runningActionId++;
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                    time: now(),
                    title: ' ' + name,
                    subtitle: 'start',
                    data: {
                        store: formatDisplay(store.$id),
                        action: formatDisplay(name),
                        args,
                    },
                    groupId,
                },
            });
            after((result) => {
                activeAction = undefined;
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: now(),
                        title: ' ' + name,
                        subtitle: 'end',
                        data: {
                            store: formatDisplay(store.$id),
                            action: formatDisplay(name),
                            args,
                            result,
                        },
                        groupId,
                    },
                });
            });
            onError((error) => {
                activeAction = undefined;
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: now(),
                        logType: 'error',
                        title: ' ' + name,
                        subtitle: 'end',
                        data: {
                            store: formatDisplay(store.$id),
                            action: formatDisplay(name),
                            args,
                            error,
                        },
                        groupId,
                    },
                });
            });
        }, true);
        store._customProperties.forEach((name) => {
            watch(() => unref(store[name]), (newValue, oldValue) => {
                api.notifyComponentUpdate();
                api.sendInspectorState(INSPECTOR_ID);
                if (isTimelineActive) {
                    api.addTimelineEvent({
                        layerId: MUTATIONS_LAYER_ID,
                        event: {
                            time: now(),
                            title: 'Change',
                            subtitle: name,
                            data: {
                                newValue,
                                oldValue,
                            },
                            groupId: activeAction,
                        },
                    });
                }
            }, { deep: true });
        });
        store.$subscribe(({ events, type }, state) => {
            api.notifyComponentUpdate();
            api.sendInspectorState(INSPECTOR_ID);
            if (!isTimelineActive)
                return;
            // rootStore.state[store.id] = state
            const eventData = {
                time: now(),
                title: formatMutationType(type),
                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
                groupId: activeAction,
            };
            if (type === MutationType.patchFunction) {
                eventData.subtitle = '';
            }
            else if (type === MutationType.patchObject) {
                eventData.subtitle = '';
            }
            else if (events && !Array.isArray(events)) {
                eventData.subtitle = events.type;
            }
            if (events) {
                eventData.data['rawEvent(s)'] = {
                    _custom: {
                        display: 'DebuggerEvent',
                        type: 'object',
                        tooltip: 'raw DebuggerEvent[]',
                        value: events,
                    },
                };
            }
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: eventData,
            });
        }, { detached: true, flush: 'sync' });
        const hotUpdate = store._hotUpdate;
        store._hotUpdate = markRaw((newStore) => {
            hotUpdate(newStore);
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                    time: now(),
                    title: ' ' + store.$id,
                    subtitle: 'HMR update',
                    data: {
                        store: formatDisplay(store.$id),
                        info: formatDisplay(`HMR update`),
                    },
                },
            });
            // update the devtools too
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
        });
        const { $dispose } = store;
        store.$dispose = () => {
            $dispose();
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
            api.getSettings().logStoreChanges &&
                toastMessage(`Disposed "${store.$id}" store `);
        };
        // trigger an update so it can display new registered stores
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges &&
            toastMessage(`"${store.$id}" store installed `);
    });
}
let runningActionId = 0;
let activeAction;
/**
 * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the
 * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state
 * mutation to the action.
 *
 * @param store - store to patch
 * @param actionNames - list of actionst to patch
 */
function patchActionForGrouping(store, actionNames, wrapWithProxy) {
    // original actions of the store as they are given by pinia. We are going to override them
    const actions = actionNames.reduce((storeActions, actionName) => {
        // use toRaw to avoid tracking #541
        storeActions[actionName] = toRaw(store)[actionName];
        return storeActions;
    }, {});
    for (const actionName in actions) {
        store[actionName] = function () {
            // the running action id is incremented in a before action hook
            const _actionId = runningActionId;
            const trackedStore = wrapWithProxy
                ? new Proxy(store, {
                    get(...args) {
                        activeAction = _actionId;
                        return Reflect.get(...args);
                    },
                    set(...args) {
                        activeAction = _actionId;
                        return Reflect.set(...args);
                    },
                })
                : store;
            // For Setup Stores we need https://github.com/tc39/proposal-async-context
            activeAction = _actionId;
            const retValue = actions[actionName].apply(trackedStore, arguments);
            // this is safer as async actions in Setup Stores would associate mutations done outside of the action
            activeAction = undefined;
            return retValue;
        };
    }
}
/**
 * pinia.use(devtoolsPlugin)
 */
function devtoolsPlugin({ app, store, options }) {
    // HMR module
    if (store.$id.startsWith('__hot:')) {
        return;
    }
    // detect option api vs setup api
    store._isOptionsAPI = !!options.state;
    // Do not overwrite actions mocked by @pinia/testing (#2298)
    if (!store._p._testing) {
        patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
        // Upgrade the HMR to also update the new actions
        const originalHotUpdate = store._hotUpdate;
        toRaw(store)._hotUpdate = function (newStore) {
            originalHotUpdate.apply(this, arguments);
            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
        };
    }
    addStoreToDevtools(app, 
    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
    store);
}

/**
 * Creates a Pinia instance to be used by the application
 */
function createPinia() {
    const scope = effectScope(true);
    // NOTE: here we could check the window object for a state and directly set it
    // if there is anything like it with Vue 3 SSR
    const state = scope.run(() => ref({}));
    let _p = [];
    // plugins added before calling app.use(pinia)
    let toBeInstalled = [];
    const pinia = markRaw({
        install(app) {
            // this allows calling useStore() outside of a component setup after
            // installing pinia's plugin
            setActivePinia(pinia);
            if (!isVue2) {
                pinia._a = app;
                app.provide(piniaSymbol, pinia);
                app.config.globalProperties.$pinia = pinia;
                /* istanbul ignore else */
                if (((( false) || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !("production" === 'test')) && IS_CLIENT) {
                    registerPiniaDevtools(app, pinia);
                }
                toBeInstalled.forEach((plugin) => _p.push(plugin));
                toBeInstalled = [];
            }
        },
        use(plugin) {
            if (!this._a && !isVue2) {
                toBeInstalled.push(plugin);
            }
            else {
                _p.push(plugin);
            }
            return this;
        },
        _p,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope,
        _s: new Map(),
        state,
    });
    // pinia devtools rely on dev only features so they cannot be forced unless
    // the dev build of Vue is used. Avoid old browsers like IE11.
    if (((( false) || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !("production" === 'test')) && IS_CLIENT && typeof Proxy !== 'undefined') {
        pinia.use(devtoolsPlugin);
    }
    return pinia;
}
/**
 * Dispose a Pinia instance by stopping its effectScope and removing the state, plugins and stores. This is mostly
 * useful in tests, with both a testing pinia or a regular pinia and in applications that use multiple pinia instances.
 * Once disposed, the pinia instance cannot be used anymore.
 *
 * @param pinia - pinia instance
 */
function disposePinia(pinia) {
    pinia._e.stop();
    pinia._s.clear();
    pinia._p.splice(0);
    pinia.state.value = {};
    // @ts-expect-error: non valid
    pinia._a = null;
}

/**
 * Checks if a function is a `StoreDefinition`.
 *
 * @param fn - object to test
 * @returns true if `fn` is a StoreDefinition
 */
const isUseStore = (fn) => {
    return typeof fn === 'function' && typeof fn.$id === 'string';
};
/**
 * Mutates in place `newState` with `oldState` to _hot update_ it. It will
 * remove any key not existing in `newState` and recursively merge plain
 * objects.
 *
 * @param newState - new state object to be patched
 * @param oldState - old state that should be used to patch newState
 * @returns - newState
 */
function patchObject(newState, oldState) {
    // no need to go through symbols because they cannot be serialized anyway
    for (const key in oldState) {
        const subPatch = oldState[key];
        // skip the whole sub tree
        if (!(key in newState)) {
            continue;
        }
        const targetValue = newState[key];
        if (isPlainObject(targetValue) &&
            isPlainObject(subPatch) &&
            !isRef(subPatch) &&
            !isReactive(subPatch)) {
            newState[key] = patchObject(targetValue, subPatch);
        }
        else {
            // objects are either a bit more complex (e.g. refs) or primitives, so we
            // just set the whole thing
            if (isVue2) {
                set(newState, key, subPatch);
            }
            else {
                newState[key] = subPatch;
            }
        }
    }
    return newState;
}
/**
 * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.
 *
 * @example
 * ```js
 * const useUser = defineStore(...)
 * if (import.meta.hot) {
 *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))
 * }
 * ```
 *
 * @param initialUseStore - return of the defineStore to hot update
 * @param hot - `import.meta.hot`
 */
function acceptHMRUpdate(initialUseStore, hot) {
    // strip as much as possible from iife.prod
    if (true) {
        return () => { };
    }
    return (newModule) => {
        const pinia = hot.data.pinia || initialUseStore._pinia;
        if (!pinia) {
            // this store is still not used
            return;
        }
        // preserve the pinia instance across loads
        hot.data.pinia = pinia;
        // console.log('got data', newStore)
        for (const exportName in newModule) {
            const useStore = newModule[exportName];
            // console.log('checking for', exportName)
            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {
                // console.log('Accepting update for', useStore.$id)
                const id = useStore.$id;
                if (id !== initialUseStore.$id) {
                    console.warn(`The id of the store changed from "${initialUseStore.$id}" to "${id}". Reloading.`);
                    // return import.meta.hot.invalidate()
                    return hot.invalidate();
                }
                const existingStore = pinia._s.get(id);
                if (!existingStore) {
                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);
                    return;
                }
                useStore(pinia, existingStore);
            }
        }
    };
}

const noop = () => { };
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
        }
    };
    if (!detached && (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentScope */ .o55)()) {
        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .onScopeDispose */ .jr2)(removeSubscription);
    }
    return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
        callback(...args);
    });
}

const fallbackRunWithContext = (fn) => fn();
/**
 * Marks a function as an action for `$onAction`
 * @internal
 */
const ACTION_MARKER = Symbol();
/**
 * Action name symbol. Allows to add a name to an action after defining it
 * @internal
 */
const ACTION_NAME = Symbol();
function mergeReactiveObjects(target, patchToApply) {
    // Handle Map instances
    if (target instanceof Map && patchToApply instanceof Map) {
        patchToApply.forEach((value, key) => target.set(key, value));
    }
    else if (target instanceof Set && patchToApply instanceof Set) {
        // Handle Set instances
        patchToApply.forEach(target.add, target);
    }
    // no need to go through symbols because they cannot be serialized anyway
    for (const key in patchToApply) {
        if (!patchToApply.hasOwnProperty(key))
            continue;
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject(targetValue) &&
            isPlainObject(subPatch) &&
            target.hasOwnProperty(key) &&
            !(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isRef */ .i9z)(subPatch) &&
            !(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isReactive */ .g8q)(subPatch)) {
            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might
            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that
            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.
            target[key] = mergeReactiveObjects(targetValue, subPatch);
        }
        else {
            // @ts-expect-error: subPatch is a valid value
            target[key] = subPatch;
        }
    }
    return target;
}
const skipHydrateSymbol = ( false)
    ? 0
    : /* istanbul ignore next */ Symbol();
/**
 * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a
 * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.
 *
 * @param obj - target object
 * @returns obj
 */
function skipHydrate(obj) {
    return Object.defineProperty(obj, skipHydrateSymbol, {});
}
/**
 * Returns whether a value should be hydrated
 *
 * @param obj - target variable
 * @returns true if `obj` should be hydrated
 */
function shouldHydrate(obj) {
    return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign } = Object;
function isComputed(o) {
    return !!((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isRef */ .i9z)(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
        if (!initialState && ( true || 0)) {
            /* istanbul ignore if */
            if (vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isVue2 */ .LER) {
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .set */ .hZp)(pinia.state.value, id, state ? state() : {});
            }
            else {
                pinia.state.value[id] = state ? state() : {};
            }
        }
        // avoid creating a state in pinia.state.value
        const localState =  false
            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary
                0
            : (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .toRefs */ .QWb)(pinia.state.value[id]);
        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            if (false) {}
            computedGetters[name] = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .markRaw */ .IGZ)((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EWP)(() => {
                setActivePinia(pinia);
                // it was created just before
                const store = pinia._s.get(id);
                // allow cross using stores
                /* istanbul ignore if */
                if (vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isVue2 */ .LER && !store._r)
                    return;
                // @ts-expect-error
                // return getters![name].call(context, context)
                // TODO: avoid reading the getter while assigning with a global variable
                return getters[name].call(store, store);
            }));
            return computedGetters;
        }, {}));
    }
    store = createSetupStore(id, setup, options, pinia, hot, true);
    return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    /* istanbul ignore if */
    if (false) {}
    // watcher options for $subscribe
    const $subscribeOptions = { deep: true };
    /* istanbul ignore else */
    if (false) {}
    // internal state
    let isListening; // set to true at the end
    let isSyncListening; // set to true at the end
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    // avoid setting the state for option stores if it is set
    // by the setup
    if (!isOptionsStore && !initialState && ( true || 0)) {
        /* istanbul ignore if */
        if (vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isVue2 */ .LER) {
            (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .set */ .hZp)(pinia.state.value, $id, {});
        }
        else {
            pinia.state.value[$id] = {};
        }
    }
    const hotState = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .KRz)({});
    // avoid triggering too many listeners
    // https://github.com/vuejs/pinia/issues/1129
    let activeListener;
    function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        // reset the debugger events since patches are sync
        /* istanbul ignore else */
        if ((false)) {}
        if (typeof partialStateOrMutator === 'function') {
            partialStateOrMutator(pinia.state.value[$id]);
            subscriptionMutation = {
                type: MutationType.patchFunction,
                storeId: $id,
                events: debuggerEvents,
            };
        }
        else {
            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
                type: MutationType.patchObject,
                payload: partialStateOrMutator,
                storeId: $id,
                events: debuggerEvents,
            };
        }
        const myListenerId = (activeListener = Symbol());
        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .nextTick */ .dYV)().then(() => {
            if (activeListener === myListenerId) {
                isListening = true;
            }
        });
        isSyncListening = true;
        // because we paused the watcher, we need to manually call the subscriptions
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore
        ? function $reset() {
            const { state } = options;
            const newState = state ? state() : {};
            // we use a patch to group all changes into one single subscription
            this.$patch(($state) => {
                // @ts-expect-error: FIXME: shouldn't error?
                assign($state, newState);
            });
        }
        : /* istanbul ignore next */
            ( false)
                ? 0
                : noop;
    function $dispose() {
        scope.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia._s.delete($id);
    }
    /**
     * Helper that wraps function so it can be tracked with $onAction
     * @param fn - action to wrap
     * @param name - name of the action
     */
    const action = (fn, name = '') => {
        if (ACTION_MARKER in fn) {
            fn[ACTION_NAME] = name;
            return fn;
        }
        const wrappedAction = function () {
            setActivePinia(pinia);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
                afterCallbackList.push(callback);
            }
            function onError(callback) {
                onErrorCallbackList.push(callback);
            }
            // @ts-expect-error
            triggerSubscriptions(actionSubscriptions, {
                args,
                name: wrappedAction[ACTION_NAME],
                store,
                after,
                onError,
            });
            let ret;
            try {
                ret = fn.apply(this && this.$id === $id ? this : store, args);
                // handle sync errors
            }
            catch (error) {
                triggerSubscriptions(onErrorCallbackList, error);
                throw error;
            }
            if (ret instanceof Promise) {
                return ret
                    .then((value) => {
                    triggerSubscriptions(afterCallbackList, value);
                    return value;
                })
                    .catch((error) => {
                    triggerSubscriptions(onErrorCallbackList, error);
                    return Promise.reject(error);
                });
            }
            // trigger after callbacks
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
        };
        wrappedAction[ACTION_MARKER] = true;
        wrappedAction[ACTION_NAME] = name; // will be set later
        // @ts-expect-error: we are intentionally limiting the returned type to just Fn
        // because all the added properties are internals that are exposed through `$onAction()` only
        return wrappedAction;
    };
    const _hmrPayload = /*#__PURE__*/ (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .markRaw */ .IGZ)({
        actions: {},
        getters: {},
        state: [],
        hotState,
    });
    const partialStore = {
        _p: pinia,
        // _s: scope,
        $id,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .watch */ .wBe)(() => pinia.state.value[$id], (state) => {
                if (options.flush === 'sync' ? isSyncListening : isListening) {
                    callback({
                        storeId: $id,
                        type: MutationType.direct,
                        events: debuggerEvents,
                    }, state);
                }
            }, assign({}, $subscribeOptions, options)));
            return removeSubscription;
        },
        $dispose,
    };
    /* istanbul ignore if */
    if (vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isVue2 */ .LER) {
        // start as non ready
        partialStore._r = false;
    }
    const store = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .reactive */ .Kh)(( false) || (((( false) || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !("production" === 'test')) && IS_CLIENT)
        ? assign({
            _hmrPayload,
            _customProperties: (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .markRaw */ .IGZ)(new Set()), // devtools custom properties
        }, partialStore
        // must be added later
        // setupStore
        )
        : partialStore);
    // store the partial store now so the setup of stores can instantiate each other before they are finished without
    // creating infinite loops.
    pinia._s.set($id, store);
    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;
    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .effectScope */ .uYQ)()).run(() => setup({ action }))));
    // overwrite existing actions to support $onAction
    for (const key in setupStore) {
        const prop = setupStore[key];
        if (((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isRef */ .i9z)(prop) && !isComputed(prop)) || (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isReactive */ .g8q)(prop)) {
            // mark it as a piece of state to be serialized
            if (false) {}
            else if (!isOptionsStore) {
                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created
                if (initialState && shouldHydrate(prop)) {
                    if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isRef */ .i9z)(prop)) {
                        prop.value = initialState[key];
                    }
                    else {
                        // probably a reactive object, lets recursively assign
                        // @ts-expect-error: prop is unknown
                        mergeReactiveObjects(prop, initialState[key]);
                    }
                }
                // transfer the ref to the pinia state to keep everything in sync
                /* istanbul ignore if */
                if (vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isVue2 */ .LER) {
                    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .set */ .hZp)(pinia.state.value[$id], key, prop);
                }
                else {
                    pinia.state.value[$id][key] = prop;
                }
            }
            /* istanbul ignore else */
            if ((false)) {}
            // action
        }
        else if (typeof prop === 'function') {
            const actionValue =  false ? 0 : action(prop, key);
            // this a hot module replacement store because the hotUpdate method needs
            // to do it with the right context
            /* istanbul ignore if */
            if (vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isVue2 */ .LER) {
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .set */ .hZp)(setupStore, key, actionValue);
            }
            else {
                // @ts-expect-error
                setupStore[key] = actionValue;
            }
            /* istanbul ignore else */
            if ((false)) {}
            // list actions so they can be used in plugins
            // @ts-expect-error
            optionsForPlugin.actions[key] = prop;
        }
        else if ((false)) {}
    }
    // add the state, getters, and action properties
    /* istanbul ignore if */
    if (vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isVue2 */ .LER) {
        Object.keys(setupStore).forEach((key) => {
            (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .set */ .hZp)(store, key, setupStore[key]);
        });
    }
    else {
        assign(store, setupStore);
        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.
        // Make `storeToRefs()` work with `reactive()` #799
        assign((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .toRaw */ .uxp)(store), setupStore);
    }
    // use this instead of a computed with setter to be able to create it anywhere
    // without linking the computed lifespan to wherever the store is first
    // created.
    Object.defineProperty(store, '$state', {
        get: () => ( false ? 0 : pinia.state.value[$id]),
        set: (state) => {
            /* istanbul ignore if */
            if (false) {}
            $patch(($state) => {
                // @ts-expect-error: FIXME: shouldn't error?
                assign($state, state);
            });
        },
    });
    // add the hotUpdate before plugins to allow them to override it
    /* istanbul ignore else */
    if ((false)) {}
    if (((( false) || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !("production" === 'test')) && IS_CLIENT) {
        const nonEnumerable = {
            writable: true,
            configurable: true,
            // avoid warning on devtools trying to display this property
            enumerable: false,
        };
        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {
            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));
        });
    }
    /* istanbul ignore if */
    if (vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .isVue2 */ .LER) {
        // mark the store as ready before plugins
        store._r = true;
    }
    // apply all plugins
    pinia._p.forEach((extender) => {
        /* istanbul ignore else */
        if (((( false) || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !("production" === 'test')) && IS_CLIENT) {
            const extensions = scope.run(() => extender({
                store: store,
                app: pinia._a,
                pinia,
                options: optionsForPlugin,
            }));
            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
            assign(store, extensions);
        }
        else {
            assign(store, scope.run(() => extender({
                store: store,
                app: pinia._a,
                pinia,
                options: optionsForPlugin,
            })));
        }
    });
    if (false) {}
    // only apply hydrate to option stores with an initial state in pinia
    if (initialState &&
        isOptionsStore &&
        options.hydrate) {
        options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
}
// allows unused stores to be tree shaken
/*! #__NO_SIDE_EFFECTS__ */
function defineStore(
// TODO: add proper types from above
idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === 'function';
    if (typeof idOrOptions === 'string') {
        id = idOrOptions;
        // the option store setup will contain the actual options in this case
        options = isSetupStore ? setupOptions : setup;
    }
    else {
        options = idOrOptions;
        id = idOrOptions.id;
        if (false) {}
    }
    function useStore(pinia, hot) {
        const hasContext = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .hasInjectionContext */ .PSC)();
        pinia =
            // in test mode, ignore the argument provided as we can always retrieve a
            // pinia instance with getActivePinia()
            ( false ? 0 : pinia) ||
                (hasContext ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQX)(piniaSymbol, null) : null);
        if (pinia)
            setActivePinia(pinia);
        if (false) {}
        pinia = activePinia;
        if (!pinia._s.has(id)) {
            // creating the store registers it in `pinia._s`
            if (isSetupStore) {
                createSetupStore(id, setup, options, pinia);
            }
            else {
                createOptionsStore(id, options, pinia);
            }
            /* istanbul ignore else */
            if ((false)) {}
        }
        const store = pinia._s.get(id);
        if (false) {}
        if (false) {}
        // StoreGeneric cannot be casted towards Store
        return store;
    }
    useStore.$id = id;
    return useStore;
}

let mapStoreSuffix = 'Store';
/**
 * Changes the suffix added by `mapStores()`. Can be set to an empty string.
 * Defaults to `"Store"`. Make sure to extend the MapStoresCustomization
 * interface if you are using TypeScript.
 *
 * @param suffix - new suffix
 */
function setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS
) {
    mapStoreSuffix = suffix;
}
/**
 * Allows using stores without the composition API (`setup()`) by generating an
 * object to be spread in the `computed` field of a component. It accepts a list
 * of store definitions.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapStores(useUserStore, useCartStore)
 *   },
 *
 *   created() {
 *     this.userStore // store with id "user"
 *     this.cartStore // store with id "cart"
 *   }
 * }
 * ```
 *
 * @param stores - list of stores to map to an object
 */
function mapStores(...stores) {
    if (false) {}
    return stores.reduce((reduced, useStore) => {
        // @ts-expect-error: $id is added by defineStore
        reduced[useStore.$id + mapStoreSuffix] = function () {
            return useStore(this.$pinia);
        };
        return reduced;
    }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            reduced[key] = function () {
                // @ts-expect-error: FIXME: should work?
                return useStore(this.$pinia)[key];
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function () {
                const store = useStore(this.$pinia);
                const storeKey = keysOrMapper[key];
                // for some reason TS is unable to infer the type of storeKey to be a
                // function
                return typeof storeKey === 'function'
                    ? storeKey.call(this, store)
                    : // @ts-expect-error: FIXME: should work?
                        store[storeKey];
            };
            return reduced;
        }, {});
}
/**
 * Alias for `mapState()`. You should use `mapState()` instead.
 * @deprecated use `mapState()` instead.
 */
const mapGetters = (/* unused pure expression or super */ null && (mapState));
/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapActions(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                // @ts-expect-error: FIXME: should work?
                return useStore(this.$pinia)[key](...args);
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                // @ts-expect-error: FIXME: should work?
                return useStore(this.$pinia)[keysOrMapper[key]](...args);
            };
            return reduced;
        }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapWritableState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            reduced[key] = {
                get() {
                    return useStore(this.$pinia)[key];
                },
                set(value) {
                    return (useStore(this.$pinia)[key] = value);
                },
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            reduced[key] = {
                get() {
                    return useStore(this.$pinia)[keysOrMapper[key]];
                },
                set(value) {
                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);
                },
            };
            return reduced;
        }, {});
}

/**
 * Creates an object of references with all the state, getters, and plugin-added
 * state properties of the store. Similar to `toRefs()` but specifically
 * designed for Pinia stores so methods and non reactive properties are
 * completely ignored.
 *
 * @param store - store to extract the refs from
 */
function storeToRefs(store) {
    // See https://github.com/vuejs/pinia/issues/852
    // It's easier to just use toRefs() even if it includes more stuff
    if (isVue2) {
        // @ts-expect-error: toRefs include methods and others
        return toRefs(store);
    }
    else {
        const rawStore = toRaw(store);
        const refs = {};
        for (const key in rawStore) {
            const value = rawStore[key];
            // There is no native method to check for a computed
            // https://github.com/vuejs/core/pull/4165
            if (value.effect) {
                // @ts-expect-error: too hard to type correctly
                refs[key] =
                    // ...
                    computed({
                        get: () => store[key],
                        set(value) {
                            store[key] = value;
                        },
                    });
            }
            else if (isRef(value) || isReactive(value)) {
                // @ts-expect-error: the key is state or getter
                refs[key] =
                    // ---
                    toRef(store, key);
            }
        }
        return refs;
    }
}

/**
 * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need
 * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:
 * https://pinia.vuejs.org/ssr/nuxt.html.
 *
 * @example
 * ```js
 * import Vue from 'vue'
 * import { PiniaVuePlugin, createPinia } from 'pinia'
 *
 * Vue.use(PiniaVuePlugin)
 * const pinia = createPinia()
 *
 * new Vue({
 *   el: '#app',
 *   // ...
 *   pinia,
 * })
 * ```
 *
 * @param _Vue - `Vue` imported from 'vue'.
 */
const PiniaVuePlugin = function (_Vue) {
    // Equivalent of
    // app.config.globalProperties.$pinia = pinia
    _Vue.mixin({
        beforeCreate() {
            const options = this.$options;
            if (options.pinia) {
                const pinia = options.pinia;
                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31
                /* istanbul ignore else */
                if (!this._provided) {
                    const provideCache = {};
                    Object.defineProperty(this, '_provided', {
                        get: () => provideCache,
                        set: (v) => Object.assign(provideCache, v),
                    });
                }
                this._provided[piniaSymbol] = pinia;
                // propagate the pinia instance in an SSR friendly way
                // avoid adding it to nuxt twice
                /* istanbul ignore else */
                if (!this.$pinia) {
                    this.$pinia = pinia;
                }
                pinia._a = this;
                if (IS_CLIENT) {
                    // this allows calling useStore() outside of a component setup after
                    // installing pinia's plugin
                    setActivePinia(pinia);
                }
                if (((( false) || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !("production" === 'test')) && IS_CLIENT) {
                    registerPiniaDevtools(pinia._a, pinia);
                }
            }
            else if (!this.$pinia && options.parent && options.parent.$pinia) {
                this.$pinia = options.parent.$pinia;
            }
        },
        destroyed() {
            delete this._pStores;
        },
    });
};




/***/ }),

/***/ 12189:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EWP: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.EW),
/* harmony export */   IGZ: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.IG),
/* harmony export */   KRz: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.KR),
/* harmony export */   Kh: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Kh),
/* harmony export */   LER: () => (/* binding */ isVue2),
/* harmony export */   PSC: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.PS),
/* harmony export */   QWb: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.QW),
/* harmony export */   WQX: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.WQ),
/* harmony export */   dYV: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.dY),
/* harmony export */   g8q: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.g8),
/* harmony export */   hZp: () => (/* binding */ set),
/* harmony export */   i9z: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.i9),
/* harmony export */   jr2: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.jr),
/* harmony export */   o55: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.o5),
/* harmony export */   uYQ: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.uY),
/* harmony export */   uxp: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ux),
/* harmony export */   wBe: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.wB)
/* harmony export */ });
/* unused harmony exports del, Vue2, isVue3, install */
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23568);


var isVue2 = false
var isVue3 = true
var Vue2 = (/* unused pure expression or super */ null && (undefined))

function install() {}

function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  target[key] = val
  return val
}

function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1)
    return
  }
  delete target[key]
}





/***/ }),

/***/ 12437:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BindingInWhenOnSyntax = void 0;
var binding_in_syntax_1 = __webpack_require__(92064);
var binding_on_syntax_1 = __webpack_require__(15078);
var binding_when_syntax_1 = __webpack_require__(74533);
var BindingInWhenOnSyntax = function () {
  function BindingInWhenOnSyntax(binding) {
    this._binding = binding;
    this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
    this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
    this._bindingInSyntax = new binding_in_syntax_1.BindingInSyntax(binding);
  }
  BindingInWhenOnSyntax.prototype.inRequestScope = function () {
    return this._bindingInSyntax.inRequestScope();
  };
  BindingInWhenOnSyntax.prototype.inSingletonScope = function () {
    return this._bindingInSyntax.inSingletonScope();
  };
  BindingInWhenOnSyntax.prototype.inTransientScope = function () {
    return this._bindingInSyntax.inTransientScope();
  };
  BindingInWhenOnSyntax.prototype.when = function (constraint) {
    return this._bindingWhenSyntax.when(constraint);
  };
  BindingInWhenOnSyntax.prototype.whenTargetNamed = function (name) {
    return this._bindingWhenSyntax.whenTargetNamed(name);
  };
  BindingInWhenOnSyntax.prototype.whenTargetIsDefault = function () {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  };
  BindingInWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenTargetTagged(tag, value);
  };
  BindingInWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
    return this._bindingWhenSyntax.whenInjectedInto(parent);
  };
  BindingInWhenOnSyntax.prototype.whenParentNamed = function (name) {
    return this._bindingWhenSyntax.whenParentNamed(name);
  };
  BindingInWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenParentTagged(tag, value);
  };
  BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
  };
  BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
    return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
  };
  BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
  };
  BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
  };
  BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(name);
  };
  BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
  };
  BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
  };
  BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
  };
  BindingInWhenOnSyntax.prototype.onActivation = function (handler) {
    return this._bindingOnSyntax.onActivation(handler);
  };
  return BindingInWhenOnSyntax;
}();
exports.BindingInWhenOnSyntax = BindingInWhenOnSyntax;

/***/ }),

/***/ 13104:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Plan = void 0;
var Plan = function () {
  function Plan(parentContext, rootRequest) {
    this.parentContext = parentContext;
    this.rootRequest = rootRequest;
  }
  return Plan;
}();
exports.Plan = Plan;

/***/ }),

/***/ 13402:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ SpaBreakpoints)
/* harmony export */ });
class SpaBreakpoints {
}
SpaBreakpoints.breakpoint539 = 539;
SpaBreakpoints.breakpoint640 = 640;
SpaBreakpoints.breakpoint991 = 991;
SpaBreakpoints.breakpoint1200 = 1200;
SpaBreakpoints.breakpoint1533 = 1533;
SpaBreakpoints.breakpoint1920 = 1920;


/***/ }),

/***/ 14423:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ SpaHelpers)
/* harmony export */ });
class SpaHelpers {
    static ParseHtmlAttrs(attrs) {
        const attrsArray = attrs.match(/[A-za-z0-9\-]*=([\']([^\s\']|[ ])*[\']|[\"]([^\s\"]|[ ])*[\"])/g);
        const attrsObj = {};
        attrsArray === null || attrsArray === void 0 ? void 0 : attrsArray.forEach(attr => {
            const attrKey = attr.match(/[A-za-z0-9\-]*=/)[0].split("=")[0];
            const attrValue = attr.match(/=([\']([^\s\']|[ ])*[\']|[\"]([^\s\"]|[ ])*[\"])/)[0];
            attrsObj[attrKey] = attrValue.substring(2, attrValue.length - 1);
        });
        return attrsObj;
    }
    static loadScript(url) {
        const script = document.createElement('script');
        script.src = url;
        document.body.appendChild(script);
    }
    static requiredAsterisk(isRequired) {
        return isRequired ? "*" : "";
    }
    static requiredAttribute(isRequired) {
        return isRequired ? true : null;
    }
}


/***/ }),

/***/ 15078:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BindingOnSyntax = void 0;
var binding_when_syntax_1 = __webpack_require__(74533);
var BindingOnSyntax = function () {
  function BindingOnSyntax(binding) {
    this._binding = binding;
  }
  BindingOnSyntax.prototype.onActivation = function (handler) {
    this._binding.onActivation = handler;
    return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
  };
  return BindingOnSyntax;
}();
exports.BindingOnSyntax = BindingOnSyntax;

/***/ }),

/***/ 15426:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MetadataReader = void 0;
var METADATA_KEY = __webpack_require__(94725);
var MetadataReader = function () {
  function MetadataReader() {}
  MetadataReader.prototype.getConstructorMetadata = function (constructorFunc) {
    var compilerGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, constructorFunc);
    var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, constructorFunc);
    return {
      compilerGeneratedMetadata: compilerGeneratedMetadata,
      userGeneratedMetadata: userGeneratedMetadata || {}
    };
  };
  MetadataReader.prototype.getPropertiesMetadata = function (constructorFunc) {
    var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED_PROP, constructorFunc) || [];
    return userGeneratedMetadata;
  };
  return MetadataReader;
}();
exports.MetadataReader = MetadataReader;

/***/ }),

/***/ 16588:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  doIocContainer: () => (/* binding */ doIocContainer)
});

// EXTERNAL MODULE: ./node_modules/inversify/lib/inversify.js
var inversify = __webpack_require__(90260);
// EXTERNAL MODULE: ./src/types/types.ts
var types = __webpack_require__(45644);
// EXTERNAL MODULE: ./src/services/toggles/toggleService.ts
var toggles_toggleService = __webpack_require__(74529);
// EXTERNAL MODULE: ./src/services/translations/translationService.ts + 3 modules
var translationService = __webpack_require__(34575);
// EXTERNAL MODULE: ./src/components/hideableScrollbar/hideableScrollbar.ts
var hideableScrollbar = __webpack_require__(56839);
;// ./src/components/searchFilter/searchFilterButton.ts
class SearchFilterButton {
    constructor() {
        this.filterStateStorageKey = "CosmosFilterPanelState";
        this.expandFilterPanelByDefault = false;
        this.initialize();
        //hide desktop filter panel by default, but only do this
        // when the mod is enabled or it'll break the old version
        // remove the querySelector check once the MOD is permanent
        if (document.querySelector(".srp-filter--mod")) {
            this.initializeFilterPanelDesktop();
        }
    }
    initialize() {
        var _a, _b, _c, _d, _e, _f;
        this.filterPanel = document.getElementById("filterPanel");
        // searchFilterButton does not exist in MRPs
        this.filterPanelButton = document.getElementById("searchFilterButton");
        this.wasabiSrp = document.querySelector(".wasabi_srp");
        this.srpResults = document.querySelector(".srp-results");
        this.expandFilterPanelByDefault = ((_c = (_b = (_a = this.filterPanel) === null || _a === void 0 ? void 0 : _a.dataset) === null || _b === void 0 ? void 0 : _b.expandFilterPanelByDefault) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === 'true';
        this.currentPageName = window.location.href.split('?')[0];
        this.setupFilterPanelState();
        if (this.filterPanelButton && !((_d = this.filterPanelButton.dataset) === null || _d === void 0 ? void 0 : _d.doInitialized)) {
            (_e = this.filterPanelButton) === null || _e === void 0 ? void 0 : _e.addEventListener("click", () => {
                this.toggleFilterPanelDesktop();
            });
            this.filterPanelButton.dataset.doInitialized = "true";
        }
        ;
        const filterButtonClose = document.getElementById("filterButtonClose");
        if (filterButtonClose && !((_f = filterButtonClose.dataset) === null || _f === void 0 ? void 0 : _f.doInitialized)) {
            filterButtonClose.addEventListener("click", () => {
                this.toggleFilterPanelDesktop();
            });
            filterButtonClose.dataset.doInitialized = "true";
        }
        ;
    }
    setupFilterPanelState() {
        const currentState = localStorage.getItem(this.filterStateStorageKey);
        if (currentState) {
            this.filterPanelState = new Set(JSON.parse(currentState));
        }
        else {
            this.filterPanelState = new Set();
            localStorage.setItem(this.filterStateStorageKey, JSON.stringify(Array.from(this.filterPanelState)));
        }
    }
    initializeFilterPanelDesktop() {
        if (this.canToggleFilterPanelDesktop()) {
            if (this.expandFilterPanelByDefault || this.filterPanelState.has(this.currentPageName)) {
                this.showFilterPanel();
            }
            else {
                this.hideFilterPanel();
            }
        }
    }
    toggleFilterPanelDesktop() {
        var _a;
        if (this.canToggleFilterPanelDesktop()) {
            if ((_a = this.filterPanel) === null || _a === void 0 ? void 0 : _a.classList.contains("hidden")) {
                this.showFilterPanel();
            }
            else {
                this.hideFilterPanel();
            }
            this.toggleFilterState();
        }
    }
    canToggleFilterPanelDesktop() {
        //if the mobile panel is open then let the mobile mtheods handle open/close
        return !this.isMobileFilterPanel() && this.filterPanel !== null;
    }
    isMobileFilterPanel() {
        const mobileFilterToggleButton = document.querySelector(".filter-modal-toggle");
        if (mobileFilterToggleButton) {
            return window.getComputedStyle(mobileFilterToggleButton).display !== "none";
        }
        return false;
    }
    showFilterPanel() {
        var _a, _b, _c, _d;
        (_a = this.filterPanel) === null || _a === void 0 ? void 0 : _a.classList.remove("hidden");
        (_b = this.filterPanelButton) === null || _b === void 0 ? void 0 : _b.classList.add("hidden");
        if (this.wasabiSrp) {
            (_c = this.wasabiSrp) === null || _c === void 0 ? void 0 : _c.classList.remove("wasabi_srp--no-grid");
            (_d = this.srpResults) === null || _d === void 0 ? void 0 : _d.classList.remove("srp-results--no-grid");
        }
    }
    hideFilterPanel() {
        var _a, _b, _c, _d;
        (_a = this.filterPanel) === null || _a === void 0 ? void 0 : _a.classList.add("hidden");
        (_b = this.filterPanelButton) === null || _b === void 0 ? void 0 : _b.classList.remove("hidden");
        if (this.wasabiSrp) {
            (_c = this.wasabiSrp) === null || _c === void 0 ? void 0 : _c.classList.add("wasabi_srp--no-grid");
            (_d = this.srpResults) === null || _d === void 0 ? void 0 : _d.classList.add("srp-results--no-grid");
        }
    }
    toggleFilterState() {
        if (!this.filterPanelState.delete(this.currentPageName)) {
            this.filterPanelState.add(this.currentPageName);
        }
        localStorage.setItem(this.filterStateStorageKey, JSON.stringify(Array.from(this.filterPanelState)));
    }
}

;// ./src/components/searchFilter/filterPanelHeader.ts
class FilterPanelHeader {
    constructor() {
        // Use a closure to prevent polluting global scope with this script
        this.CLEAR_ALL_ELEMENT_ID = "filter-panel-header-clear-all";
        this.FILTER_STATE_CHANGE_EVENT = "filter-number-change";
        this.FILTER_STATE_INIT_EVENT = "filter-number-init";
        this.initialize();
    }
    initialize() {
        var clearAllElement = this.getClearAllElement();
        var filterPillListContainer = document.querySelector('.srp-selected-filters--pill-list');
        this.addFilterStateListeners(clearAllElement, filterPillListContainer);
        this.setInitialVisibility(clearAllElement);
        this.setHrefToCurrentPathname(clearAllElement);
        this.addHoverTextToTruncatedFilterPills(filterPillListContainer);
    }
    getClearAllElement() {
        return document.getElementById(this.CLEAR_ALL_ELEMENT_ID);
    }
    // Set the href on an element the path without the query string (e.g. /searchnew.aspx)
    setHrefToCurrentPathname(clearAllElement) {
        if (clearAllElement) {
            clearAllElement.href = window.location.pathname;
        }
    }
    addHoverTextToTruncatedFilterPills(filterPillListContainer) {
        if (!filterPillListContainer) {
            return;
        }
        var filterPillElements = filterPillListContainer.querySelectorAll(".pill-list__item-text");
        Array.from(filterPillElements).forEach((filterPillElement) => {
            if (filterPillElement.offsetWidth < filterPillElement.scrollWidth) {
                filterPillElement.setAttribute('title', filterPillElement.textContent);
            }
        });
    }
    addFilterStateListeners(clearAllElement, filterPillListContainer) {
        document.addEventListener(this.FILTER_STATE_INIT_EVENT, (event) => {
            this.setClearAllBtnStyling(event, clearAllElement, filterPillListContainer);
        });
        document.addEventListener(this.FILTER_STATE_CHANGE_EVENT, (event) => {
            this.setClearAllBtnStyling(event, clearAllElement, filterPillListContainer);
        });
    }
    setClearAllBtnStyling(event, clearAllElement, filterPillListContainer) {
        var filterPillsExist = filterPillListContainer && filterPillListContainer.children.length > 0;
        var selectedFiltersExist = event.detail > 0;
        if (filterPillsExist || selectedFiltersExist) {
            clearAllElement === null || clearAllElement === void 0 ? void 0 : clearAllElement.classList.remove("hidden");
        }
        else {
            clearAllElement === null || clearAllElement === void 0 ? void 0 : clearAllElement.classList.add("hidden");
        }
    }
    // Make the clear all button active by default if there's a query string
    setInitialVisibility(clearAllElement) {
        const noFiltersEl = document.querySelector("#no-filters-text");
        if (noFiltersEl) {
            clearAllElement === null || clearAllElement === void 0 ? void 0 : clearAllElement.classList.add("hidden");
        }
    }
}

;// ./src/components/searchResultsPage/searchFilters/filterPanel/panelToggle.ts
class FilterPanelToggle {
    static Toggle(element) {
        var _a;
        const panelContentSlideinClass = "panel__content--slide-in";
        const panelExpandedClass = "panel--expanded";
        const panelExpandedParentClass = "filter-expanded";
        const displayNoneClass = "no-display";
        const activeButton = element;
        const activePanel = activeButton.closest(".panel");
        const panelParent = activeButton.closest("#filter-panels");
        const filterPanelContentButton = activePanel.querySelector(".panel__content-btn");
        const filterPanelToggleButton = activePanel.querySelector(".panel-toggle__label-btn");
        const activePanelContent = activePanel.querySelector(".panel__content");
        activePanel.classList.toggle(panelExpandedClass);
        (_a = panelParent === null || panelParent === void 0 ? void 0 : panelParent.classList) === null || _a === void 0 ? void 0 : _a.toggle(panelExpandedParentClass);
        activePanelContent.classList.toggle(panelContentSlideinClass);
        // There are two panel buttons - hide the one that is not visible
        filterPanelToggleButton.classList.toggle(displayNoneClass);
        filterPanelContentButton.classList.toggle(displayNoneClass);
        activePanel.parentElement.scrollTo({ top: 0, behavior: "smooth" });
    }
}

;// ./src/components/searchResultsPage/searchFilters/filterPanel/makeFilter.ts

class MakeFilterPanel {
    constructor() {
        this._makes = [];
        this.makeModelNavElement = document.querySelector("#collapse-options-make-expanded #model-btn");
        this.addMakeFilteringEventHandler("click");
        this.setupMakeModelNavigation();
    }
    addMakeFilteringEventHandler(clickEvent) {
        const searchParameters = new URLSearchParams(window.location.search);
        //handle case sensitivity issues in the param name
        const caseInsensitiveParams = new URLSearchParams();
        for (const [name, value] of searchParameters) {
            caseInsensitiveParams.append(name.toLowerCase(), value);
        }
        if (caseInsensitiveParams.has("make")) {
            const rawMakeValue = caseInsensitiveParams.get("make");
            if (rawMakeValue.indexOf(",")) {
                const splitMakes = rawMakeValue.split(",");
                splitMakes.forEach((x) => this._makes.push(x));
            }
            else {
                this._makes.push(rawMakeValue);
            }
            this.toggleMakeModelNavElement();
            this.hideElementsOnMakeFilterSelectionChange();
            this.showElementsOnMakeFilterSelectionChange();
        }
        const makeCheckboxes = Array.from(document.querySelectorAll('[data-make][type="checkbox"]'));
        const makeFilterPills = Array.from(document.querySelectorAll('button[data-key="Make"]'));
        const inputsWithMakeData = makeCheckboxes.concat(makeFilterPills);
        inputsWithMakeData.forEach((checkbox) => {
            checkbox.addEventListener(clickEvent, (event) => {
                this.updateMakesArray(event);
                if (this._makes.length === 0) {
                    return this.resetOnEmptyMakesFilterSelection();
                }
                this.uncheckMakeFilterInputsOnMakeDeselect();
                this.collapseTrimPanelsOnMakeDeselect();
                this.hideElementsOnMakeFilterSelectionChange();
                this.showElementsOnMakeFilterSelectionChange();
            });
        });
    }
    showElementsOnMakeFilterSelectionChange() {
        const targetsToShow = Array.from(document.querySelectorAll(`[data-make-filter]`)).filter((x) => this._makes.some((make) => x.dataset.makeFilter === make));
        targetsToShow.forEach((targetElement) => {
            targetElement.classList.remove("hidden_filter");
        });
    }
    hideElementsOnMakeFilterSelectionChange() {
        const targetsToHide = Array.from(document.querySelectorAll(`[data-make-filter]`)).filter((x) => !this._makes.some((make) => x.dataset.makeFilter === make));
        targetsToHide.forEach((targetElement) => {
            targetElement.classList.add("hidden_filter");
        });
    }
    updateMakesArray(event) {
        const checkbox = event.target;
        const checkboxMake = checkbox.dataset.make;
        const optionChecked = checkbox.checked;
        if (optionChecked) {
            this._makes.push(checkboxMake);
        }
        else {
            this._makes.splice(this._makes.indexOf(checkboxMake), 1);
        }
        this.toggleMakeModelNavElement();
    }
    resetOnEmptyMakesFilterSelection() {
        Array.from(document.querySelectorAll(`[data-make-filter]`)).forEach((targetElement) => {
            targetElement.classList.remove("hidden_filter");
        });
        this.uncheckMakeFilterInputsOnMakeDeselect();
        this.collapseTrimPanelsOnMakeDeselect();
        return;
    }
    collapseTrimPanelsOnMakeDeselect() {
        const targetsToCollapse = Array.from(document.querySelectorAll("[data-make-filter-collapse]")).filter((x) => !this._makes.some((make) => x.dataset.makeFilterCollapse === make));
        targetsToCollapse.forEach((x) => {
            x.classList.remove("in");
        });
    }
    uncheckMakeFilterInputsOnMakeDeselect() {
        const targetsToUncheck = Array.from(document.querySelectorAll(`[data-make-filter-input]:checked`)).filter((x) => !this._makes.some((make) => x.dataset.makeFilterInput === make));
        targetsToUncheck.forEach((targetElement) => {
            targetElement.checked = false;
            targetElement.dispatchEvent(new Event("change"));
            document.dispatchEvent(new Event("filter-number-change"));
        });
    }
    setupMakeModelNavigation() {
        if (!this.makeModelNavElement) {
            return;
        }
        const makeCollapse = document.getElementById("collapse-options-make");
        const modelCollapse = document.getElementById("collapse-options-model");
        if (!makeCollapse) {
            return;
        }
        if (!modelCollapse) {
            this.makeModelNavElement.hidden = true;
            this.makeModelNavElement.classList.add("hidden");
            return;
        }
        this.makeModelNavElement.addEventListener("click", () => {
            FilterPanelToggle.Toggle(makeCollapse);
            FilterPanelToggle.Toggle(modelCollapse);
        });
    }
    toggleMakeModelNavElement() {
        if (!this.makeModelNavElement) {
            return;
        }
        if (this._makes.length > 0) {
            this.makeModelNavElement.removeAttribute("disabled");
        }
        else {
            this.makeModelNavElement.setAttribute("disabled", "true");
        }
    }
}

;// ./src/components/searchResultsPage/searchFilters/filterPanel/modelTrimFilterPanel.ts
class ModelTrimFilterPanel {
    constructor() {
        this.initialize();
    }
    initialize() {
        this.addModelTrimFilterEventListeners();
    }
    showAllTrims(collapseModelId) {
        var _a;
        const trimsList = document.getElementById(collapseModelId);
        Array.from((_a = trimsList === null || trimsList === void 0 ? void 0 : trimsList.firstElementChild) === null || _a === void 0 ? void 0 : _a.children).forEach(trim => {
            trim.removeAttribute("hidden");
        });
    }
    addModelTrimFilterEventListeners() {
        const filterPanel = document.getElementById("filterPanel");
        const allTrimsCheckboxes = filterPanel.querySelectorAll("[id^=filter][id$=AllTrims]");
        const trimCheckboxes = filterPanel.querySelectorAll("[data-filter-type=trim]");
        const modelCheckboxes = filterPanel.querySelectorAll("[data-filter-type=model]");
        modelCheckboxes.forEach((modelCheckbox) => {
            modelCheckbox.addEventListener("change", (event) => {
                const target = event.target;
                this.toggleAllTrimsCheckboxOnModelCheck(target, filterPanel);
            });
        });
        trimCheckboxes.forEach((trimCheckbox) => {
            trimCheckbox.addEventListener("change", (event) => {
                const target = event.target;
                this.toggleOffAllTrimsCheckbox(target);
                if (!target.checked) {
                    this.getTrimCheckStatus(target);
                }
            });
        });
        allTrimsCheckboxes.forEach((checkbox) => {
            checkbox.addEventListener("change", (event) => {
                const target = event.target;
                if (target.checked) {
                    checkbox.classList.remove("dash");
                    target.disabled = true;
                    this.toggleOffAllModelTrims(target);
                }
            });
        });
    }
    toggleAllTrimsCheckboxOnModelCheck(element, location) {
        const allTrimsCheckbox = element.parentElement.nextElementSibling.querySelector("[id$=AllTrims]");
        if (allTrimsCheckbox) {
            allTrimsCheckbox.checked = element.checked;
            allTrimsCheckbox.dispatchEvent(new Event("change"));
            if (element.checked) {
                allTrimsCheckbox.classList.remove("dash");
            }
            if (allTrimsCheckbox.checked) {
                allTrimsCheckbox.disabled = true;
            }
            location.dispatchEvent(new Event("filter-number-change"));
            return;
        }
    }
    toggleOffAllTrimsCheckbox(element) {
        const trimCheckboxesContainer = element.closest(".collapse-options-sub");
        if (trimCheckboxesContainer) {
            const allTrimsCheckbox = trimCheckboxesContainer.querySelector("[id$=AllTrims]");
            if (allTrimsCheckbox && element.checked) {
                allTrimsCheckbox.disabled = false;
                allTrimsCheckbox.checked = false;
                allTrimsCheckbox.classList.add("dash");
                allTrimsCheckbox.dispatchEvent(new Event("change"));
            }
        }
    }
    // If the user unchecks all the trims re-check the "All Trims" checkbox
    getTrimCheckStatus(element) {
        const trimsContainer = element.closest(".collapse-options-sub");
        const allTrimCheckboxes = Array.from(trimsContainer.querySelectorAll("[data-filter-type=trim]"));
        const allTrimsCheckbox = trimsContainer.querySelector("[id$=AllTrims]");
        let anyCheckBoxesChecked = allTrimCheckboxes.some((checkbox) => {
            return checkbox.checked === true;
        });
        if (anyCheckBoxesChecked) {
            return;
        }
        if (allTrimsCheckbox) {
            allTrimsCheckbox.checked = true;
            allTrimsCheckbox.classList.remove("dash");
            allTrimsCheckbox.disabled = true;
        }
        trimsContainer.dispatchEvent(new Event("filter-number-change"));
    }
    toggleOffAllModelTrims(element) {
        const trimCheckboxesContainer = element.closest(".collapse-options-sub");
        if (trimCheckboxesContainer) {
            const checkedModelTrims = trimCheckboxesContainer.querySelectorAll("input:checked:not([id$=AllTrims])");
            checkedModelTrims.forEach((checkbox) => {
                checkbox.checked = false;
                trimCheckboxesContainer.dispatchEvent(new Event("filter-number-change"));
            });
        }
    }
}

;// ./src/components/searchResultsPage/searchFilters/selectedFilters/selectedFilters.ts
class SelectedFilters {
    constructor() {
        SelectedFilters._maxHeight = 120;
        this._pillListElem = document.querySelector('[data-pill-list]');
        if (this._pillListElem) {
            const isMobile = this.filterPillsInit();
            if (isMobile) {
                this.moreFiltersMobile();
            }
            else {
                this.moreFiltersSetup();
            }
            this.addViewportResizeListener();
        }
    }
    moreFiltersSetup() {
        const pillListElem = document.querySelector('[data-pill-list]');
        const computedStyle = getComputedStyle(pillListElem);
        const pillListHeight = (pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.clientHeight) - (parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom));
        if (pillListHeight === SelectedFilters._currentPillsListHeight && SelectedFilters._areFiltersHidden) {
            return;
        }
        var hiddenFilterPills = this.moreFiltersHide(pillListElem, pillListHeight);
        this.updateHiddenFiltersCount(hiddenFilterPills[1]);
        let viewMoreElem = document.querySelector("[data-pill-hidden]");
        if (viewMoreElem && SelectedFilters._areFiltersHidden) {
            viewMoreElem.classList.remove("hidden");
            viewMoreElem.dataset.pillHidden = '0';
        }
        else if (viewMoreElem) {
            viewMoreElem.dataset.pillHidden = '1';
        }
        this.moreFiltersOnClick(viewMoreElem.querySelector("button"), hiddenFilterPills[0], pillListElem);
    }
    moreFiltersHide(pillListElem, pillListHeight) {
        let indexToHide = -1;
        if (pillListHeight > SelectedFilters._maxHeight) {
            for (let i = 0; i < (pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.childElementCount); i++) {
                const elem = pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.children.item(i);
                // Note that the "view more" pill is included in this list of children. We don't want to count that pill in our calculations.
                if (elem.offsetTop >= SelectedFilters._maxHeight && i !== (pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.childElementCount) - 1) {
                    indexToHide = i - 1;
                    break;
                }
            }
        }
        SelectedFilters._currentPillsListHeight = pillListHeight;
        SelectedFilters._areFiltersHidden = !(indexToHide === -1);
        let hiddenFiltersCount = 0;
        let hiddenFilterPills = [];
        if (SelectedFilters._areFiltersHidden) {
            for (let i = indexToHide; i < (pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.childElementCount); i++) {
                (pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.children.item(i)).classList.add("hidden");
                hiddenFiltersCount++;
                hiddenFilterPills.push(pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.children.item(i));
            }
        }
        pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.classList.add("collapsed");
        var hiddenFilterPillsTuple = [hiddenFilterPills, hiddenFiltersCount - 1];
        return hiddenFilterPillsTuple;
    }
    updateHiddenFiltersCount(count) {
        const countSpan = document.querySelector("[data-minimized-filters-count='0']");
        countSpan.innerHTML = count.toString();
    }
    moreFiltersOnClick(viewMoreBtn, hiddenFilterPills, pillListElem) {
        const clickEvent = 'click';
        viewMoreBtn.addEventListener(clickEvent, event => {
            pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.classList.replace("collapsed", "expanded");
            hiddenFilterPills.forEach(pill => {
                pill.classList.remove("hidden");
            });
            const viewMoreElem = viewMoreBtn.closest("li");
            viewMoreElem.classList.add("hidden");
            this.addHoverTextToTruncatedFilterPills();
        });
    }
    addHoverTextToTruncatedFilterPills() {
        var filterPillElements = document.querySelectorAll(".srp-selected-filters--pill-list .pill-list__item-text");
        filterPillElements.forEach((filterPillElement) => {
            if (filterPillElement.offsetWidth < filterPillElement.scrollWidth) {
                filterPillElement.setAttribute('title', filterPillElement.textContent);
            }
        });
    }
    moreFiltersMobile() {
        const pillListElem = document.querySelector('[data-pill-list]');
        var hiddenPills = pillListElem.querySelectorAll(".hidden");
        hiddenPills.forEach(elem => {
            elem.classList.remove("hidden");
        });
        let viewMoreElem = document.querySelector("[data-pill-hidden]");
        viewMoreElem.dataset.pillHidden = "1";
        SelectedFilters._areFiltersHidden = false;
    }
    addViewportResizeListener() {
        // Change pill list styling when screen changes between mobile and desktop
        window.addEventListener('resize', () => {
            const isMobile = SelectedFilters.prototype.filterPillsInit();
            if (isMobile) {
                SelectedFilters.prototype.moreFiltersMobile();
            }
            else if (!SelectedFilters._areFiltersHidden) {
                SelectedFilters.prototype.moreFiltersSetup();
            }
        });
    }
    filterPillsInit() {
        const pillListElem = document.querySelector('[data-pill-list]');
        if (window.innerWidth > 991) {
            pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.classList.remove("mobile");
            return false;
        }
        else {
            pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.classList.remove("collapsed");
            pillListElem === null || pillListElem === void 0 ? void 0 : pillListElem.classList.add("mobile");
            return true;
        }
    }
}

;// ./src/components/searchResultsPage/searchFilters/filterPanel/filterPanel.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};









let FilterPanel = class FilterPanel {
    constructor(InventoryWasabi, toggleService) {
        this._makes = [];
        this.isIlp = () => {
            const isIlp = window.location.pathname.toLowerCase().indexOf("inventorylineup.aspx") > -1;
            return isIlp;
        };
        this.inventoryWasabi = InventoryWasabi;
        this._toggleService = toggleService;
    }
    initialize() {
        let filterPanelContainer;
        filterPanelContainer = !this.isIlp() ? document.querySelector("#sephora_filter") : document.querySelector("#srp_filter");
        //NOTE: Order is important because of custom event listeners and dom structure. 
        //    The Dependency chain is a train wreck and needs to be cleaned up
        // - InventoryWasabi
        // - FilterPanelHeader
        // - FilterState
        //This is leftover from conversion to wasabi-mod. This class has a mix of filter and non-filter stuff. 
        //  The filter items should be split out and merged into this class
        this.inventoryWasabi.initialize();
        // We might not have a filter panel at all since it can be hidden. If we don't have a panel
        // then don't run the remainder of these items to save some cycles.
        if (!filterPanelContainer) {
            return;
        }
        if (this.isIlp()) {
            new FilterPanelHeader();
        }
        new SearchFilterButton();
        const filtersElem = document.querySelector("#filter-panels");
        this._hideableScrollbarFilterV2_Panels = new hideableScrollbar/* HideableScrollbar */.t(filtersElem);
        if (this.isIlp()) {
            const filterHeaderElem = document.querySelector(".filter-header--scroll");
            this._hideableScrollbarFilterV2_Header = new hideableScrollbar/* HideableScrollbar */.t(filterHeaderElem);
            this._hideableScrollbarFilterV2_PanelContents = [];
            const panelContentElems = filtersElem === null || filtersElem === void 0 ? void 0 : filtersElem.querySelectorAll('.panel__content');
            panelContentElems === null || panelContentElems === void 0 ? void 0 : panelContentElems.forEach(panelContentElem => {
                var _a;
                (_a = this._hideableScrollbarFilterV2_PanelContents) === null || _a === void 0 ? void 0 : _a.push(new hideableScrollbar/* HideableScrollbar */.t(panelContentElem));
            });
            this._selectedFilters = new SelectedFilters();
        }
        else {
            this.addFilterPanelResizeObserver(filtersElem);
        }
        this.addEventHandlers(filterPanelContainer);
    }
    addEventHandlers(filterPanelContainer) {
        if (this.isIlp()) {
            new MakeFilterPanel();
        }
        const modelTrimFilterPanel = new ModelTrimFilterPanel();
        const clickEvent = "click";
        if (this.isIlp()) {
            const filterPanelsList = filterPanelContainer.querySelectorAll(".panel-toggle__label-btn, .panel__content-btn");
            const filterPanels = Array.from(filterPanelsList);
            filterPanels === null || filterPanels === void 0 ? void 0 : filterPanels.forEach((panel) => {
                panel.addEventListener(clickEvent, (event) => {
                    const element = event.currentTarget;
                    FilterPanelToggle.Toggle(element);
                });
            });
        }
        const vehicleStageFilters = Array.from(document.querySelectorAll(`[data-vehicle-stage-filter="true"]`));
        vehicleStageFilters === null || vehicleStageFilters === void 0 ? void 0 : vehicleStageFilters.forEach((filter) => {
            if (!filter.dataset.filterPanelEventAttached) {
                filter.addEventListener("change", (event) => {
                    const elem = event.currentTarget;
                    this.limitVehicleStageCheckboxes(elem, vehicleStageFilters);
                });
                filter.dataset.filterPanelEventAttached = "true";
            }
        });
        if (this.isIlp()) {
            const allTrimsBtns = Array.from(document.querySelectorAll("[data-collapse-model-id]"));
            allTrimsBtns === null || allTrimsBtns === void 0 ? void 0 : allTrimsBtns.forEach((btn) => {
                btn.addEventListener(clickEvent, (event) => {
                    var _a;
                    (_a = btn.firstElementChild) === null || _a === void 0 ? void 0 : _a.addEventListener("click", () => {
                        modelTrimFilterPanel.showAllTrims(btn.dataset.collapseModelId);
                        btn.setAttribute("hidden", "");
                    });
                });
                btn.dataset.filterPanelEventAttached = "true";
            });
        }
        const filterPanel = document.querySelector("#filter-panels");
        if (!(filterPanel === null || filterPanel === void 0 ? void 0 : filterPanel.dataset.filterPanelEventAttached)) {
            filterPanel === null || filterPanel === void 0 ? void 0 : filterPanel.addEventListener("scroll", () => {
                if (document.querySelectorAll(".panel__content--slide-in").length > 0) {
                    filterPanel.scrollTo(0, 0);
                }
            });
            filterPanel.dataset.filterPanelEventAttached = "true";
        }
        const filterCheckboxes = document.querySelectorAll('.panel__content input[type="checkbox"]');
        if (!(filterPanel === null || filterPanel === void 0 ? void 0 : filterPanel.dataset.filterPanelEventAttached)) {
            filterCheckboxes === null || filterCheckboxes === void 0 ? void 0 : filterCheckboxes.forEach((checkbox) => {
                checkbox.addEventListener("click", () => {
                    filterPanel.scrollTo(0, 0);
                });
                checkbox.dataset.filterPanelEventAttached = "true";
            });
        }
    }
    //vehicle staging checkboxes only supports one of the checkboxes being checked
    //or we'll get no results because the filters are AND filters
    limitVehicleStageCheckboxes(currentFilter, vehicleStageFilters) {
        const currentFilterIsChecked = currentFilter.checked;
        vehicleStageFilters
            .forEach((filter) => {
            filter.checked = false;
        });
        currentFilter.checked = currentFilterIsChecked;
    }
    addFilterPanelResizeObserver(filterPanelContainer) {
        const observer = new ResizeObserver((entries) => {
            entries.forEach((entry) => {
                const panelWidth = entry.borderBoxSize[0].inlineSize;
                filterPanelContainer.style.setProperty('--filter-panel-width', `${panelWidth}px`);
            });
        });
        if (filterPanelContainer) {
            observer.observe(filterPanelContainer);
        }
    }
};
FilterPanel = __decorate([
    (0,inversify/* injectable */._G)(),
    __param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IInventoryWasabi)),
    __param(1, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IToggleService)),
    __metadata("design:paramtypes", [Object, Object])
], FilterPanel);


// EXTERNAL MODULE: ./src/utilities/jQueryHelper/jQueryHelper.ts
var jQueryHelper = __webpack_require__(82781);
// EXTERNAL MODULE: ./src/infrastructure/vue/cosmosSrp/customEvents.ts
var customEvents = __webpack_require__(29600);
;// ./src/components/inventorysearch/inventory-wasabi-mod.ts
var inventory_wasabi_mod_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var inventory_wasabi_mod_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var inventory_wasabi_mod_param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




class PopoverOpts {
    constructor(html, trigger, container, animation, placement) {
        this.html = html;
        this.trigger = trigger;
        this.container = container;
        this.animation = animation;
        this.placement = placement;
    }
}
let InventoryWasabi = class InventoryWasabi {
    constructor(wasabiFilterState, toggleService) {
        this.isIlp = () => {
            const isIlp = window.location.pathname.toLowerCase().indexOf("inventorylineup.aspx") > -1;
            return isIlp;
        };
        this.toggleService = toggleService;
        this.wasabiFilterState = wasabiFilterState;
    }
    initialize() {
        if (this.isIlp()) {
            this.wasabiFilterState.initialize();
        }
        // If on the lineup page, these variables will not have been defined
        window.usingUwmTpi = window.usingUwmTpi || false;
        window.vehicleType = window.vehicleType || "new";
        if (!String.prototype.includes) {
            String.prototype.includes = function () {
                'use strict';
                return String.prototype.indexOf.apply(this, arguments) !== -1;
            };
        }
        jQuery('[data-toggle=offcanvas]').click(function () {
            jQuery('.row-offcanvas').toggleClass('active');
            jQuery("#srpRefineSearch_Filters input:first").focus();
            if (jQuery('.row-offcanvas').hasClass('active'))
                jQuery('.contentWrapper .container').css('overflow-x', 'hidden');
        });
        if (!window.usingUwmTpi) {
            if (!this.isIlp()) {
                document.addEventListener(customEvents/* CosmosSrpCustomEvents */.A.VehicleLoadEnd, () => {
                    this.activateVideos();
                });
            }
            else {
                this.activateVideos();
            }
        }
        jQuery('body').on('show.bs.modal', function (e) {
            //@ts-ignore
            var relatedTarget = e.relatedTarget;
            if (relatedTarget) {
                jQuery('iframe#rebateIframe').removeAttr('src');
                jQuery('iframe#rebateIframe').attr("src", relatedTarget.getAttribute('data-iframe-src'));
            }
        });
        jQuery('body').on('hidden.bs.modal', '.page-modal', function () {
            jQuery(this).find('iframe').removeAttr('src');
            jQuery(this).removeData('bs.modal');
        });
        if (this.isIlp()) {
            var openSearchButton = document.getElementById("opensearch-submit");
            if (openSearchButton) {
                openSearchButton.addEventListener("click", () => {
                    this.refineSearch(true);
                });
            }
            const filterSearchButtons = document.querySelectorAll('[data-filter-search-btn]');
            filterSearchButtons === null || filterSearchButtons === void 0 ? void 0 : filterSearchButtons.forEach(button => {
                const buttonElement = button;
                buttonElement === null || buttonElement === void 0 ? void 0 : buttonElement.addEventListener('click', () => {
                    this.refineSearch(false);
                });
            });
        }
        jQuery('.modal-link').click(function (e) {
            e.preventDefault();
            var modal = jQuery('#rebateModal');
            modal
                .on('show.bs.modal', function () {
                jQuery('iframe#rebateIframe').removeAttr('src');
                const currentTarget = e.currentTarget;
                jQuery('iframe#rebateIframe').attr("src", currentTarget.href);
            })
                .modal();
        });
        // DEV-4627
        jQuery(".commentsExpand").click(function (e) {
            jQuery(this).prev().toggleClass("vehicleCommentsCollapsed");
            if (jQuery(this).find("i").hasClass("fa-plus")) {
                jQuery(this).find("i").removeClass("fa-plus").addClass("fa-minus");
            }
            else {
                jQuery(this).find("i").removeClass("fa-minus").addClass("fa-plus");
            }
        });
        //var openDetailsNew is defined in UCSearchResultsBlock.cs
        $('div[rel]').each(function () {
            $(this).click(function () {
                if (window.openDetailsNew)
                    window.open(jQuery(this).attr('rel'));
                else
                    location.href = jQuery(this).attr('rel');
            });
        });
        $('div ul[rel]').each(function () {
            $(this).click(function () {
                if (window.openDetailsNew)
                    window.open(jQuery(this).attr('rel'));
                else
                    location.href = jQuery(this).attr('rel');
            });
        });
        $('span[data-toggle="popover"],a:not([role="button"])[data-toggle="popover"]').each(function () {
            var vin = $(this).closest('.vehicleCard, .vehicle-card').attr('data-vin');
            var containerSelector = '[data-vin="' + vin + '"]';
            if (window.matchMedia("(max-width: 767px)").matches) {
                const opts = new PopoverOpts(true, "click", "body", false, this.dataset.placement || 'bottom');
                jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(this, opts);
            }
            else {
                var _this = this;
                const opts = new PopoverOpts(true, "manual", "body", false, this.dataset.placement || 'auto left');
                jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(this, opts)
                    .on("mouseenter", function () {
                    jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(_this, "show");
                    $(containerSelector + ' .popover').on("mouseleave", function () {
                        jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(_this, 'hide');
                    });
                    const popoverElems = document.getElementsByClassName("popover");
                    Array.from(popoverElems).forEach(elem => {
                        elem.addEventListener('mouseleave', (event) => {
                            jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(_this, 'hide');
                        });
                    });
                }).on("mouseleave", function () {
                    setTimeout(function () {
                        if (!$(".popover:hover").length) {
                            jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(_this, "hide");
                        }
                    }, 5);
                });
            }
        });
        $('body').on("shown.bs.popover", function () {
            $('.modal-link').click(function (e) {
                e.preventDefault();
                var modal = jQuery('#rebateModal');
                modal
                    .on('show.bs.modal', function () {
                    jQueryHelper/* JQueryHelper */.$.SafeApplyPopover('[aria-describedby]', 'hide');
                    $('iframe#rebateIframe').removeAttr('src');
                    const currentTarget = e.currentTarget;
                    $('iframe#rebateIframe').attr("src", currentTarget.href);
                })
                    .modal();
            });
        });
        jQuery("#closeSRP_refine").on('click touch', this.closeRefineSearch);
        jQuery(document).keyup((e) => {
            if (e.key === "Escape") {
                this.closeRefineSearch();
            }
        });
        var firstFocusableElement = jQuery("#closeSRP_refine");
        var lastFocusableElement = jQuery("#btnFilter");
        lastFocusableElement.keydown(function (e) {
            if (e.key === "Tab" && !e.shiftKey) {
                e.preventDefault();
                firstFocusableElement.focus();
            }
        });
        firstFocusableElement.keydown(function (e) {
            if (e.key === "Tab" && e.shiftKey) {
                e.preventDefault();
                lastFocusableElement.focus();
            }
        });
        $('a[data-toggle="offcanvas"].stat-search-toggle').on('click', function () {
            $('#srpRefineSearch_Filters input').attr('readonly', 'readonly');
            setTimeout(function () {
                $('#srpRefineSearch_Filters input').removeAttr('readonly');
                $('#srpRefineSearch_Filters input').blur();
            }, 100);
        });
    }
    activateVideos() {
        var _a;
        (_a = document.querySelectorAll("[id^='videoBtn']")) === null || _a === void 0 ? void 0 : _a.forEach((elem) => {
            const src = elem.getAttribute("show").replace(/["']/g, "");
            this.ActivateMagnific(jQuery(elem), 'video', src);
        });
    }
    /*********************/
    /* BEGIN ILP Methods */
    refineSearch(newSearch) {
        //Fetch all the key/value pairs that encapsulate the querystring parameters for a search
        var appliedFilters = () => {
            const filters = this.wasabiFilterState.getAppliedFilters();
            this.wasabiFilterState.triggerDealerOnTrackEvents(filters);
            return filters;
        };
        var removedFilters = () => {
            const filters = this.wasabiFilterState.getRemovedFilters();
            return filters;
        };
        // DEV-14659 - Changing location.href will not reload the window if there is a fragment
        // If there is a # then remove that portion of the URL starting at the # (just need to take care of fragments)
        var currentUrl = location.href;
        if (currentUrl.includes("#")) {
            currentUrl = currentUrl.substring(0, currentUrl.indexOf("#"));
        }
        var updatedUrl = this.updateQueryStringParameters(currentUrl, appliedFilters(), removedFilters(), newSearch);
        location.href = updatedUrl;
    }
    updateQueryStringParameters(uri, addValues, removeValues, newSearch) {
        //order of operations is important, remove values first
        jQuery.each(removeValues, (key, value) => {
            const keyLowerCase = key.toString().toLowerCase();
            if (keyLowerCase.startsWith("model") || keyLowerCase == "trim") {
                uri = this.removeQueryStringParameter(uri, key);
                key = "ModelAndTrim";
            }
            uri = this.removeQueryStringParameter(uri, key);
        });
        //CONPLAT-1833
        //always clear open search explicitly, or it won't get removed
        uri = this.removeQueryStringParameter(uri, "q");
        uri = this.removeQueryStringParameter(uri, "vehiclelocation");
        //END CONPLAT-1833
        if (newSearch) {
            var newSearchQuery = addValues["q"];
            if (newSearchQuery) {
                uri = this.updateQueryStringParameter(uri, "q", newSearchQuery);
            }
        }
        else {
            jQuery.each(addValues, (key, value) => {
                uri = this.updateQueryStringParameter(uri, key, value);
            });
        }
        return (uri);
    }
    updateQueryStringParameter(uri, key, value) {
        var re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
        var separator = uri.indexOf('?') !== -1 ? "&" : "?";
        if (uri.match(re)) {
            return uri.replace(re, '$1' + key + "=" + value + '$2');
        }
        else {
            return (uri + separator + key + "=" + value).replace(/pt=\d+&?/i, "");
        }
    }
    removeQueryStringParameter(uri, key) {
        var re = new RegExp("([?&])" + key + "\\d{0,3}=.*?(&|$)", 'i');
        var match;
        while ((match = re.exec(uri)) !== null) {
            uri = uri.replace(match[0], !match[2] ? "" : match[1]);
        }
        return uri;
    }
    /* END ILP Methods   */
    /*********************/
    ActivateMagnific(that, type, src) {
        if (window.magnificPopupLoaded) {
            this.ActivateMagnificInner(that, type, src);
        }
        else {
            document.addEventListener("MagnificPopupLoaded", () => {
                this.ActivateMagnificInner(that, type, src);
            });
        }
    }
    ActivateMagnificInner(that, type, src) {
        if (src === '') {
            return;
        }
        switch (type) {
            case 'iframe':
                jQuery(that).magnificPopup({
                    type: 'iframe',
                    midClick: true,
                    items: {
                        src: src
                    }
                });
                break;
            case 'special':
                jQuery(that).magnificPopup({
                    items: {
                        type: 'iframe',
                        src: src
                    },
                    iframe: {
                        markup: '<div class="mfp-iframe-scaler specialMagnific">' +
                            '<div class="mfp-close"></div>' +
                            '<iframe class="mfp-iframe" frameborder="0" allowfullscreen>            </iframe>' +
                            '</div>'
                    },
                    callbacks: {
                        open: () => {
                            this.ResetTracker();
                            //var specialLinkTrackerEvent is defined in C# as a global that is expected to exist
                            window.trackerHook(window.specialLinkTrackerEvent, 'click');
                        }
                    }
                });
                break;
            case 'video':
                jQuery(that).magnificPopup({
                    items: {
                        type: 'iframe',
                        midClick: true,
                        src: src
                    },
                    iframe: {
                        markup: '<div class="mfp-iframe-scaler vehicleVidMagnific">' +
                            '<div class="mfp-close"></div>' +
                            '<iframe class="mfp-iframe" frameborder="0" allowfullscreen scrolling="no">            </iframe>' +
                            '</div>'
                    },
                    mainClass: "vehicleVidMagnificContainer"
                });
        }
    }
    openWindowSticker(url) {
        const screen_width = window.screen.availWidth / 2;
        const left_point = window.parseInt(screen_width) - (500);
        const brochureWindow = window.open(url, "", "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=1,resizable=yes,copyhistory=yes,width=1050,height=1500");
        brochureWindow.moveTo(left_point, 0);
    }
    openFordWindowSticker(url) {
        var t3websiteCookie = (window.DealeronCookie.getItem('t3website') || '');
        var guid = '';
        if (t3websiteCookie != '') {
            var elements = t3websiteCookie.match(/<cookieguid>([^<]*)<\/cookieguid>/);
            if (elements.length > 1) {
                var cookieguid = elements[1];
                if (cookieguid != null) {
                    guid = cookieguid;
                }
            }
        }
        if (guid == '') {
            this.openWindowSticker(url);
        }
        else {
            this.openWindowSticker(url + "&cguid=" + guid);
        }
    }
    closeRefineSearch() {
        jQuery('.row-offcanvas-left').removeClass('active');
        jQuery('.contentWrapper .container').css('overflow-x', 'visible');
        jQuery("a[data-toggle='offcanvas']").focus();
    }
    ResetTracker() {
        window.eventFired = 0;
    }
};
InventoryWasabi = inventory_wasabi_mod_decorate([
    (0,inversify/* injectable */._G)(),
    inventory_wasabi_mod_param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IWasabiFilterState)),
    inventory_wasabi_mod_param(1, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IToggleService)),
    inventory_wasabi_mod_metadata("design:paramtypes", [Object, Object])
], InventoryWasabi);


;// ./src/components/inventorysearch/wasabiFilterState.ts
var wasabiFilterState_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var wasabiFilterState_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var wasabiFilterState_param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
//NOTE: Only used for InventoryLineup.aspx (ILP)



let WasabiFilterState = class WasabiFilterState {
    constructor(translationService) {
        this.handleUndo = () => {
            const savedQueryString = this.getSavedFilterState() || "";
            localStorage.setItem("isFilterStateUndo", "true");
            window.location.search = savedQueryString;
        };
        this.isIlp = () => {
            const isIlp = window.location.pathname.toLowerCase().indexOf("inventorylineup.aspx") > -1;
            return isIlp;
        };
        this.translationService = translationService;
    }
    getAppliedFilters() {
        //This is only used by ILP
        if (!this.isIlp()) {
            return;
        }
        const keyValues = {};
        const modelTrims = {};
        //Vehicle Properties Selector
        document.querySelectorAll("input[type=checkbox][id^=filter]:checked").forEach((element) => {
            if (element.name === "Model") {
                const model = element.value;
                const escapedModel = model.replace(/!/g, "%5C!")
                    .replace(/:/g, "%5C:")
                    .replace(/\+/g, "%2B")
                    .replace(/\&/g, "%26");
                if (!(model in modelTrims)) {
                    modelTrims[escapedModel] = [];
                }
            }
            else if (element.name === "Trim") {
                const model = element.value.split(',')[0];
                const escapedModel = model.replace(/!/g, "%5C!")
                    .replace(/:/g, "%5C:")
                    .replace(/\+/g, "%2B")
                    .replace(/\&/g, "%26");
                const trim = element.value.split(',')[1];
                const escapedTrim = trim.replace(/!/g, "%5C!")
                    .replace(/:/g, "%5C:")
                    .replace(/\+/g, "%2B")
                    .replace(/\&/g, "%26");
                if (model in modelTrims) {
                    modelTrims[escapedModel].push(escapedTrim);
                }
                else {
                    modelTrims[escapedModel] = [escapedTrim];
                }
            }
            else if (element.name !== "All-Trims") {
                const key = element.name;
                const value = encodeURIComponent(element.value);
                if (key in keyValues) {
                    keyValues[key].push(value);
                }
                else {
                    keyValues[key] = [value];
                }
            }
        });
        if (Object.keys(modelTrims).length) {
            const encodedModelTrims = [];
            for (const key in modelTrims) {
                if (modelTrims[key].length > 0) {
                    encodedModelTrims.push(key + ":" + modelTrims[key].join(','));
                }
                else {
                    encodedModelTrims.push(key);
                }
            }
            keyValues["ModelAndTrim"] = encodedModelTrims.join('!');
        }
        if ("cpotier" in keyValues) {
            delete keyValues["cpo"];
        }
        this.handleRangeInputKeyValues(keyValues);
        const searchValet = document.querySelector("input[id^='opensearch-']");
        if (searchValet && searchValet.value.trim() !== "") {
            keyValues["q"] = searchValet.value;
        }
        const zipCodeField = document.getElementById("search_valet_zip");
        const distanceSelect = document.getElementsByClassName("distance-select")[0];
        if (distanceSelect) {
            const distanceField = distanceSelect.querySelector(".custom-option.selected");
            if (distanceField && (zipCodeField && zipCodeField.value !== "")) {
                const distance = distanceField.dataset.value.trim();
                if (distance === "") {
                    alert("Please select a distance.");
                    distanceField.focus();
                }
                //first 5 digits only
                const zipCode = zipCodeField.value.trim().split("-")[0];
                keyValues["vehiclelocation"] = zipCode + "-" + distance;
            }
        }
        const makeModelNavElement = document.querySelector("#collapse-options-make-expanded #model-btn");
        if (keyValues["make"]) {
            makeModelNavElement === null || makeModelNavElement === void 0 ? void 0 : makeModelNavElement.removeAttribute("disabled");
        }
        else {
            makeModelNavElement === null || makeModelNavElement === void 0 ? void 0 : makeModelNavElement.setAttribute("disabled", "true");
        }
        return keyValues;
    }
    //remove all checkboxes from the query string
    getRemovedFilters() {
        if (!this.isIlp()) {
            return;
        }
        var keyValues = {};
        jQuery("input:checkbox[id^='filter']").each(function (i, e) {
            const checkbox = this;
            var key = checkbox.name;
            if (key.toLowerCase() == "model" || key.toLowerCase() == "trim") {
                key = "ModelAndTrim";
            }
            var value = encodeURIComponent(checkbox.value);
            if (key in keyValues) {
                keyValues[key].push(value);
            }
            else {
                keyValues[key] = [value];
            }
        });
        this.handleRangeInputKeyValues(keyValues);
        return keyValues;
    }
    removeFilter(filterName, filterValue) {
        if (!this.isIlp()) {
            return;
        }
        if (filterValue.includes(" - ")) {
            if (filterName === "Mileage") {
                this.removeCheckboxFilter("Mileagerange", filterValue.replace(/\s/g, ""));
            }
            else {
                const filterRangeMin = document.querySelector(`input[name="${filterName.toLowerCase()}range"][data-min]`);
                const filterRangeMax = document.querySelector(`input[name="${filterName.toLowerCase()}range"][data-max]`);
                filterRangeMin.value = filterRangeMin.dataset.minValue;
                filterRangeMax.value = filterRangeMax.dataset.maxValue;
            }
        }
        else {
            this.removeCheckboxFilter(filterName, filterValue);
        }
    }
    removeCheckboxFilter(filterName, filterValue) {
        var _a;
        if (!this.isIlp()) {
            return;
        }
        const filterCheckbox = document.querySelector(`input[name="${filterName}"][value="${filterValue}"]`);
        if (filterCheckbox) {
            filterCheckbox.checked = false;
            filterCheckbox.parentElement.classList.remove("tile_selected");
        }
        if (filterName === "Model") {
            const allTrimsCheckbox = filterCheckbox.parentElement.nextElementSibling.querySelector("[id$=AllTrims]");
            if (allTrimsCheckbox) {
                allTrimsCheckbox.checked = false;
                allTrimsCheckbox.disabled = true;
                allTrimsCheckbox.dispatchEvent(new Event("change"));
                (_a = document.getElementById("filterPanel")) === null || _a === void 0 ? void 0 : _a.dispatchEvent(new Event("filter-number-change"));
            }
            jQueryHelper/* JQueryHelper */.$.SafeApplyCollapse(`[id^=collapse-options-model-${filterValue}-]`, 'hide');
        }
        else if (filterName === "ModelAndTrim") {
            const modelTrimSplit = filterValue.split(": ");
            const trimCheckboxFilter = document.querySelector(`[id='filter${modelTrimSplit[0]}${modelTrimSplit[1]}']`); // "4Runner: Limited"
            trimCheckboxFilter.checked = false;
            const trimsListParent = document.querySelector(`[id^='collapse-options-model-${modelTrimSplit[0]}']`);
            const trimsCheckboxes = Array.from(trimsListParent.querySelectorAll("[type='checkbox']:not([id$=AllTrims])"));
            const allTrimsCheckbox = trimsListParent.querySelector("[id$=AllTrims]");
            if (!trimsCheckboxes.some(checkbox => checkbox.checked)) {
                if (allTrimsCheckbox) {
                    allTrimsCheckbox.classList.remove("dash");
                    allTrimsCheckbox.checked = false;
                    allTrimsCheckbox.disabled = true;
                }
                const modelCheckbox = document.querySelector(`[name='Model'][value='${modelTrimSplit[0]}']`);
                if (modelCheckbox) {
                    modelCheckbox.checked = false;
                }
                jQueryHelper/* JQueryHelper */.$.SafeApplyCollapse(`[id^=collapse-options-model-${modelTrimSplit[0]}-]`, 'hide');
            }
        }
    }
    handleRangeInputKeyValues(keyValues, isRemove = false) {
        const rangeFilters = document.querySelectorAll("input[class^=range]");
        rangeFilters.forEach((elem) => {
            const key = elem.name;
            const preEncodeValue = this.removeWhiteSpace(elem.value);
            const value = encodeURIComponent(preEncodeValue);
            if (value > '') {
                if (key in keyValues) {
                    const preEncodeMax = elem.getAttribute("data-max-value");
                    const maxValue = encodeURIComponent(preEncodeMax);
                    const preEncodeMin = this.removeWhiteSpace(elem.getAttribute("data-min-value"));
                    const minValue = encodeURIComponent(preEncodeMin);
                    if (isRemove) {
                        if (keyValues[key] === minValue && value === maxValue) {
                            keyValues[key] = keyValues[key] + '-' + value;
                        }
                        else {
                            delete keyValues[key];
                        }
                    }
                    else {
                        if (keyValues[key] === minValue && value === maxValue) {
                            delete keyValues[key];
                        }
                        else {
                            keyValues[key] = keyValues[key] + '-' + value;
                        }
                    }
                }
                else {
                    keyValues[key] = value;
                }
            }
        });
    }
    triggerDealerOnTrackEvents(filters) {
        // Don't track search valet or zipcode/distance
        const keyValues = Object.assign({}, filters);
        delete keyValues.q;
        delete keyValues.vehiclelocation;
        const dealerOnTrackEvents = [];
        document.querySelectorAll("input[type=checkbox][id^=filter]:checked").forEach((element) => {
            if (element.name === "Model" || element.name === "Trim") {
                return;
            }
            let currentLabel = "";
            switch (element.value) {
                case "1":
                    currentLabel = "on";
                    break;
                default:
                    currentLabel = element.value;
            }
            const trackingCategory = "SRP - Filter - " + element.name;
            const eventGroup = dealerOnTrackEvents.find(event => event.category === trackingCategory);
            if (eventGroup) {
                eventGroup.label += ", " + currentLabel;
            }
            else {
                dealerOnTrackEvents.push({ category: trackingCategory, action: vehicleType, label: currentLabel });
            }
        });
        if (Array.isArray(keyValues.ModelAndTrim)) {
            dealerOnTrackEvents.push({ category: "SRP - Filter - Model_Trim", action: vehicleType, label: keyValues.ModelAndTrim.join(',') });
        }
        this.setupRangeInputTrackerData(dealerOnTrackEvents);
    }
    setupRangeInputTrackerData(dealerOnTrackEvents) {
        const rangeFilters = document.querySelectorAll("input[class^=range]");
        const rangeInputTrackerData = [];
        rangeFilters.forEach((elem) => {
            const key = elem.name;
            const trackerValue = this.removeWhiteSpace(encodeURIComponent((elem.value ? elem.value : elem.placeholder)));
            let currentTrackerData = rangeInputTrackerData.find(t => t.key === key);
            if (!currentTrackerData) {
                currentTrackerData = { key: key, min: elem.dataset.minValue, max: elem.dataset.maxValue };
                rangeInputTrackerData.push(currentTrackerData);
            }
            if (elem.id.indexOf("_min") > -1) {
                currentTrackerData.minValue = trackerValue;
            }
            else {
                currentTrackerData.maxValue = trackerValue;
            }
        });
        rangeInputTrackerData.forEach(function (entry) {
            //if the user modified any of the range values then send a track event
            if (entry.min !== entry.minValue || entry.max !== entry.maxValue) {
                let category = "SRP - Filter - ";
                //handle special cases with category names
                switch (entry.key) {
                    case "pricerange":
                        category = `${category}Buy`;
                        break;
                    case "financepricerange":
                        category = `${category}Finance`;
                        break;
                    case "leasepricerange":
                        category = `${category}Lease`;
                        break;
                    default:
                        category = `${category}${entry.key}`;
                }
                dealerOnTrackEvents.push({ category: category, action: vehicleType, label: "Min = " + entry.minValue + ", Max = " + entry.maxValue });
            }
        });
    }
    removeWhiteSpace(str) {
        return str.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " ");
    }
    initialize() {
        if (this.isIlp()) {
            const requestQueryString = window.location.search;
            const storedQueryString = this.getSavedFilterState();
            const isUndo = localStorage.getItem("isUndoFilterState");
            if (requestQueryString && !isUndo) {
                this.saveFilterState();
            }
            else if (isUndo) {
                localStorage.removeItem("isFilterStateUndo");
            }
            else if (storedQueryString && !requestQueryString) {
                this.showUndoButton(storedQueryString);
                const FILTER_STATE_CHANGE_EVENT = "filter-number-change";
                document.addEventListener(FILTER_STATE_CHANGE_EVENT, (event) => {
                    this.hideUndoButton();
                    this.clearSavedFilterState();
                }, { once: true });
            }
        }
    }
    saveFilterState() {
        localStorage.setItem("filterState", window.location.search);
    }
    getSavedFilterState() {
        const filterState = localStorage.getItem("filterState");
        return filterState || null;
    }
    clearSavedFilterState() {
        localStorage.removeItem("filterState");
    }
    showUndoButton(queryString) {
        var _a;
        const container = document.querySelector("[data-undo-btn-container]");
        const btn = document.querySelector("[data-undo-btn]");
        const filterCount = this.getClearedFilterCount(queryString);
        const filterCountSpan = document.getElementById("cleared-filters-count-text");
        btn === null || btn === void 0 ? void 0 : btn.addEventListener("click", this.handleUndo, { once: true });
        if (filterCountSpan) {
            if (filterCount == 1) {
                filterCountSpan.textContent = this.translate("FILTERS_CLEARED_SINGULAR");
            }
            else {
                filterCountSpan.textContent = (_a = this.translate("FILTERS_CLEARED_PLURAL")) === null || _a === void 0 ? void 0 : _a.replace('{0}', filterCount.toString());
            }
        }
        container === null || container === void 0 ? void 0 : container.removeAttribute("hidden");
    }
    getClearedFilterCount(queryString) {
        const filters = queryString.split(/[&,!]/g);
        return filters.length;
    }
    hideUndoButton() {
        const container = document.querySelector(".srp-selected-filters--cleared");
        const btn = document.querySelector("[data-undo-btn]");
        btn === null || btn === void 0 ? void 0 : btn.removeEventListener("click", this.handleUndo);
        container === null || container === void 0 ? void 0 : container.setAttribute("hidden", "true");
    }
    translate(item) {
        return this.translationService.getLabel(item);
    }
};
WasabiFilterState = wasabiFilterState_decorate([
    (0,inversify/* injectable */._G)(),
    wasabiFilterState_param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.ITranslationService)),
    wasabiFilterState_metadata("design:paramtypes", [Object])
], WasabiFilterState);


;// ./src/components/searchFilter/filterState.ts
var filterState_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var filterState_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var filterState_param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


let FilterState = class FilterState {
    constructor(translationService) {
        this.filterList = {};
        this.FILTER = "Filter";
        this.FILTERS = "Filters";
        this.APPLY = "Apply";
        this.APPLIED = "Applied";
        this.FILTER_STATE_APPLIED = "applied-filters";
        this.FILTER_STATE_APPLY = "apply-filters";
        this.FILTER_STATE_NONE = "no-filters";
        this.LABEL_APPLY_FILTERS = 'APPLY_FILTERS';
        this.LABEL_APPLY_FILTERS_SINGULAR = 'APPLY_FILTERS_SINGULAR';
        this.LABEL_APPLY_FILTERS_PLURAL = 'APPLY_FILTERS_PLURAL';
        this.LABEL_FILTERS_APPLIED_SINGULAR = 'FILTERS_APPLIED_SINGULAR';
        this.LABEL_FILTERS_APPLIED_PLURAL = 'FILTERS_APPLIED_PLURAL';
        this.LABEL_NO_FILTERS_TO_APPLY = 'NO_FILTERS_TO_APPLY';
        this.translationService = translationService;
    }
    initialize(filterStateJson = null) {
        //TODO: this entire filter state should be migrated to the pinia store once
        //  vue is fully implemented. For now we need to support loading filter state 
        //  from the server when the toggle is off
        if (!filterStateJson) {
            let filterStateJson = document.getElementById("filter-state");
            if (filterStateJson) {
                this.filterList = JSON.parse(filterStateJson.textContent);
                this.attachEvents();
            }
            else {
                console.error('#filter-state does not exist. Failed to initialize filter state');
            }
        }
        else {
            this.filterList = filterStateJson;
            this.attachEvents();
        }
    }
    attachEvents() {
        var vehicleSelectors = document.querySelectorAll("input[type='checkbox'][id^='filter']");
        vehicleSelectors.forEach((el) => {
            el.addEventListener('change', (element) => {
                var filterUpdated = element.target;
                var filterName = filterUpdated.name.toLowerCase();
                var filterValue = filterUpdated.value;
                var filterKey = this.getFilterKey(filterName, filterValue);
                if (filterUpdated.checked) {
                    this.updateApplyFilterBtnCount(filterKey, filterValue);
                    switch (filterName.toLowerCase()) {
                        case "cpo":
                            this.cpoCheckChanged(filterUpdated, filterUpdated.checked);
                            break;
                        case "model":
                            this.modelCheckChanged(filterUpdated, filterUpdated.checked);
                            break;
                        case "trim":
                            this.trimChecked(filterName, filterValue);
                            break;
                        case "cpotier":
                            this.cpoTierChecked(filterName, filterValue);
                            break;
                        case "intransit":
                            this.inTransitChecked(filterName);
                            break;
                        case "inproduction":
                            this.inProductionChecked(filterName);
                            break;
                        case "instock":
                            this.inStockChecked(filterName);
                            break;
                        default:
                        // do nothing
                    }
                }
                else {
                    switch (filterName.toLowerCase()) {
                        case "model":
                        case "trim":
                            this.modelOrTrimUnchecked(filterName, filterValue);
                            break;
                        case "cpo":
                        case "cpotier":
                            this.cpoOrCpoTierUnChecked(filterName, filterValue);
                            break;
                        default:
                        // do nothing
                    }
                    this.updateApplyFilterBtnCount(filterKey);
                }
                this.notifyFilterNumberChange();
                this.setFilterCountPillsOnLoad();
            });
            this.initInStockCheckbox();
        });
        var specialOnlyCheckbox = document.getElementsByClassName("special-only")[0];
        if (specialOnlyCheckbox) {
            specialOnlyCheckbox.addEventListener('click', (e) => {
                var checkbox = document.getElementById("filter-searchspecialsonly");
                if (checkbox) {
                    var key = checkbox.name.toLowerCase() + "-" + checkbox.value;
                    checkbox.checked = !checkbox.checked;
                    if (checkbox.checked) {
                        this.updateApplyFilterBtnCount(key, checkbox.value);
                    }
                    else {
                        this.updateApplyFilterBtnCount(key);
                    }
                    this.notifyFilterNumberChange();
                }
            });
        }
        var collapsableFilterBtns = document.querySelectorAll('.panel__content-btn');
        collapsableFilterBtns.forEach((btn) => {
            var panelOptionTitleId = btn.getAttribute('data-target');
            var filterPill = document.querySelector(`${panelOptionTitleId} .filter-count`);
            document.addEventListener('filter-number-change', () => {
                this.getFilterCount(filterPill);
            });
            btn.addEventListener('click', () => {
                this.handleCollapsibleFilterClick(filterPill);
            });
            btn.addEventListener('keyup', (keyPressed) => {
                if (keyPressed.code == 'Space' || keyPressed.code == 'Enter') {
                    this.handleCollapsibleFilterClick(filterPill);
                }
            });
        });
        document.addEventListener('range-value-change', (e) => {
            if (e.detail.min === e.detail.rangeMin && e.detail.max === e.detail.rangeMax) {
                this.updateApplyFilterBtnCount(e.detail.name.toLowerCase());
            }
            else {
                var key = e.detail.name.toLowerCase();
                var value = { min: e.detail.min, max: e.detail.max };
                this.updateApplyFilterBtnCount(key, value);
            }
            this.notifyFilterNumberChange();
        });
        document.addEventListener('filter-number-change', (e) => {
            this.updateSearchBtnText(e.detail);
        });
        document.addEventListener('filter-number-init', (e) => {
            this.initSearchBtnText(e.detail);
            this.setFilterCountPillsOnLoad();
        });
        const filterPanelContainer = document.querySelector("#srp_filter");
        if (filterPanelContainer) {
            filterPanelContainer.classList.remove("srp-filter--uninitialized");
            const loadingSpinners = filterPanelContainer.querySelectorAll(".filter-header-loading");
            if (loadingSpinners.length > 0) {
                loadingSpinners.forEach(elem => {
                    elem.classList.add("filter-header-loading--hidden");
                });
            }
        }
        this.notifyFilterNumberChange(true);
    }
    initSearchBtnText(count) {
        var searchButtonsV2 = document.querySelectorAll('[data-filter-search-btn]');
        if (searchButtonsV2 !== null && searchButtonsV2 !== undefined) {
            if (count > 0) {
                searchButtonsV2.forEach((btn) => {
                    var _a;
                    if (count == 1) {
                        btn.innerText = this.translate(this.LABEL_FILTERS_APPLIED_SINGULAR);
                    }
                    else {
                        btn.innerText = (_a = this.translate(this.LABEL_FILTERS_APPLIED_PLURAL)) === null || _a === void 0 ? void 0 : _a.replace('{0}', count);
                    }
                    btn.dataset.filterState = this.FILTER_STATE_APPLIED;
                });
            }
            else {
                searchButtonsV2.forEach((btn) => {
                    btn.innerText = this.translate(this.LABEL_NO_FILTERS_TO_APPLY);
                    btn.dataset.filterState = this.FILTER_STATE_NONE;
                });
                this.hideShowNoFiltersApplied();
            }
        }
    }
    updateSearchBtnText(count) {
        var searchButtonsV2 = document.querySelectorAll('[data-filter-search-btn]');
        if (searchButtonsV2 !== null && searchButtonsV2 !== undefined) {
            var filterPills = document.querySelector('.srp-selected-filters--pill-list');
            var filterPillsExist = filterPills && filterPills.children && filterPills.children.length > 0;
            if (count > 0) {
                searchButtonsV2.forEach((btn) => {
                    var _a;
                    if (count == 1) {
                        btn.innerText = this.translate(this.LABEL_APPLY_FILTERS_SINGULAR);
                    }
                    else {
                        btn.innerText = (_a = this.translate(this.LABEL_APPLY_FILTERS_PLURAL)) === null || _a === void 0 ? void 0 : _a.replace('{0}', count);
                    }
                    btn.dataset.filterState = this.FILTER_STATE_APPLY;
                    btn.classList.replace("btn-inactive", "btn-cta");
                });
            }
            else {
                searchButtonsV2.forEach((btn) => {
                    var _a;
                    if (filterPillsExist) {
                        btn.innerText = (_a = this.translate(this.LABEL_APPLY_FILTERS_PLURAL)) === null || _a === void 0 ? void 0 : _a.replace('{0}', count);
                        btn.dataset.filterState = this.FILTER_STATE_APPLY;
                        btn.classList.replace("btn-inactive", "btn-cta");
                    }
                    else {
                        btn.innerText = this.translate(this.LABEL_NO_FILTERS_TO_APPLY);
                        btn.dataset.filterState = this.FILTER_STATE_NONE;
                        btn.classList.replace("btn-cta", "btn-inactive");
                    }
                });
                this.hideShowNoFiltersApplied();
            }
        }
    }
    translate(item) {
        return this.translationService.getLabel(item);
    }
    hideShowNoFiltersApplied() {
        var noFiltersElement = document.querySelector(".srp-selected-filters #no-filters-text");
        if (!noFiltersElement) {
            return;
        }
        var filterPillsElement = document.querySelector('.srp-selected-filters--pill-list');
        var filtersClearedElement = document.querySelector(".srp-selected-filters--cleared");
        var undoBtnDisplayed = filtersClearedElement && !filtersClearedElement.hidden;
        if (!filterPillsElement && !undoBtnDisplayed) {
            noFiltersElement.removeAttribute("hidden");
        }
        else {
            noFiltersElement.setAttribute("hidden", "true");
        }
    }
    getFilterKey(inputElementName, inputElementValue) {
        return inputElementName.toLowerCase() + '-' + inputElementValue;
    }
    updateApplyFilterBtnCount(filterKey, filterValue = undefined) {
        if (filterValue) {
            this.filterList[filterKey] = filterValue;
        }
        else {
            delete this.filterList[filterKey];
        }
    }
    cpoCheckChanged(filter, shouldAddChildren) {
        var targetedID = $(filter.parentElement).attr('data-target');
        var elems = $(filter).parents('.list_display').find('' + targetedID + ' .collapse-options-sub .display_child.list_display_child input:checked');
        //account for not having any tiered items
        if (elems.length == 0 && $(filter).is(':checked')) {
            elems = filter;
        }
        this.updateChildrenInBtnFilterCount(elems, shouldAddChildren);
    }
    updateChildrenInBtnFilterCount(children, shouldAddChildren) {
        if (shouldAddChildren) {
            Array.from(children).forEach((child) => {
                var childFilterKey = this.getFilterKey(child.name, child.value);
                this.updateApplyFilterBtnCount(childFilterKey, child.value);
            });
            var parentFilterKey = this.getFilterKey(parent.name, undefined);
            //REFACTOR - parent.value was always undefined in the legacy js version of this.
            //var parentFilterKey = this.getFilterKey(parent.name, parent.value);
            this.updateApplyFilterBtnCount(parentFilterKey);
        }
        else {
            Array.from(children).forEach((child) => {
                var childFilterKey = this.getFilterKey(child.name, child.value);
                this.updateApplyFilterBtnCount(childFilterKey);
            });
        }
    }
    modelCheckChanged(filter, shouldAddChildren) {
        var targetedID = $(filter.parentElement).attr('data-target');
        var elems = $(filter).parents('.list_display').find('' + targetedID + ' .collapse-options-sub .display_child.list_display_child input:checked');
        this.updateChildrenInBtnFilterCount(elems, shouldAddChildren);
    }
    trimChecked(filterType, filterValue) {
        if (filterType == "trim") {
            var model = filterValue.split(',')[0];
            var modelKey = "model" + "-" + model;
            if (this.filterList[modelKey]) {
                this.updateApplyFilterBtnCount(modelKey);
            }
        }
    }
    cpoTierChecked(filterType, filterValue) {
        var cpoFilterType = "cpotier";
        if (filterType.toLowerCase() === cpoFilterType) {
            var cpoTierParentKey = filterValue.split(',')[0];
            if (this.filterList[cpoTierParentKey]) {
                this.updateApplyFilterBtnCount(cpoTierParentKey);
            }
        }
    }
    inTransitChecked(filterType) {
        if (filterType == "intransit") {
            this.RemoveInStockFilterFromCount();
            this.RemoveInProductionFilterFromCount();
        }
    }
    inProductionChecked(filterType) {
        if (filterType == "inproduction") {
            this.RemoveInStockFilterFromCount();
            this.RemoveInTransitFilterFromCount();
        }
    }
    inStockChecked(filterType) {
        if (filterType == "instock") {
            this.RemoveInTransitFilterFromCount();
            this.RemoveInProductionFilterFromCount();
        }
    }
    RemoveInStockFilterFromCount() {
        const inStockCheckbox = document.querySelector("[id^='filter-instock']");
        if (inStockCheckbox) {
            this.updateApplyFilterBtnCount("instock-1");
        }
    }
    RemoveInTransitFilterFromCount() {
        const inTransitCheckbox = document.querySelector("[id^='filter-intransit']");
        if (inTransitCheckbox) {
            this.updateApplyFilterBtnCount("intransit-1");
        }
    }
    RemoveInProductionFilterFromCount() {
        const inProductionCheckbox = document.querySelector("[id^='filter-inproduction']");
        if (inProductionCheckbox) {
            this.updateApplyFilterBtnCount("inproduction-1");
        }
    }
    modelOrTrimUnchecked(filterType, filterValue) {
        if (filterType == "model") {
            var model = filterValue;
            var trimKeyPrefix = "trim" + "-" + model;
            Object.keys(this.filterList).forEach((dictKey) => {
                if (dictKey.match(trimKeyPrefix)) {
                    this.updateApplyFilterBtnCount(dictKey);
                }
            });
        }
        else if (filterType == "trim") {
            var model = filterValue.split(',')[0];
            var modelKey = "model" + "-" + model;
            var trimKeyPrefix = "trim" + "-" + model;
            var count = 0;
            Object.keys(this.filterList).forEach((dictKey) => {
                if (dictKey.match(trimKeyPrefix)) {
                    count++;
                }
            });
            // When last trim for model is unchecked add model back to filter count
            if (count == 1) {
                this.updateApplyFilterBtnCount(modelKey, modelKey);
            }
        }
    }
    cpoOrCpoTierUnChecked(filterType, filterValue) {
        var cpoFilterType = "cpo";
        var cpotierFilterType = "cpotier";
        if (filterType == cpoFilterType) {
            Object.keys(this.filterList).forEach((dictKey) => {
                if (dictKey.startsWith(cpoFilterType)) {
                    this.updateApplyFilterBtnCount(dictKey);
                }
            });
        }
        else if (filterType == cpotierFilterType) {
            var count = 0;
            Object.keys(this.filterList).forEach((dictKey) => {
                if (dictKey.startsWith(cpotierFilterType)) {
                    count++;
                }
            });
            // When last cpotier for cpo is unchecked add cpo back to filter count
            if (count == 1) {
                var value = cpoFilterType + "-" + filterValue;
                this.updateApplyFilterBtnCount(cpoFilterType, value);
            }
        }
    }
    notifyFilterNumberChange(isInitCall = false) {
        var filterCount = Object.keys(this.filterList).length;
        if (Object.keys(this.filterList).includes("inproduction-1") && Object.keys(this.filterList).includes("intransit-1")) {
            filterCount -= 2;
        }
        if (isInitCall) {
            document.dispatchEvent(new CustomEvent('filter-number-init', { detail: filterCount }));
        }
        else {
            document.dispatchEvent(new CustomEvent('filter-number-change', { detail: filterCount }));
        }
    }
    setFilterCountPillsOnLoad() {
        var filterCountPills = document.querySelectorAll('#filter-panels .panel .filter-count');
        filterCountPills.forEach((filterCountPill) => {
            this.handleCollapsibleFilterClick(filterCountPill);
        });
    }
    handleCollapsibleFilterClick(filterCountPill) {
        if (filterCountPill) {
            var filterCount = this.getFilterCount(filterCountPill);
            this.showHideFilterCountPill(filterCountPill, filterCount);
        }
    }
    getFilterCount(filterCountPill) {
        if (!filterCountPill) {
            return;
        }
        var filterName = filterCountPill.id.replace("-count", "");
        if (filterName === "ModelAndTrim") {
            return this.getFilterCountForModelAndTrim();
        }
        else if (filterName.includes('range')) {
            var rangeFilterName = filterName.replace("-range", "").toLowerCase();
            if (rangeFilterName === "price") {
                return this.getFilterCountForPriceFilter();
            }
            else if (rangeFilterName === "mpg") {
                return this.getFilterCountForMpgFilter();
            }
            else if (typeof (this.filterList[rangeFilterName]) !== "undefined") {
                /* For Range Filters with Only One Range */
                return 1;
            }
        }
        else if (filterName === "vehicle-condition") {
            return this.getFilterCountForVehicleCondition();
        }
        else {
            // mileage is a special type of ranged checkbox that doesn't work like other
            // ranges, so we want to account for it here like other checkeboxes
            if (filterName.toLowerCase() == "mileage") {
                filterName += "range";
            }
            var elems = document.querySelectorAll("[name='" + filterName + "']:checked");
            return elems ? elems.length : 0;
        }
    }
    showHideFilterCountPill(filterCountPill, filterCount) {
        if (filterCount > 0) {
            filterCountPill.innerText = filterCount;
            filterCountPill.removeAttribute('hidden');
        }
        else {
            filterCountPill.innerText = "";
            filterCountPill.setAttribute('hidden', '');
        }
    }
    getFilterCountForModelAndTrim() {
        var modelFilters = document.querySelectorAll("[name='Model']:checked");
        var filterCount = modelFilters ? modelFilters.length : 0;
        modelFilters.forEach((model) => {
            var modelName = model.value.replace(/\s+/g, "-");
            var collapsableModelDiv = document.getElementById("collapse-options-model-" + modelName);
            if (collapsableModelDiv) {
                var trimFilterCountElem = collapsableModelDiv.querySelectorAll("[name='Trim']:checked");
                if (trimFilterCountElem) {
                    var trimFilterCount = trimFilterCountElem.length;
                    if (trimFilterCount > 1) {
                        filterCount += (trimFilterCount - 1);
                    }
                }
            }
        });
        return filterCount;
    }
    getFilterCountForPriceFilter() {
        var filterCount = 0;
        if (typeof (this.filterList["price"]) !== "undefined") {
            filterCount++;
        }
        if (typeof (this.filterList["leaseprice"]) !== "undefined") {
            filterCount++;
        }
        if (typeof (this.filterList["financeprice"]) !== "undefined") {
            filterCount++;
        }
        var checkboxSearchSpecialsOnly = document.getElementById("filter-searchspecialsonly");
        if (checkboxSearchSpecialsOnly && checkboxSearchSpecialsOnly.checked) {
            filterCount++;
        }
        return filterCount;
    }
    getFilterCountForMpgFilter() {
        var filterCount = 0;
        if (typeof (this.filterList["citympg"]) !== "undefined") {
            filterCount++;
        }
        if (typeof (this.filterList["hwympg"]) !== "undefined") {
            filterCount++;
        }
        return filterCount;
    }
    getFilterCountForVehicleCondition() {
        var vehicleConditionFilterCount = 1;
        var vehicleConditionFiltersDiv = document.querySelector('#Vehicle-Condition-Filters');
        var vehicleConditionFilters = (vehicleConditionFiltersDiv && vehicleConditionFiltersDiv.children) ? vehicleConditionFiltersDiv.children : undefined;
        if (vehicleConditionFilters) {
            Array.from(vehicleConditionFilters).forEach((vehicleConditionFilter) => {
                var checkedFilter = vehicleConditionFilter.querySelector('input[id^="filter"]:checked');
                if (checkedFilter) {
                    // Filters with nested filters - there is only one at this point (Certified Pre-Owned).
                    if (checkedFilter.name.toLowerCase().includes("cpo")) {
                        return;
                    }
                    else {
                        vehicleConditionFilterCount++;
                    }
                }
            });
        }
        //Get CpoTier Counts
        vehicleConditionFilterCount += this.getCpoTierCount();
        return vehicleConditionFilterCount;
    }
    getCpoTierCount() {
        var cpoFilters = document.querySelectorAll("[name='cpo']:checked");
        var filterCount = cpoFilters ? cpoFilters.length : 0;
        cpoFilters.forEach(() => {
            var collapsableDiv = document.getElementById("collapse-options-cpotier");
            if (collapsableDiv) {
                var tierFilterCountElem = collapsableDiv.querySelectorAll("[name='cpotier']:checked");
                if (tierFilterCountElem) {
                    var tierFilterCount = tierFilterCountElem.length;
                    if (tierFilterCount > 1) {
                        filterCount += (tierFilterCount - 1);
                    }
                }
            }
        });
        return filterCount;
    }
    initInStockCheckbox() {
        var inStockCheckbox = document.querySelector("#filter-instock");
        if (inStockCheckbox && inStockCheckbox.checked) {
            var key = inStockCheckbox.name.toLowerCase() + "-" + inStockCheckbox.value;
            this.updateApplyFilterBtnCount(key, inStockCheckbox.value);
        }
    }
};
FilterState = filterState_decorate([
    (0,inversify/* injectable */._G)(),
    filterState_param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.ITranslationService)),
    filterState_metadata("design:paramtypes", [Object])
], FilterState);


// EXTERNAL MODULE: ./src/services/toggles/toggleFetcher.ts
var toggleFetcher = __webpack_require__(55141);
// EXTERNAL MODULE: ./src/services/translations/defaultTranslationFetcher.ts
var defaultTranslationFetcher = __webpack_require__(88102);
// EXTERNAL MODULE: ./src/components/searchFilter/srpWasabi_General.ts + 1 modules
var srpWasabi_General = __webpack_require__(30721);
// EXTERNAL MODULE: ./src/components/vehicle/vehicleCard/vehicleCardWasabi.ts + 1 modules
var vehicleCardWasabi = __webpack_require__(88066);
;// ./src/components/searchFilter/rangeFilterCosmos.ts
var rangeFilterCosmos_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var rangeFilterCosmos_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

let RangeFilterCosmos = class RangeFilterCosmos {
    constructor() {
    }
    initialize() {
        let ranges = document.querySelectorAll("[data-range-filter-config]");
        for (let i = 0; i < ranges.length; i++) {
            const elem = ranges[i];
            if (elem) {
                const rangeConfig = { rangeId: elem.dataset.rangeFilterConfig };
                this.setupRange(rangeConfig);
            }
        }
        //TODO: Get rid of this when VUE conversion for FilterPanels is complete
        // if we didn't find any ranges above, then we are not rending vue components
        // so make sure the old way works.
        if (ranges.length === 0) {
            const scriptId = "range-filter-config";
            let ranges = document.querySelectorAll("[id^=" + scriptId + "]");
            // IE doesn't support forEach on NodeList
            Array.prototype.forEach.call(ranges, (range) => {
                const jsonData = JSON.parse(range.text);
                this.setupRange(jsonData);
            });
        }
    }
    setupRange(rangeConfig) {
        // Initialize min/max elements and listeners
        const rangeName = rangeConfig.rangeId;
        let minElement = document.getElementById(rangeName + '_min');
        let maxElement = document.getElementById(rangeName + '_max');
        switch (rangeName) {
            case "range-filter-config-finance":
                minElement = document.getElementById('financeprice_min');
                maxElement = document.getElementById('financeprice_max');
                break;
            case "range-filter-config-lease":
                minElement = document.getElementById('leaseprice_min');
                maxElement = document.getElementById('leaseprice_max');
                break;
        }
        this.setupSliderEventListeners(minElement, maxElement);
        this.setupSeparatorEventListeners(minElement, maxElement);
    }
    updateSlider(elem, position) {
        if (!elem.id) {
            return;
        }
        const elemValue = elem.value.replace(/,/g, '');
        let inputValue = parseFloat(elemValue);
        const baseElemId = elem.id.split("_")[0];
        const minElemId = baseElemId + "_min";
        const maxElemId = baseElemId + "_max";
        //enforce step
        const sliderStep = parseFloat(elem.dataset.stepSize);
        inputValue = Math.ceil(inputValue / sliderStep) * sliderStep;
        elem.value = inputValue;
        //min value
        const defaultMinValue = parseFloat(elem.dataset.minValue);
        const minElem = document.getElementById(minElemId);
        let selectedMinValue = 0;
        if (minElem) {
            let minValue = minElem.value.replace(/,/g, '');
            selectedMinValue = parseFloat(minValue);
            if (isNaN(selectedMinValue)) {
                selectedMinValue = defaultMinValue;
            }
        }
        //max value
        const defaultMaxValue = parseFloat(elem.dataset.maxValue);
        const maxElem = document.getElementById(maxElemId);
        let selectedMaxValue = 0;
        if (maxElem) {
            let maxValue = maxElem.value.replace(/,/g, '');
            selectedMaxValue = parseFloat(maxValue);
            if (isNaN(selectedMaxValue)) {
                selectedMaxValue = defaultMaxValue;
            }
        }
        //trigger validation message
        let validator = elem.parentElement.parentElement.parentElement.getElementsByClassName("invalid-feedback");
        if (validator) {
            validator = validator[0];
            if (selectedMinValue > selectedMaxValue) {
                validator.classList.remove("hidden");
            }
            else {
                validator.classList.add("hidden");
            }
        }
        //enforce min/max values and don't let the min/max values pass each other
        if (isNaN(inputValue) || selectedMinValue > selectedMaxValue) {
            if (position == 0) {
                inputValue = defaultMinValue;
                elem.value = defaultMinValue;
                selectedMinValue = defaultMinValue;
            }
            else {
                inputValue = defaultMaxValue;
                elem.value = defaultMaxValue;
                selectedMaxValue = defaultMaxValue;
            }
        }
        const sliderEvent = new CustomEvent('range-value-change', {
            detail: {
                name: baseElemId,
                min: selectedMinValue,
                max: selectedMaxValue,
                rangeMin: defaultMinValue,
                rangeMax: defaultMaxValue
            }
        });
        document.dispatchEvent(sliderEvent);
    }
    setupSliderEventListeners(minElement, maxElement) {
        if (minElement) {
            minElement.addEventListener("change", (e) => {
                this.updateSlider(e.target, 0);
            });
        }
        if (maxElement) {
            maxElement.addEventListener("change", (e) => {
                this.updateSlider(e.target, 1);
            });
        }
    }
    separatorUpdater(minObj, maxObj) {
        let inputMin = minObj.value === "" ? minObj.getAttribute('placeholder') : minObj.value;
        let inputMax = maxObj.value === "" ? maxObj.getAttribute('placeholder') : maxObj.value;
        // Don't add a separator for year values
        if (!minObj.parentElement.classList.contains("input-year")) {
            inputMin = this.formatValueWithSeparator(inputMin);
        }
        if (!maxObj.parentElement.classList.contains("input-year")) {
            inputMax = this.formatValueWithSeparator(inputMax);
        }
        minObj.value = inputMin;
        maxObj.value = inputMax;
    }
    formatValueWithSeparator(value) {
        const cleanValue = value.replace(/,/g, "");
        return new Intl.NumberFormat("en-US", { style: "decimal" }).format(cleanValue);
    }
    setupSeparatorEventListeners(minElement, maxElement) {
        if (minElement && maxElement) {
            minElement.addEventListener('change', () => {
                this.separatorUpdater(minElement, maxElement);
            });
            maxElement.addEventListener('change', () => {
                this.separatorUpdater(minElement, maxElement);
            });
        }
    }
};
RangeFilterCosmos = rangeFilterCosmos_decorate([
    (0,inversify/* injectable */._G)(),
    rangeFilterCosmos_metadata("design:paramtypes", [])
], RangeFilterCosmos);


// EXTERNAL MODULE: ./src/services/vehicleService/vehicleService.ts
var vehicleService = __webpack_require__(42283);
// EXTERNAL MODULE: ./src/components/spaCosmos/commonModels/srpPageSettingsModel.ts
var srpPageSettingsModel = __webpack_require__(16611);
// EXTERNAL MODULE: ./src/services/serviceHelpers.ts
var serviceHelpers = __webpack_require__(17090);
;// ./src/services/filterService/filterService.ts
var filterService_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var filterService_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var filterService_param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





let FilterService = class FilterService {
    constructor(toggleService, personalizationService) {
        this.rootSrpFiltersUrl = "/api/vhcliaa/vehicle-pages/cosmos/srp/filters/";
        this.filterCache = {};
        this.getFilterApiUrl = (dealerId, pageId, dynamicCountsSearchParams) => {
            let searchParams = serviceHelpers/* ServiceHelpers */.d.getBaseApiQueryString(undefined, dynamicCountsSearchParams);
            //HACK: don't decode the queryString params because we allow dealers to add unsafe data and this will break the search
            let apiUrl = `${this.rootSrpFiltersUrl}${dealerId}/${pageId}?${serviceHelpers/* ServiceHelpers */.d.mapArrayToQueryString(searchParams)}`;
            return apiUrl;
        };
        this.getFilters = (dealerId, pageId, dynamicCountsSearchParams) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let url = this.getFilterApiUrl(dealerId, pageId, dynamicCountsSearchParams);
            //Personalization (aka Signals)
            //NOTE: We add this here so we don't have to see it visually show up on the URL every time 
            url = (_b = (_a = this.personalizationService) === null || _a === void 0 ? void 0 : _a.addPersonalizationParameters(url)) !== null && _b !== void 0 ? _b : url;
            if (this.toggleService.getToggleStatus(toggles_toggleService/* Toggle */.lM.DO45165_InitQuickPass2)) {
                if (this.filterCache[url]) {
                    return this.filterCache[url];
                }
                const response = serviceHelpers/* ServiceHelpers */.d.sendApiRequest(url);
                this.filterCache[url] = response;
                return response;
            }
            return serviceHelpers/* ServiceHelpers */.d.sendApiRequest(url);
        });
        //Helpers
        //we put these here so we can inject toggleService more better than in the pinia stores
        //which don't have a way to take a constructor
        this.isDynamicFilteringEnabled = (filterType, uiLocation) => {
            return filterType === srpPageSettingsModel/* SrpFilterType */.K.Dynamic;
        };
        this.toggleService = toggleService;
        this.personalizationService = personalizationService;
        this.filterCache = {};
    }
    hideZeroCountFilters() {
        return this.toggleService.getToggleStatus(toggles_toggleService/* Toggle */.lM.HideZeroCountFilters);
    }
};
FilterService = filterService_decorate([
    (0,inversify/* injectable */._G)(),
    filterService_param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IToggleService)),
    filterService_param(1, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IPersonalizationService)),
    filterService_metadata("design:paramtypes", [Object, Object])
], FilterService);


;// ./src/components/priceStak/priceStakSyncDataModel.ts
class PriceStakSyncDataModel {
    constructor() {
        this.previousElementScrollY = 0;
    }
}

// EXTERNAL MODULE: ./src/components/pricing/pricingTypeCookie.ts
var pricingTypeCookie = __webpack_require__(41373);
// EXTERNAL MODULE: ./src/components/spaCosmos/pagination/srpScrollType.ts
var srpScrollType = __webpack_require__(31560);
// EXTERNAL MODULE: ./src/infrastructure/vue/cosmosSrp/vehicleLoadCause.ts
var vehicleLoadCause = __webpack_require__(23249);
;// ./src/components/spaCosmos/vehicleCards/vehiclePricingPanel/priceStakDataModel.ts
class PriceStakDataModel {
    constructor(selectedTab) {
        this.selectedTab = selectedTab;
    }
}

// EXTERNAL MODULE: ./src/utilities/performanceHelpers.ts
var performanceHelpers = __webpack_require__(69185);
;// ./src/components/priceStak/priceStakSynchronizer.ts
var priceStakSynchronizer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var priceStakSynchronizer_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var priceStakSynchronizer_param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var priceStakSynchronizer_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};









var DropdownEvent;
(function (DropdownEvent) {
    DropdownEvent["SHOW"] = "show";
    DropdownEvent["HIDE"] = "hide";
})(DropdownEvent || (DropdownEvent = {}));
var DropdownButtonText;
(function (DropdownButtonText) {
    DropdownButtonText["MORE"] = "More";
    DropdownButtonText["LESS"] = "Less";
})(DropdownButtonText || (DropdownButtonText = {}));
var DoTaggingResult;
(function (DoTaggingResult) {
    DoTaggingResult["INCREASE"] = "increase";
    DoTaggingResult["DECREASE"] = "decrease";
})(DoTaggingResult || (DoTaggingResult = {}));
let PriceStakSynchronizer = class PriceStakSynchronizer {
    constructor(storeProvider) {
        this.priceStakSyncDataModel = new PriceStakSyncDataModel();
        this.storeProvider = storeProvider;
    }
    initialize(scrollType, causeOfVehicleLoad = vehicleLoadCause/* VehicleLoadCause */.q.Unknown) {
        this.globalStore = this.storeProvider.getGlobalStore();
        if (scrollType === srpScrollType/* SrpScrollType */.v.InfiniteScroll) {
            // Set all pricestak dropdowns to open/close when the dropdown is clicked
            if (!this.priceStakSyncDataModel.dropdowns) {
                this.getElements();
                this.addPriceStakDropdownListeners();
            }
            else {
                let newDropdownStartIndex = this.priceStakSyncDataModel.dropdowns.length > 0 ? this.priceStakSyncDataModel.dropdowns.length - 1 : 0;
                if (causeOfVehicleLoad != vehicleLoadCause/* VehicleLoadCause */.q.InfiniteScroll) {
                    //start from 0 if we filtered vehicles (infinite scroll)
                    newDropdownStartIndex = 0;
                }
                this.getElements();
                // Add listeners only for new pricestak dropdowns (infinite scroll)
                this.addPriceStakDropdownListeners(newDropdownStartIndex);
                // Sync dropdowns
                let firstDropdown = this.priceStakSyncDataModel.dropdownButtons[0];
                if (firstDropdown) {
                    const ariaExpanded = firstDropdown.getAttribute('aria-expanded');
                    const eventType = ariaExpanded === 'true' ? DropdownEvent.SHOW : DropdownEvent.HIDE;
                    this.toggleDropdowns(eventType, newDropdownStartIndex);
                }
            }
            this.addPriceStakDropdownResizeObserver();
            // Set all pricestak tabs to switch when a tab is clicked
            if (!this.priceStakSyncDataModel.priceStackTabs) {
                this.setPriceStakTabDataModel();
                this.setPriceStakTabListeners();
                this.checkForQuerystringOverrides();
                this.switchAllTabs();
            }
            else {
                // Add listeners only for new pricestak tabs (infinite scroll)
                let newTabStartIndex = this.priceStakSyncDataModel.priceStackTabs.length > 0 ? this.priceStakSyncDataModel.priceStackTabs.length - 1 : 0;
                if (causeOfVehicleLoad != vehicleLoadCause/* VehicleLoadCause */.q.InfiniteScroll) {
                    //start from 0 if we filtered vehicles (infinite scroll)
                    newTabStartIndex = 0;
                }
                this.setPriceStakTabListeners(newTabStartIndex);
                this.switchAllTabs();
            }
        }
        else {
            //set pricestak dropdowns for pagination
            this.getElements();
            this.addPriceStakDropdownListeners();
            // Sync Dropdowns
            let firstDropdown = this.priceStakSyncDataModel.dropdownButtons[0];
            if (firstDropdown) {
                const ariaExpanded = firstDropdown.getAttribute('aria-expanded');
                const eventType = ariaExpanded === 'true' ? DropdownEvent.SHOW : DropdownEvent.HIDE;
                this.toggleDropdowns(eventType);
            }
            this.addPriceStakDropdownResizeObserver();
            //set pricestak tabs for pagination
            this.setPriceStakTabDataModel();
            this.setPriceStakTabListeners();
            this.checkForQuerystringOverrides();
            this.switchAllTabs();
        }
    }
    ;
    scrollAnchorAfter(target, buttonBeforeY) {
        return priceStakSynchronizer_awaiter(this, void 0, void 0, function* () {
            let buttonAfterY = yield this.getTargetScrollTop(target);
            window.scrollTo(0, window.scrollY - (buttonBeforeY - buttonAfterY));
            setTimeout(() => this.globalStore.updateProgramaticScroll(false), 500);
        });
    }
    getTargetScrollTop(target) {
        return priceStakSynchronizer_awaiter(this, void 0, void 0, function* () {
            let boundingRect;
            yield (0,performanceHelpers/* doBeforeNextRepaint */.L)(() => {
                boundingRect = target.getBoundingClientRect();
            });
            return boundingRect.top;
        });
    }
    setPriceStakTabDataModel() {
        var widgetDataElement = document.getElementById('priceStakDataModel');
        if (widgetDataElement && widgetDataElement.textContent) {
            this.priceStakSyncDataModel.priceStakDataModel = JSON.parse(widgetDataElement.textContent);
        }
        else {
            this.priceStakSyncDataModel.priceStakDataModel = new PriceStakDataModel('buy');
        }
    }
    checkForQuerystringOverrides() {
        var queryString = window.location.search.toLocaleLowerCase();
        if (queryString.includes('?pricerange') || queryString.includes('&pricerange')) {
            this.priceStakSyncDataModel.priceStakDataModel.selectedTab = 'buy';
        }
        else if (queryString.includes('financepricerange')) {
            this.priceStakSyncDataModel.priceStakDataModel.selectedTab = 'finance';
        }
        else if (queryString.includes('leasepricerange')) {
            this.priceStakSyncDataModel.priceStakDataModel.selectedTab = 'lease';
        }
    }
    setPriceStakTabListeners(startIndex = 0) {
        this.priceStakSyncDataModel.priceStackTabs = document.querySelectorAll('[data-pricestak-tab]:not([data-pricestack-tabs-init="true"])');
        for (let i = startIndex; i < this.priceStakSyncDataModel.priceStackTabs.length; i++) {
            const button = this.priceStakSyncDataModel.priceStackTabs[i];
            if (button) {
                button.addEventListener('click', (event) => priceStakSynchronizer_awaiter(this, void 0, void 0, function* () {
                    let target = event.currentTarget;
                    let buttonBeforeY = yield this.getTargetScrollTop(target);
                    this.priceStakSyncDataModel.priceStakDataModel.selectedTab = (target).getAttribute('data-pricestak-tab');
                    pricingTypeCookie/* PricingTypeCookie */.L.setPricingTypeCookie(this.priceStakSyncDataModel.priceStakDataModel.selectedTab);
                    this.globalStore.updateProgramaticScroll(true);
                    this.switchAllTabs();
                    yield this.scrollAnchorAfter(target, buttonBeforeY);
                }));
                button.setAttribute('data-pricestack-tabs-init', 'true');
            }
        }
    }
    switchAllTabs() {
        var _a;
        var allTabContainers = document.querySelectorAll('[data-pricestak-main]');
        let selectedTab = (_a = pricingTypeCookie/* PricingTypeCookie */.L.currentCookieValue) !== null && _a !== void 0 ? _a : this.priceStakSyncDataModel.priceStakDataModel.selectedTab;
        // send event to Vue priceStakTabs to set the tabs correctly on refresh
        document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.SwitchPricingTab, { detail: selectedTab }));
        allTabContainers.forEach((tabContainer) => {
            //check for tab, if it does not exist in this tab container, try buy
            //CONPLAT-2374: Use the PricingTypeCookie value to determine the selected tab
            var tabSelector = `[data-pricestak-tab='${selectedTab}']`;
            var selectedTabElement = tabContainer.querySelector(tabSelector);
            if (selectedTabElement) {
                this.switchTab(tabContainer, selectedTab);
            }
            else {
                //if there is no "buy" tab, nothing to do
                var defaultTabSelector = `[data-pricestak-tab='buy']`;
                var defaultTabElement = tabContainer.querySelector(defaultTabSelector);
                if (defaultTabElement) {
                    this.switchTab(tabContainer, 'buy');
                }
            }
        });
    }
    switchTab(tabContainer, newTabName) {
        var _a, _b, _c, _d;
        if (tabContainer) {
            const currentTabWrapper = tabContainer.querySelector('[data-pricestak-tab-wrapper].active');
            const currentTabButton = currentTabWrapper === null || currentTabWrapper === void 0 ? void 0 : currentTabWrapper.querySelector('[data-pricestak-tab]');
            const currentTabPane = tabContainer.querySelector('[data-pricestak-tab-pane].active');
            const newTabWrapper = tabContainer.querySelector(`[data-pricestak-tab-wrapper="${newTabName}"]`);
            const newTabButton = tabContainer.querySelector(`[data-pricestak-tab="${newTabName}"]`);
            const newTabPane = tabContainer.querySelector(`[data-pricestak-tab-pane="${newTabName}"]`);
            (_a = currentTabWrapper === null || currentTabWrapper === void 0 ? void 0 : currentTabWrapper.classList) === null || _a === void 0 ? void 0 : _a.remove('active');
            currentTabButton === null || currentTabButton === void 0 ? void 0 : currentTabButton.setAttribute('aria-expanded', 'false');
            (_b = currentTabPane === null || currentTabPane === void 0 ? void 0 : currentTabPane.classList) === null || _b === void 0 ? void 0 : _b.remove('active');
            (_c = newTabWrapper === null || newTabWrapper === void 0 ? void 0 : newTabWrapper.classList) === null || _c === void 0 ? void 0 : _c.add('active');
            newTabButton === null || newTabButton === void 0 ? void 0 : newTabButton.setAttribute('aria-expanded', 'true');
            (_d = newTabPane === null || newTabPane === void 0 ? void 0 : newTabPane.classList) === null || _d === void 0 ? void 0 : _d.add('active');
        }
    }
    getElements() {
        this.priceStakSyncDataModel.dropdowns = document.querySelectorAll('[data-pricestak-element="collapse"]');
        this.priceStakSyncDataModel.dropdownButtons = document.querySelectorAll('[data-pricestak-element="collapse-button"]');
        this.priceStakSyncDataModel.dropdownButtonLabels = document.querySelectorAll('[data-pricestak-element="collapse-button-label"]');
    }
    addPriceStakDropdownListeners(startIndex = 0) {
        if (this.priceStakSyncDataModel.dropdowns && this.priceStakSyncDataModel.dropdownButtonLabels) {
            for (let i = startIndex; i < this.priceStakSyncDataModel.dropdowns.length; i++) {
                const button = this.priceStakSyncDataModel.dropdownButtons[i];
                // we want to add a dropdown-listener attribute to avoid duplicate listeners that will cause incorrect
                // dropdown labels
                if (button && button.getAttribute('dropdown-listener') !== 'enabled') {
                    button.addEventListener('click', (event) => {
                        this.dropdownButtonCallback(event);
                    });
                    button.setAttribute('dropdown-listener', 'enabled');
                }
            }
            window.jQuery(this.priceStakSyncDataModel.dropdowns).on('hidden.bs.collapse', (event) => {
                this.toggleDropdownResizeObservation(false);
            });
            window.jQuery(this.priceStakSyncDataModel.dropdowns).on('shown.bs.collapse', (event) => {
                this.toggleDropdownResizeObservation(false);
            });
        }
    }
    dropdownButtonCallback(event) {
        var _a;
        event.preventDefault();
        const clickedElement = event.target;
        const clickedButton = clickedElement.closest('[data-pricestak-element="collapse-button"]');
        const target_DropdownSelector = (_a = clickedButton === null || clickedButton === void 0 ? void 0 : clickedButton.dataset) === null || _a === void 0 ? void 0 : _a.target;
        const currentDropdown = document.querySelector(target_DropdownSelector);
        // only allow opening/closing the dropdown if its not already in the process of opening/closing
        if (!currentDropdown.classList.contains("collapsing")) {
            const scrollbarPositionBeforeToggle = document.documentElement.scrollTop;
            const scrollHeightBeforeToggle = document.documentElement.scrollHeight;
            this.priceStakSyncDataModel.currentScrollbarRatio = scrollbarPositionBeforeToggle / scrollHeightBeforeToggle;
            const ariaExpanded = clickedButton.getAttribute('aria-expanded');
            this.toggleDropdownResizeObservation(true, currentDropdown);
            if (ariaExpanded != null) {
                const eventType = ariaExpanded === 'true' ? DropdownEvent.HIDE : DropdownEvent.SHOW;
                this.toggleDropdowns(eventType);
            }
        }
    }
    addPriceStakDropdownResizeObserver() {
        if (!this.priceStakSyncDataModel.resizeObserver) {
            this.priceStakSyncDataModel.resizeObserver = new ResizeObserver(() => {
                const scrollHeightAfterToggle = document.documentElement.scrollHeight;
                const scrollbarPositionAfterToggle = scrollHeightAfterToggle * this.priceStakSyncDataModel.currentScrollbarRatio;
                document.documentElement.scrollTo({ top: scrollbarPositionAfterToggle });
            });
        }
    }
    toggleDropdownResizeObservation(shouldObserve, currentDropdown = null) {
        if (currentDropdown) {
            if (shouldObserve) {
                this.priceStakSyncDataModel.resizeObserver.observe(currentDropdown);
            }
            else {
                this.priceStakSyncDataModel.resizeObserver.unobserve(currentDropdown);
            }
        }
    }
    toggleDropdowns(eventType, startIndex = 0) {
        const newButtonLabel = eventType === DropdownEvent.SHOW ? DropdownButtonText.LESS : DropdownButtonText.MORE;
        const newButtonDoTaggingResult = eventType === DropdownEvent.SHOW ? DoTaggingResult.DECREASE : DoTaggingResult.INCREASE;
        for (let i = startIndex; i < this.priceStakSyncDataModel.dropdownButtons.length; i++) {
            const label = this.priceStakSyncDataModel.dropdownButtonLabels[i];
            const dropdown = this.priceStakSyncDataModel.dropdowns[i];
            const doTaggedButton = this.priceStakSyncDataModel.dropdownButtons[i];
            doTaggedButton.setAttribute('data-dotagging-event-action-result', newButtonDoTaggingResult);
            label.innerText = newButtonLabel;
            $(dropdown).collapse(eventType);
        }
    }
};
PriceStakSynchronizer = priceStakSynchronizer_decorate([
    (0,inversify/* injectable */._G)(),
    priceStakSynchronizer_param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IStoreProvider)),
    priceStakSynchronizer_metadata("design:paramtypes", [Object])
], PriceStakSynchronizer);


// EXTERNAL MODULE: ./src/components/shareVehicleModal/shareVehicleModal.ts + 1 modules
var shareVehicleModal = __webpack_require__(94999);
// EXTERNAL MODULE: ./src/components/oem/ford/evnVideoPlayer.ts
var evnVideoPlayer = __webpack_require__(83925);
;// ./src/services/oem/oemVehicleStatusService/oemVehicleStatusService.ts
var oemVehicleStatusService_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var oemVehicleStatusService_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var oemVehicleStatusService_param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


let OemVehicleStatusService = class OemVehicleStatusService {
    constructor(translationService) {
        this.translationService = translationService;
    }
    getVehicleStatusLabel(stage) {
        const compareText = decodeURIComponent(stage).toLowerCase();
        let label = stage;
        // TODO: We need to bring down the actual OemProgram to the front end so that we can check specifically if the Dealer is that Oem type (e.g. Dealer == Ford, etc)
        switch (compareText) {
            // Ford/Lincoln
            case "stockinventory":
                label = this.translationService.getLabel("IN_STOCK");
                break;
            case "stockintransit":
                label = this.translationService.getLabel("IN_TRANSIT");
                break;
            case "stockinplant":
                label = this.translationService.getLabel("DEALER_ORDERED");
                break;
            case "extendedinventory":
                label = this.translationService.getLabel("EXTENDED_INVENTORY");
                break;
            case "fctp_readyforsale":
                label = this.translationService.getLabel("FCTP_READY_FOR_SALE");
                break;
            case "fctp_inservice":
                label = this.translationService.getLabel("FCTP_INSERVICE_SHORT");
                break;
            case "available":
                label = this.translationService.getLabel("SRP_REFINEMENT_AVAILABLE");
                break;
            // GM
            case "in-transit retail stock":
                label = this.translationService.getLabel("IN_TRANSIT");
                break;
            case "courtesy car retail stock":
                label = this.translationService.getLabel("FCTP_READY_FOR_SALE");
                break;
            case "dealer retail grounded stock":
                label = this.translationService.getLabel("IN_STOCK");
                break;
            case "dealer demo retail stock":
                label = this.translationService.getLabel("DEMO_VEHICLE");
                break;
            case "driver ed retail stock":
                label = this.translationService.getLabel("DRIVER_ED_VEHICLE");
                break;
            default:
                label = stage;
                break;
        }
        return label;
    }
};
OemVehicleStatusService = oemVehicleStatusService_decorate([
    (0,inversify/* injectable */._G)(),
    oemVehicleStatusService_param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.ITranslationService)),
    oemVehicleStatusService_metadata("design:paramtypes", [Object])
], OemVehicleStatusService);


;// ./src/core/enums/localStorageContainer.ts
var LocalStorageContainer;
(function (LocalStorageContainer) {
    LocalStorageContainer["SignalsForYouDql"] = "do_signals_personalized_vehicles_query";
})(LocalStorageContainer || (LocalStorageContainer = {}));

;// ./src/services/personalizationService/personalizationService.ts
var personalizationService_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var personalizationService_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var personalizationService_param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PersonalizationService_1;



let PersonalizationService = PersonalizationService_1 = class PersonalizationService {
    constructor(toggleService) {
        this.toggleService = toggleService;
    }
    isForYouFilterEnabled() {
        return this.getSignalsForYouDql() != null;
    }
    getSignalsForYouDql(url = "") {
        var getSignalsForYouDql = localStorage.getItem(LocalStorageContainer.SignalsForYouDql);
        // Check the query to see if the we want to override the signalsForYou dql
        if (url.includes("overrideForYouDql=")) {
            getSignalsForYouDql = this.overrideForYouDql(url);
        }
        if (!getSignalsForYouDql) {
            return null;
        }
        //NOTE: always base64 encode Dql
        let encoded = `${btoa(getSignalsForYouDql).replace(/\+/g, "%2B")}`;
        if (encoded.length < PersonalizationService_1.QS_MAX_LENGTH) {
            return encoded;
        }
        else {
            return null;
        }
    }
    addPersonalizationParameters(url) {
        const signalsDql = this.getSignalsForYouDql(url);
        if (signalsDql === null) {
            return url;
        }
        const separator = url.indexOf("?") > -1 ? "&" : "?";
        return `${url}${separator}signalsforyoudql=${signalsDql}`;
    }
    overrideForYouDql(url) {
        const queryString = url.split('?')[1] || '';
        const params = new URLSearchParams(queryString);
        return params.get("overrideForYouDql");
    }
};
PersonalizationService.QS_MAX_LENGTH = 2000;
PersonalizationService = PersonalizationService_1 = personalizationService_decorate([
    (0,inversify/* injectable */._G)(),
    personalizationService_param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IToggleService)),
    personalizationService_metadata("design:paramtypes", [Object])
], PersonalizationService);


// EXTERNAL MODULE: ./src/infrastructure/vue/types/appLocation.ts
var appLocation = __webpack_require__(38602);
// EXTERNAL MODULE: ./src/infrastructure/vue/cosmosSrp/globalStore.ts + 11 modules
var globalStore = __webpack_require__(53551);
// EXTERNAL MODULE: ./src/infrastructure/vue/vehicleCardDeck/globalStore.ts + 1 modules
var vehicleCardDeck_globalStore = __webpack_require__(65467);
;// ./src/services/stores/storeProvider.ts
var storeProvider_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




let StoreProvider = class StoreProvider {
    initialize(appLocation) {
        this.appLocation = appLocation;
    }
    /**
     * Get the global store that a component should pull from based on its app's location
     */
    getGlobalStore() {
        switch (this.appLocation) {
            case appLocation/* AppLocation */.V.CosmosSrp:
                return (0,globalStore/* useGlobalStore */.o)();
            case appLocation/* AppLocation */.V.VehicleCardDeck:
                return (0,vehicleCardDeck_globalStore/* useGlobalStore */.o)();
            default:
                return (0,globalStore/* useGlobalStore */.o)();
        }
    }
};
StoreProvider = storeProvider_decorate([
    (0,inversify/* injectable */._G)()
], StoreProvider);


// EXTERNAL MODULE: ./src/components/vehicleDisclaimerModal/vehiclePricestakDisclaimerModal.ts
var vehiclePricestakDisclaimerModal = __webpack_require__(56579);
// EXTERNAL MODULE: ./src/components/digitalGarage/tdgConfirmAndContactButtons.ts
var tdgConfirmAndContactButtons = __webpack_require__(47067);
;// ./src/utilities/stringHelpers.ts
class StringHelpers {
    static isNullOrWhitespace(input) {
        if (input === undefined || input == null) {
            return true;
        }
        return input.replace(/\s/g, '').length < 1;
    }
}

;// ./src/services/locationSortModalService/locationSortModalService.ts
var locationSortModalService_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let LocationSortModalService = class LocationSortModalService {
    constructor() {
        // These are the three types of interactions we track for the modal.
        // Coordinate is associated with the user sharing their GeoLocation,
        // zip is associated with the user entering a zip code,
        // closed is associated with the user closing the modal in any way without taking action.
        this.MODAL_INTERACTION_COORDINATE = 'coordinate';
        this.MODAL_INTERACTION_ZIP = 'zip';
        this.MODAL_INTERACTION_CLOSED = 'closed';
        // Cookie storage keys
        this.MODAL_INTERACTION_COOKIE = 'DLRON_LOCATION_MODAL_USED';
        this.COORDINATE_COOKIE = 'DLRON_coordinate';
        this.ZIP_COOKIE = 'DLRON_ZIP';
        this.COORDINATE_PARTIAL = 'DLRON_coordinate_';
    }
    initialize(defaultSortOrder, enableDistanceModal) {
        this.setupModalEventListeners();
        //NOTE: EnableDistanceModal only controls whether or not we show the modal on page load.
        if (enableDistanceModal && this.shouldShowGeoModalOnLoad(defaultSortOrder)) {
            // @ts-ignore
            jQuery('#geoFilterModal').modal('show');
            this.findCookieAndShowButton();
        }
    }
    askLocation() {
        if (!globalThis.DealeronCookie.hasItem(this.COORDINATE_COOKIE)) {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(this.createCoordinateCookie.bind(this), (error) => alert('Error: ' + error.message));
            }
            else {
                alert('Geolocation is not supported by this browser.');
            }
        }
    }
    acceptLocation() {
        if (this.isLocalStorageAvailable()) {
            sessionStorage.setItem(this.COORDINATE_PARTIAL + globalThis.location.href.split('?')[0], "1");
        }
        else {
            alert('Error: Location sharing not enabled in private browsing');
        }
    }
    sortLocationDynamic(selection) {
        let selectionValue = "";
        if (selection.nodeName.toLowerCase() === "option") {
            // @ts-ignore
            selectionValue = selection.value;
        }
        else {
            selectionValue = selection.dataset.value;
        }
        if (!this.isLocationProvided()) {
            // @ts-ignore
            jQuery('#geoFilterModal').modal('show');
            this.findCookieAndShowButton();
            const qs = selectionValue.match(/st=([^&]*)/g);
            if (qs) {
                this.swapOrInsertDistanceSort('hasLocation', qs[0]);
                this.swapOrInsertDistanceSort('getLocation', qs[0]);
                this.swapOrInsertDistanceSort('zipSearchModalBtn', qs[0]);
            }
        }
    }
    zipcodeSearchDynamic(event) {
        event.preventDefault();
        const zip = jQuery('#zipCodeModalTxt').val();
        if (StringHelpers.isNullOrWhitespace(zip) || this.isInvalidUSZip(zip)) {
            document.getElementById('zipCodeModalTxt').style.borderColor = 'red';
        }
        else {
            globalThis.DealeronCookie.setItem(this.ZIP_COOKIE, zip);
            this.setModalInteraction(this.MODAL_INTERACTION_ZIP);
            // i hate this
            const button = document.getElementById('dynamicZip');
            button.innerHTML = zip;
            button.click();
            // @ts-ignore
            jQuery('#geoFilterModal').modal('hide');
        }
    }
    // --------------  Private helper methods --------------
    // create cookie and querystring with location
    createCoordinateCookie(position) {
        const querystring = position.coords.latitude.toFixed(3) + '|' + position.coords.longitude.toFixed(3);
        if (this.isLocalStorageAvailable()) {
            // Use a normalized path ('/') to ensure subsequent retrieval works across environments
            globalThis.DealeronCookie.setItem(this.COORDINATE_COOKIE, querystring, null, '/');
            this.setModalInteraction(this.MODAL_INTERACTION_COORDINATE);
            this.loadWithCoordinate(querystring);
        }
        else {
            alert('Error: Location sharing not enabled in private browsing');
        }
    }
    // show correct button, append query string values setup to button values
    findCookieAndShowButton() {
        const url = globalThis.location.href;
        if (!url.includes('ZipCode')) {
            if (url.includes('?')) {
                jQuery('#zipSearchModalBtn').val(url + '&ZipCode=');
            }
            else {
                jQuery('#zipSearchModalBtn').val(url + '?ZipCode=');
            }
        }
        if (url.includes('?')) {
            jQuery('#getLocation').val(url + '&currentlocation=');
        }
        else {
            jQuery('#getLocation').val(url + '?currentlocation=');
        }
    }
    isLocalStorageAvailable() {
        try {
            sessionStorage.setItem('testKey', '1');
            sessionStorage.removeItem('testKey');
            return true;
        }
        catch (error) {
            alert('Error: session storage not available');
            return false;
        }
    }
    isInvalidUSZip(zip) {
        return !/(^\d{5}$)|(^\d{5}-\d{4}$)/.test(zip);
    }
    isLocationProvided() {
        const coord = globalThis.DealeronCookie.getItem(this.COORDINATE_COOKIE);
        const zip = globalThis.DealeronCookie.getItem(this.ZIP_COOKIE);
        return !!coord || !!zip;
    }
    loadWithCoordinate(querystring) {
        sessionStorage.setItem(this.COORDINATE_PARTIAL + globalThis.location.href.split('?')[0], "1");
        globalThis.location.href = jQuery('#getLocation').val().replace('currentlocation=', 'currentlocation=' + this.trimLatLongCoordinate(querystring));
    }
    setModalInteraction(type) {
        // Persist interaction for all recognized modal interaction states:
        //  - coordinate: user shared geolocation
        //  - zip: user provided a zip code
        //  - closed: user explicitly dismissed without providing location
        // Storing 'closed' lets us suppress automatic re-opening while still
        // allowing an explicit distance sort selection to re-trigger the modal.
        if ([
            this.MODAL_INTERACTION_COORDINATE,
            this.MODAL_INTERACTION_ZIP,
            this.MODAL_INTERACTION_CLOSED
        ].includes(type)) {
            globalThis.DealeronCookie.setItem(this.MODAL_INTERACTION_COOKIE, type, null, '/');
        }
    }
    setupModalEventListeners() {
        $('#geoFilterModal').on('hidden.bs.modal', (e) => {
            const used = globalThis.DealeronCookie.getItem(this.MODAL_INTERACTION_COOKIE);
            if ((used != this.MODAL_INTERACTION_COORDINATE) && (used != this.MODAL_INTERACTION_ZIP)) {
                this.setModalInteraction(this.MODAL_INTERACTION_CLOSED);
            }
        });
    }
    shouldShowGeoModalOnLoad(defaultSortOrder) {
        var _a, _b, _c;
        const url = globalThis.location.href;
        const normalizedDefault = (_a = defaultSortOrder === null || defaultSortOrder === void 0 ? void 0 : defaultSortOrder.toLowerCase()) !== null && _a !== void 0 ? _a : '';
        let params;
        try {
            params = new URL(url).searchParams;
        }
        catch (_d) {
            // Fallback: create params from substring after '?'
            const query = (_b = url.split('?')[1]) !== null && _b !== void 0 ? _b : '';
            params = new URLSearchParams(query);
        }
        const st = (_c = params.get('st')) === null || _c === void 0 ? void 0 : _c.toLowerCase();
        const isSortByDistance = st ? st.startsWith('distance') : normalizedDefault.includes('distance');
        // Presence of location indicators in query string
        const hasCoordInUrl = params.has('currentlocation');
        // Accept both ZipCode and zipcode variants
        const hasZipInUrl = params.has('ZipCode') || params.has('zipcode');
        const hasLocationInUrl = hasCoordInUrl || hasZipInUrl;
        // Stored location (cookie) only reflects actual coordinate or zip
        const hasStoredLocation = this.isLocationProvided();
        // If user previously closed the modal without supplying location, suppress auto-display.
        const interaction = globalThis.DealeronCookie.getItem(this.MODAL_INTERACTION_COOKIE);
        const userPreviouslyClosed = interaction === this.MODAL_INTERACTION_CLOSED;
        if (userPreviouslyClosed) {
            return false;
        }
        // Show modal only if sorting by distance and neither URL nor stored location present
        return isSortByDistance && !hasLocationInUrl && !hasStoredLocation;
    }
    swapOrInsertDistanceSort(id, distanceFilter) {
        var _a;
        let previous = (_a = jQuery('#' + id).val()) !== null && _a !== void 0 ? _a : '';
        if (/([?&])st=([^&]*)/i.test(previous)) {
            previous = previous
                .replace(/&st=([^&]*)/gi, `&${distanceFilter}`)
                .replace(/\?st=([^&]*)/gi, `?${distanceFilter}`);
        }
        else {
            // Append with correct delimiter logic
            const delimiter = previous.includes('?') ? '&' : (previous.length > 0 ? (previous.endsWith('&') ? '' : '&') : '');
            previous = previous + delimiter + distanceFilter;
        }
        jQuery('#' + id).val(previous);
    }
    trimLatLongCoordinate(location) {
        const latLong = location.split('|');
        return Number.parseFloat(latLong[0]).toFixed(3) + '|' + Number.parseFloat(latLong[1]).toFixed(3);
    }
};
LocationSortModalService = locationSortModalService_decorate([
    (0,inversify/* injectable */._G)()
], LocationSortModalService);


;// ./src/services/navbarSearch/navbarSearchService.ts
var navbarSearchService_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var navbarSearchService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


let NavbarSearchService = class NavbarSearchService {
    constructor() {
        this.rootApiUrl = "/api/vhcliaa";
        this.getNavigationBarSearchApiUrl = (dealerId) => {
            var _a, _b;
            const searchParams = serviceHelpers/* ServiceHelpers */.d.getBaseApiQueryString(null, null);
            const origin = (_b = (_a = globalThis.location) === null || _a === void 0 ? void 0 : _a.origin) !== null && _b !== void 0 ? _b : "";
            return `${this.rootApiUrl}/navbar-search/${dealerId}?${serviceHelpers/* ServiceHelpers */.d.mapArrayToQueryString(searchParams)}&host=${origin}`;
        };
    }
    getNavbarSearchSuggestions(dealerId) {
        return navbarSearchService_awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(this.getNavigationBarSearchApiUrl(dealerId));
            if (!response.ok) {
                const text = yield response.text();
                throw new Error(`Failed to fetch navbar search data: ${response.status} ${text}`);
            }
            const data = yield response.json();
            if (!Array.isArray(data) || !data.every((x) => typeof x === "string")) {
                throw new Error("Invalid navbar search suggestions format");
            }
            return data;
        });
    }
    redirectToSearchPage(searchRoute, query) {
        if (!(query === null || query === void 0 ? void 0 : query.trim()) || !searchRoute) {
            return;
        }
        const encodedQuery = encodeURIComponent(query).replace(/%20/g, " ");
        globalThis.location.href = `${searchRoute}?q=${encodedQuery}`;
    }
};
NavbarSearchService = navbarSearchService_decorate([
    (0,inversify/* injectable */._G)()
], NavbarSearchService);


;// ./src/inversify.config.ts

























const doIocContainer = new inversify/* Container */.mc();
doIocContainer.bind(types/* TYPES */.Q.IToggleFetcher).to(toggleFetcher/* ToggleFetcher */.I).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.ITranslationFetcher).to(defaultTranslationFetcher/* TranslationFetcher */.$).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IFilterPanel).to(FilterPanel).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IInventoryWasabi).to(InventoryWasabi);
doIocContainer.bind(types/* TYPES */.Q.IWasabiFilterState).to(WasabiFilterState).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IFilterState).to(FilterState).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.SrpWasabiGeneral).to(srpWasabi_General/* SrpWasabiGeneral */.d).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.VehicleCardWasabi).to(vehicleCardWasabi/* VehicleCardWasabi */.a).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.RangeFilterCosmos).to(RangeFilterCosmos).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IVehicleService).to(vehicleService/* VehicleService */.K).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IFilterService).to(FilterService).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IPriceStakSynchronizer).to(PriceStakSynchronizer).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.ShareVehicleModel).to(shareVehicleModal/* ShareVehicleModal */.H).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.EvnVideoPlayer).to(evnVideoPlayer/* EvnVideoPlayer */.U).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IToggleService).to(toggles_toggleService/* ToggleService */.gH).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.ITranslationService).to(translationService/* TranslationService */.L).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IOemVehicleStatusService).to(OemVehicleStatusService).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IPersonalizationService).to(PersonalizationService).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.IStoreProvider).to(StoreProvider).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.VehiclePricestakDisclaimerModal).to(vehiclePricestakDisclaimerModal/* VehiclePricestakDisclaimerModal */.F).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.TdgConfirmAndContactButtons).to(tdgConfirmAndContactButtons/* TdgConfirmAndContactButtons */.Y).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.ILocationSortModalService).to(LocationSortModalService).inSingletonScope();
doIocContainer.bind(types/* TYPES */.Q.INavbarSearchService).to(NavbarSearchService).inSingletonScope();



/***/ }),

/***/ 16611:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ SrpPageSettingsModel),
/* harmony export */   K: () => (/* binding */ SrpFilterType)
/* harmony export */ });
class SrpPageSettingsModel {
}
var SrpFilterType;
(function (SrpFilterType) {
    SrpFilterType[SrpFilterType["Dynamic"] = 0] = "Dynamic";
    SrpFilterType[SrpFilterType["Applied"] = 1] = "Applied";
})(SrpFilterType || (SrpFilterType = {}));


/***/ }),

/***/ 17090:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ ServiceHelpers)
/* harmony export */ });
/* harmony import */ var _components_spaCosmos_pagination_pagingModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81719);
/* harmony import */ var _utilities_urlHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7324);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;


class ServiceHelpers {
    static mapArrayToQueryString(searchParams) {
        return searchParams.map(param => {
            switch (param.key) {
                // Base64 encode any dql query parameters
                case "dql":
                    return `${param.key}=${btoa(param.value).replace(/\+/g, "%2B")}`;
                default:
                    // Use default behavior for other keys
                    return `${param.key}=${param.value}`;
            }
        }).join('&');
    }
}
_a = ServiceHelpers;
ServiceHelpers.sendApiRequest = (url) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const response = yield fetch(url);
        if (response.ok) {
            const responseText = yield response.text();
            try {
                const responseData = JSON.parse(responseText);
                return responseData;
            }
            catch (error) {
                console.error(new Error(`Error parsing JSON data from endpoint ${url}: ${error.message}
            \n\nData that failed JSON-parsing:\n\n${responseText}`));
            }
        }
        else {
            throw new Error(`Error: ${response.status} for endpoint ${url}`);
        }
    }
    catch (error) {
        console.error(new Error(`Error fetching data from ${url}: ${error.message}`));
    }
});
//HACK: we can't use the built in URLSearchParams because we let dealers use unsafe querystring params
ServiceHelpers.getBaseApiQueryString = (paginationData = null, dynamicCountsSearch = null) => {
    var _b, _c, _d, _e;
    var search = dynamicCountsSearch ? dynamicCountsSearch : window.location.search;
    const searchParams = _utilities_urlHelpers__WEBPACK_IMPORTED_MODULE_1__/* .UrlHelpers */ .b.queryStringToArray(search);
    searchParams.push({ "key": "host", "value": window.location.host });
    const pageNumber = (_c = (_b = searchParams.find(param => param.key === _components_spaCosmos_pagination_pagingModel__WEBPACK_IMPORTED_MODULE_0__/* .PaginationQueryParams */ .p.PageNumber)) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : paginationData === null || paginationData === void 0 ? void 0 : paginationData.PageNumber;
    // don't put the pt param if it's the first page
    if (pageNumber && pageNumber > 1) {
        _a.setSearchParam(_components_spaCosmos_pagination_pagingModel__WEBPACK_IMPORTED_MODULE_0__/* .PaginationQueryParams */ .p.PageNumber, +pageNumber, searchParams);
    }
    const pageSize = (_e = (_d = searchParams.find(param => param.key === _components_spaCosmos_pagination_pagingModel__WEBPACK_IMPORTED_MODULE_0__/* .PaginationQueryParams */ .p.PageSize)) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : paginationData === null || paginationData === void 0 ? void 0 : paginationData.PageSize;
    // TODO: don't put the pn param if it's the default value
    if (pageSize && pageSize > 0) {
        _a.setSearchParam(_components_spaCosmos_pagination_pagingModel__WEBPACK_IMPORTED_MODULE_0__/* .PaginationQueryParams */ .p.PageSize, +pageSize, searchParams);
    }
    return searchParams;
};
ServiceHelpers.setSearchParam = (paramName, paramValue, searchParams) => {
    const existingParam = searchParams.find(param => param.key === paramName);
    if (paramValue !== '' && paramValue !== null && paramValue !== undefined) {
        const btoaFilters = ["dql"];
        if (btoaFilters.includes(paramName)) {
            paramValue = btoa(paramValue).replace(/\+/g, "%2B");
        }
        //if the paramName already exists, update it
        if (existingParam) {
            searchParams[searchParams.indexOf(existingParam)].value = paramValue;
        }
        else {
            //otherwise add it
            searchParams.push({ "key": paramName, "value": paramValue });
        }
    }
    else {
        //remove the param if it exists and the value is null or empty string
        if (existingParam && (paramValue === '' || paramValue === null || paramValue === undefined)) {
            searchParams.splice(searchParams.indexOf(existingParam), 1);
        }
    }
};


/***/ }),

/***/ 17590:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.named = void 0;
var METADATA_KEY = __webpack_require__(94725);
var metadata_1 = __webpack_require__(88390);
var decorator_utils_1 = __webpack_require__(50040);
function named(name) {
  return function (target, targetKey, index) {
    var metadata = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, name);
    if (typeof index === "number") {
      decorator_utils_1.tagParameter(target, targetKey, index, metadata);
    } else {
      decorator_utils_1.tagProperty(target, targetKey, metadata);
    }
  };
}
exports.named = named;

/***/ }),

/***/ 18156:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.resolve = void 0;
var ERROR_MSGS = __webpack_require__(27718);
var literal_types_1 = __webpack_require__(27802);
var exceptions_1 = __webpack_require__(98229);
var serialization_1 = __webpack_require__(57911);
var instantiation_1 = __webpack_require__(43553);
var invokeFactory = function (factoryType, serviceIdentifier, fn) {
  try {
    return fn();
  } catch (error) {
    if (exceptions_1.isStackOverflowExeption(error)) {
      throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryType, serviceIdentifier.toString()));
    } else {
      throw error;
    }
  }
};
var _resolveRequest = function (requestScope) {
  return function (request) {
    request.parentContext.setCurrentRequest(request);
    var bindings = request.bindings;
    var childRequests = request.childRequests;
    var targetIsAnArray = request.target && request.target.isArray();
    var targetParentIsNotAnArray = !request.parentRequest || !request.parentRequest.target || !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
    if (targetIsAnArray && targetParentIsNotAnArray) {
      return childRequests.map(function (childRequest) {
        var _f = _resolveRequest(requestScope);
        return _f(childRequest);
      });
    } else {
      var result = null;
      if (request.target.isOptional() && bindings.length === 0) {
        return undefined;
      }
      var binding_1 = bindings[0];
      var isSingleton = binding_1.scope === literal_types_1.BindingScopeEnum.Singleton;
      var isRequestSingleton = binding_1.scope === literal_types_1.BindingScopeEnum.Request;
      if (isSingleton && binding_1.activated) {
        return binding_1.cache;
      }
      if (isRequestSingleton && requestScope !== null && requestScope.has(binding_1.id)) {
        return requestScope.get(binding_1.id);
      }
      if (binding_1.type === literal_types_1.BindingTypeEnum.ConstantValue) {
        result = binding_1.cache;
      } else if (binding_1.type === literal_types_1.BindingTypeEnum.Function) {
        result = binding_1.cache;
      } else if (binding_1.type === literal_types_1.BindingTypeEnum.Constructor) {
        result = binding_1.implementationType;
      } else if (binding_1.type === literal_types_1.BindingTypeEnum.DynamicValue && binding_1.dynamicValue !== null) {
        result = invokeFactory("toDynamicValue", binding_1.serviceIdentifier, function () {
          return binding_1.dynamicValue(request.parentContext);
        });
      } else if (binding_1.type === literal_types_1.BindingTypeEnum.Factory && binding_1.factory !== null) {
        result = invokeFactory("toFactory", binding_1.serviceIdentifier, function () {
          return binding_1.factory(request.parentContext);
        });
      } else if (binding_1.type === literal_types_1.BindingTypeEnum.Provider && binding_1.provider !== null) {
        result = invokeFactory("toProvider", binding_1.serviceIdentifier, function () {
          return binding_1.provider(request.parentContext);
        });
      } else if (binding_1.type === literal_types_1.BindingTypeEnum.Instance && binding_1.implementationType !== null) {
        result = instantiation_1.resolveInstance(binding_1.implementationType, childRequests, _resolveRequest(requestScope));
      } else {
        var serviceIdentifier = serialization_1.getServiceIdentifierAsString(request.serviceIdentifier);
        throw new Error(ERROR_MSGS.INVALID_BINDING_TYPE + " " + serviceIdentifier);
      }
      if (typeof binding_1.onActivation === "function") {
        result = binding_1.onActivation(request.parentContext, result);
      }
      if (isSingleton) {
        binding_1.cache = result;
        binding_1.activated = true;
      }
      if (isRequestSingleton && requestScope !== null && !requestScope.has(binding_1.id)) {
        requestScope.set(binding_1.id, result);
      }
      return result;
    }
  };
};
function resolve(context) {
  var _f = _resolveRequest(context.plan.rootRequest.requestScope);
  return _f(context.plan.rootRequest);
}
exports.resolve = resolve;

/***/ }),

/***/ 18370:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.injectable = void 0;
var ERRORS_MSGS = __webpack_require__(27718);
var METADATA_KEY = __webpack_require__(94725);
function injectable() {
  return function (target) {
    if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {
      throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);
    }
    var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];
    Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);
    return target;
  };
}
exports.injectable = injectable;

/***/ }),

/***/ 23249:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ VehicleLoadCause)
/* harmony export */ });
var VehicleLoadCause;
(function (VehicleLoadCause) {
    VehicleLoadCause[VehicleLoadCause["Unknown"] = 0] = "Unknown";
    VehicleLoadCause[VehicleLoadCause["InfiniteScroll"] = 1] = "InfiniteScroll";
    VehicleLoadCause[VehicleLoadCause["SetPageSize"] = 2] = "SetPageSize";
    VehicleLoadCause[VehicleLoadCause["SetPageNumber"] = 3] = "SetPageNumber";
})(VehicleLoadCause || (VehicleLoadCause = {}));


/***/ }),

/***/ 23277:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ UiLocationVersion)
/* harmony export */ });
//NOTE: This MUST lineup with the EnumUiLocationVersion.cs in the backend. We compare backend int to the int here!
var UiLocationVersion;
(function (UiLocationVersion) {
    UiLocationVersion[UiLocationVersion["SrpWasabi"] = 1] = "SrpWasabi";
    UiLocationVersion[UiLocationVersion["VdpHoisin"] = 3] = "VdpHoisin";
    UiLocationVersion[UiLocationVersion["VehicleCardDeck"] = 8] = "VehicleCardDeck";
})(UiLocationVersion || (UiLocationVersion = {}));


/***/ }),

/***/ 23415:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.unmanaged = void 0;
var METADATA_KEY = __webpack_require__(94725);
var metadata_1 = __webpack_require__(88390);
var decorator_utils_1 = __webpack_require__(50040);
function unmanaged() {
  return function (target, targetKey, index) {
    var metadata = new metadata_1.Metadata(METADATA_KEY.UNMANAGED_TAG, true);
    decorator_utils_1.tagParameter(target, targetKey, index, metadata);
  };
}
exports.unmanaged = unmanaged;

/***/ }),

/***/ 23568:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $u: () => (/* binding */ ld),
/* harmony export */   C4: () => (/* binding */ es),
/* harmony export */   CE: () => (/* binding */ it),
/* harmony export */   EW: () => (/* binding */ ij),
/* harmony export */   Ef: () => (/* binding */ of),
/* harmony export */   FK: () => (/* binding */ r0),
/* harmony export */   Fv: () => (/* binding */ ig),
/* harmony export */   IG: () => (/* binding */ tC),
/* harmony export */   KC: () => (/* binding */ lc),
/* harmony export */   KR: () => (/* binding */ tk),
/* harmony export */   Kh: () => (/* binding */ tp),
/* harmony export */   Lk: () => (/* binding */ iu),
/* harmony export */   PS: () => (/* binding */ rl),
/* harmony export */   Q3: () => (/* binding */ iv),
/* harmony export */   QW: () => (/* binding */ tF),
/* harmony export */   R1: () => (/* binding */ tO),
/* harmony export */   Tr: () => (/* binding */ en),
/* harmony export */   WQ: () => (/* binding */ rn),
/* harmony export */   Wv: () => (/* binding */ il),
/* harmony export */   aG: () => (/* binding */ sh),
/* harmony export */   bF: () => (/* binding */ ic),
/* harmony export */   bo: () => (/* binding */ np),
/* harmony export */   dY: () => (/* binding */ t9),
/* harmony export */   eB: () => (/* binding */ i7),
/* harmony export */   eW: () => (/* binding */ ih),
/* harmony export */   g8: () => (/* binding */ tm),
/* harmony export */   hi: () => (/* binding */ lg),
/* harmony export */   i9: () => (/* binding */ tw),
/* harmony export */   jR: () => (/* binding */ oi),
/* harmony export */   jr: () => (/* binding */ e_),
/* harmony export */   k6: () => (/* binding */ nf),
/* harmony export */   o5: () => (/* binding */ em),
/* harmony export */   pI: () => (/* binding */ lT),
/* harmony export */   pM: () => (/* binding */ nj),
/* harmony export */   sV: () => (/* binding */ lf),
/* harmony export */   uX: () => (/* binding */ r3),
/* harmony export */   uY: () => (/* binding */ ev),
/* harmony export */   ux: () => (/* binding */ tS),
/* harmony export */   v_: () => (/* binding */ ep),
/* harmony export */   wB: () => (/* binding */ rM)
/* harmony export */ });
/* unused harmony exports BaseTransition, BaseTransitionPropsValidators, Comment, DeprecationTypes, EffectScope, ErrorCodes, ErrorTypeStrings, KeepAlive, ReactiveEffect, Static, Suspense, Teleport, Text, TrackOpTypes, TransitionGroup, TriggerOpTypes, VueElement, assertNumber, callWithAsyncErrorHandling, callWithErrorHandling, camelize, capitalize, cloneVNode, compatUtils, compile, createHydrationRenderer, createPropsRestProxy, createRenderer, createSSRApp, createSlots, customRef, defineAsyncComponent, defineCustomElement, defineEmits, defineExpose, defineModel, defineOptions, defineProps, defineSSRCustomElement, defineSlots, devtools, effect, getCurrentInstance, getCurrentWatcher, getTransitionRawChildren, guardReactiveProps, h, handleError, hydrate, hydrateOnIdle, hydrateOnInteraction, hydrateOnMediaQuery, hydrateOnVisible, initCustomFormatter, initDirectivesForSSR, isMemoSame, isProxy, isReadonly, isRuntimeOnly, isShallow, isVNode, mergeDefaults, mergeModels, mergeProps, normalizeProps, onActivated, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onRenderTracked, onRenderTriggered, onServerPrefetch, onWatcherCleanup, popScopeId, provide, proxyRefs, pushScopeId, queuePostFlushCb, readonly, registerRuntimeCompiler, render, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveFilter, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, shallowReactive, shallowReadonly, shallowRef, ssrContextKey, ssrUtils, stop, toHandlerKey, toHandlers, toRef, toValue, transformVNodeArgs, triggerRef, useAttrs, useCssModule, useCssVars, useHost, useId, useModel, useSSRContext, useShadowRoot, useSlots, useTemplateRef, useTransitionState, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, version, warn, watchEffect, watchPostEffect, watchSyncEffect, withAsyncContext, withDefaults, withMemo, withModifiers, withScopeId */
/**
* vue v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/var e, t;
let n, l, r, i, s, o, a, u, c, f, p, d;
function h(e) {
  let t = Object.create(null);
  for (let n of e.split(",")) t[n] = 1;
  return e => e in t;
}
let g = {},
  m = [],
  _ = () => {},
  y = () => !1,
  b = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && (e.charCodeAt(2) > 122 || 97 > e.charCodeAt(2)),
  S = e => e.startsWith("onUpdate:"),
  C = Object.assign,
  x = (e, t) => {
    let n = e.indexOf(t);
    n > -1 && e.splice(n, 1);
  },
  E = Object.prototype.hasOwnProperty,
  w = (e, t) => E.call(e, t),
  k = Array.isArray,
  T = e => "[object Map]" === F(e),
  A = e => "[object Set]" === F(e),
  R = e => "[object Date]" === F(e),
  N = e => "[object RegExp]" === F(e),
  O = e => "function" == typeof e,
  P = e => "string" == typeof e,
  M = e => "symbol" == typeof e,
  I = e => null !== e && "object" == typeof e,
  L = e => (I(e) || O(e)) && O(e.then) && O(e.catch),
  D = Object.prototype.toString,
  F = e => D.call(e),
  V = e => F(e).slice(8, -1),
  U = e => "[object Object]" === F(e),
  j = e => P(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e,
  B = h(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
  $ = e => {
    let t = Object.create(null);
    return n => t[n] || (t[n] = e(n));
  },
  H = /-(\w)/g,
  W = $(e => e.replace(H, (e, t) => t ? t.toUpperCase() : "")),
  K = /\B([A-Z])/g,
  z = $(e => e.replace(K, "-$1").toLowerCase()),
  q = $(e => e.charAt(0).toUpperCase() + e.slice(1)),
  G = $(e => e ? `on${q(e)}` : ""),
  J = (e, t) => !Object.is(e, t),
  X = (e, ...t) => {
    for (let n = 0; n < e.length; n++) e[n](...t);
  },
  Z = (e, t, n, l = !1) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      writable: l,
      value: n
    });
  },
  Y = e => {
    let t = parseFloat(e);
    return isNaN(t) ? e : t;
  },
  Q = e => {
    let t = P(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t;
  },
  ee = () => n || (n = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : {}),
  et = h("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol");
function en(e) {
  if (k(e)) {
    let t = {};
    for (let n = 0; n < e.length; n++) {
      let l = e[n],
        r = P(l) ? function (e) {
          let t = {};
          return e.replace(ei, "").split(el).forEach(e => {
            if (e) {
              let n = e.split(er);
              n.length > 1 && (t[n[0].trim()] = n[1].trim());
            }
          }), t;
        }(l) : en(l);
      if (r) for (let e in r) t[e] = r[e];
    }
    return t;
  }
  if (P(e) || I(e)) return e;
}
let el = /;(?![^(]*\))/g,
  er = /:([^]+)/,
  ei = /\/\*[^]*?\*\//g;
function es(e) {
  let t = "";
  if (P(e)) t = e;else if (k(e)) for (let n = 0; n < e.length; n++) {
    let l = es(e[n]);
    l && (t += l + " ");
  } else if (I(e)) for (let n in e) e[n] && (t += n + " ");
  return t.trim();
}
function eo(e) {
  if (!e) return null;
  let {
    class: t,
    style: n
  } = e;
  return t && !P(t) && (e.class = es(t)), n && (e.style = en(n)), e;
}
let ea = h("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");
function eu(e, t) {
  if (e === t) return !0;
  let n = R(e),
    l = R(t);
  if (n || l) return !!n && !!l && e.getTime() === t.getTime();
  if (n = M(e), l = M(t), n || l) return e === t;
  if (n = k(e), l = k(t), n || l) return !!n && !!l && function (e, t) {
    if (e.length !== t.length) return !1;
    let n = !0;
    for (let l = 0; n && l < e.length; l++) n = eu(e[l], t[l]);
    return n;
  }(e, t);
  if (n = I(e), l = I(t), n || l) {
    if (!n || !l || Object.keys(e).length !== Object.keys(t).length) return !1;
    for (let n in e) {
      let l = e.hasOwnProperty(n),
        r = t.hasOwnProperty(n);
      if (l && !r || !l && r || !eu(e[n], t[n])) return !1;
    }
  }
  return String(e) === String(t);
}
function ec(e, t) {
  return e.findIndex(e => eu(e, t));
}
let ef = e => !!(e && !0 === e.__v_isRef),
  ep = e => P(e) ? e : null == e ? "" : k(e) || I(e) && (e.toString === D || !O(e.toString)) ? ef(e) ? ep(e.value) : JSON.stringify(e, ed, 2) : String(e),
  ed = (e, t) => ef(t) ? ed(e, t.value) : T(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce((e, [t, n], l) => (e[eh(t, l) + " =>"] = n, e), {})
  } : A(t) ? {
    [`Set(${t.size})`]: [...t.values()].map(e => eh(e))
  } : M(t) ? eh(t) : !I(t) || k(t) || U(t) ? t : String(t),
  eh = (e, t = "") => {
    var n;
    return M(e) ? `Symbol(${null != (n = e.description) ? n : t})` : e;
  };
class eg {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = l, !e && l && (this.index = (l.scopes || (l.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      let e, t;
      if (this._isPaused = !0, this.scopes) for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].pause();
      for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].pause();
    }
  }
  resume() {
    if (this._active && this._isPaused) {
      let e, t;
      if (this._isPaused = !1, this.scopes) for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].resume();
      for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      let t = l;
      try {
        return l = this, e();
      } finally {
        l = t;
      }
    }
  }
  on() {
    l = this;
  }
  off() {
    l = this.parent;
  }
  stop(e) {
    if (this._active) {
      let t, n;
      for (t = 0, this._active = !1, n = this.effects.length; t < n; t++) this.effects[t].stop();
      for (t = 0, this.effects.length = 0, n = this.cleanups.length; t < n; t++) this.cleanups[t]();
      if (this.cleanups.length = 0, this.scopes) {
        for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        let e = this.parent.scopes.pop();
        e && e !== this && (this.parent.scopes[this.index] = e, e.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function ev(e) {
  return new eg(e);
}
function em() {
  return l;
}
function e_(e, t = !1) {
  l && l.cleanups.push(e);
}
let ey = new WeakSet();
class eb {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, l && l.active && l.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    64 & this.flags && (this.flags &= -65, ey.has(this) && (ey.delete(this), this.trigger()));
  }
  notify() {
    (!(2 & this.flags) || 32 & this.flags) && (8 & this.flags || eC(this));
  }
  run() {
    if (!(1 & this.flags)) return this.fn();
    this.flags |= 2, eL(this), eE(this);
    let e = r,
      t = eO;
    r = this, eO = !0;
    try {
      return this.fn();
    } finally {
      ew(this), r = e, eO = t, this.flags &= -3;
    }
  }
  stop() {
    if (1 & this.flags) {
      for (let e = this.deps; e; e = e.nextDep) eA(e);
      this.deps = this.depsTail = void 0, eL(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    64 & this.flags ? ey.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  runIfDirty() {
    ek(this) && this.run();
  }
  get dirty() {
    return ek(this);
  }
}
let eS = 0;
function eC(e, t = !1) {
  if (e.flags |= 8, t) {
    e.next = s, s = e;
    return;
  }
  e.next = i, i = e;
}
function ex() {
  let e;
  if (!(--eS > 0)) {
    if (s) {
      let e = s;
      for (s = void 0; e;) {
        let t = e.next;
        e.next = void 0, e.flags &= -9, e = t;
      }
    }
    for (; i;) {
      let t = i;
      for (i = void 0; t;) {
        let n = t.next;
        if (t.next = void 0, t.flags &= -9, 1 & t.flags) try {
          t.trigger();
        } catch (t) {
          e || (e = t);
        }
        t = n;
      }
    }
    if (e) throw e;
  }
}
function eE(e) {
  for (let t = e.deps; t; t = t.nextDep) t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function ew(e) {
  let t;
  let n = e.depsTail,
    l = n;
  for (; l;) {
    let e = l.prevDep;
    -1 === l.version ? (l === n && (n = e), eA(l), function (e) {
      let {
        prevDep: t,
        nextDep: n
      } = e;
      t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0);
    }(l)) : t = l, l.dep.activeLink = l.prevActiveLink, l.prevActiveLink = void 0, l = e;
  }
  e.deps = t, e.depsTail = n;
}
function ek(e) {
  for (let t = e.deps; t; t = t.nextDep) if (t.dep.version !== t.version || t.dep.computed && (eT(t.dep.computed) || t.dep.version !== t.version)) return !0;
  return !!e._dirty;
}
function eT(e) {
  if (4 & e.flags && !(16 & e.flags) || (e.flags &= -17, e.globalVersion === eD)) return;
  e.globalVersion = eD;
  let t = e.dep;
  if (e.flags |= 2, t.version > 0 && !e.isSSR && e.deps && !ek(e)) {
    e.flags &= -3;
    return;
  }
  let n = r,
    l = eO;
  r = e, eO = !0;
  try {
    eE(e);
    let n = e.fn(e._value);
    (0 === t.version || J(n, e._value)) && (e._value = n, t.version++);
  } catch (e) {
    throw t.version++, e;
  } finally {
    r = n, eO = l, ew(e), e.flags &= -3;
  }
}
function eA(e, t = !1) {
  let {
    dep: n,
    prevSub: l,
    nextSub: r
  } = e;
  if (l && (l.nextSub = r, e.prevSub = void 0), r && (r.prevSub = l, e.nextSub = void 0), n.subs === e && (n.subs = l, !l && n.computed)) {
    n.computed.flags &= -5;
    for (let e = n.computed.deps; e; e = e.nextDep) eA(e, !0);
  }
  t || --n.sc || !n.map || n.map.delete(n.key);
}
function eR(e, t) {
  e.effect instanceof eb && (e = e.effect.fn);
  let n = new eb(e);
  t && C(n, t);
  try {
    n.run();
  } catch (e) {
    throw n.stop(), e;
  }
  let l = n.run.bind(n);
  return l.effect = n, l;
}
function eN(e) {
  e.effect.stop();
}
let eO = !0,
  eP = [];
function eM() {
  eP.push(eO), eO = !1;
}
function eI() {
  let e = eP.pop();
  eO = void 0 === e || e;
}
function eL(e) {
  let {
    cleanup: t
  } = e;
  if (e.cleanup = void 0, t) {
    let e = r;
    r = void 0;
    try {
      t();
    } finally {
      r = e;
    }
  }
}
let eD = 0;
class eF {
  constructor(e, t) {
    this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class eV {
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0;
  }
  track(e) {
    if (!r || !eO || r === this.computed) return;
    let t = this.activeLink;
    if (void 0 === t || t.sub !== r) t = this.activeLink = new eF(r, this), r.deps ? (t.prevDep = r.depsTail, r.depsTail.nextDep = t, r.depsTail = t) : r.deps = r.depsTail = t, function e(t) {
      if (t.dep.sc++, 4 & t.sub.flags) {
        let n = t.dep.computed;
        if (n && !t.dep.subs) {
          n.flags |= 20;
          for (let t = n.deps; t; t = t.nextDep) e(t);
        }
        let l = t.dep.subs;
        l !== t && (t.prevSub = l, l && (l.nextSub = t)), t.dep.subs = t;
      }
    }(t);else if (-1 === t.version && (t.version = this.version, t.nextDep)) {
      let e = t.nextDep;
      e.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = e), t.prevDep = r.depsTail, t.nextDep = void 0, r.depsTail.nextDep = t, r.depsTail = t, r.deps === t && (r.deps = e);
    }
    return t;
  }
  trigger(e) {
    this.version++, eD++, this.notify(e);
  }
  notify(e) {
    eS++;
    try {
      for (let e = this.subs; e; e = e.prevSub) e.sub.notify() && e.sub.dep.notify();
    } finally {
      ex();
    }
  }
}
let eU = new WeakMap(),
  ej = Symbol(""),
  eB = Symbol(""),
  e$ = Symbol("");
function eH(e, t, n) {
  if (eO && r) {
    let t = eU.get(e);
    t || eU.set(e, t = new Map());
    let l = t.get(n);
    l || (t.set(n, l = new eV()), l.map = t, l.key = n), l.track();
  }
}
function eW(e, t, n, l, r, i) {
  let s = eU.get(e);
  if (!s) {
    eD++;
    return;
  }
  let o = e => {
    e && e.trigger();
  };
  if (eS++, "clear" === t) s.forEach(o);else {
    let r = k(e),
      i = r && j(n);
    if (r && "length" === n) {
      let e = Number(l);
      s.forEach((t, n) => {
        ("length" === n || n === e$ || !M(n) && n >= e) && o(t);
      });
    } else switch ((void 0 !== n || s.has(void 0)) && o(s.get(n)), i && o(s.get(e$)), t) {
      case "add":
        r ? i && o(s.get("length")) : (o(s.get(ej)), T(e) && o(s.get(eB)));
        break;
      case "delete":
        !r && (o(s.get(ej)), T(e) && o(s.get(eB)));
        break;
      case "set":
        T(e) && o(s.get(ej));
    }
  }
  ex();
}
function eK(e) {
  let t = tS(e);
  return t === e ? t : (eH(t, "iterate", e$), ty(e) ? t : t.map(tx));
}
function ez(e) {
  return eH(e = tS(e), "iterate", e$), e;
}
let eq = {
  __proto__: null,
  [Symbol.iterator]() {
    return eG(this, Symbol.iterator, tx);
  },
  concat(...e) {
    return eK(this).concat(...e.map(e => k(e) ? eK(e) : e));
  },
  entries() {
    return eG(this, "entries", e => (e[1] = tx(e[1]), e));
  },
  every(e, t) {
    return eX(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return eX(this, "filter", e, t, e => e.map(tx), arguments);
  },
  find(e, t) {
    return eX(this, "find", e, t, tx, arguments);
  },
  findIndex(e, t) {
    return eX(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return eX(this, "findLast", e, t, tx, arguments);
  },
  findLastIndex(e, t) {
    return eX(this, "findLastIndex", e, t, void 0, arguments);
  },
  forEach(e, t) {
    return eX(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return eY(this, "includes", e);
  },
  indexOf(...e) {
    return eY(this, "indexOf", e);
  },
  join(e) {
    return eK(this).join(e);
  },
  lastIndexOf(...e) {
    return eY(this, "lastIndexOf", e);
  },
  map(e, t) {
    return eX(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return eQ(this, "pop");
  },
  push(...e) {
    return eQ(this, "push", e);
  },
  reduce(e, ...t) {
    return eZ(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return eZ(this, "reduceRight", e, t);
  },
  shift() {
    return eQ(this, "shift");
  },
  some(e, t) {
    return eX(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return eQ(this, "splice", e);
  },
  toReversed() {
    return eK(this).toReversed();
  },
  toSorted(e) {
    return eK(this).toSorted(e);
  },
  toSpliced(...e) {
    return eK(this).toSpliced(...e);
  },
  unshift(...e) {
    return eQ(this, "unshift", e);
  },
  values() {
    return eG(this, "values", tx);
  }
};
function eG(e, t, n) {
  let l = ez(e),
    r = l[t]();
  return l === e || ty(e) || (r._next = r.next, r.next = () => {
    let e = r._next();
    return e.value && (e.value = n(e.value)), e;
  }), r;
}
let eJ = Array.prototype;
function eX(e, t, n, l, r, i) {
  let s = ez(e),
    o = s !== e && !ty(e),
    a = s[t];
  if (a !== eJ[t]) {
    let t = a.apply(e, i);
    return o ? tx(t) : t;
  }
  let u = n;
  s !== e && (o ? u = function (t, l) {
    return n.call(this, tx(t), l, e);
  } : n.length > 2 && (u = function (t, l) {
    return n.call(this, t, l, e);
  }));
  let c = a.call(s, u, l);
  return o && r ? r(c) : c;
}
function eZ(e, t, n, l) {
  let r = ez(e),
    i = n;
  return r !== e && (ty(e) ? n.length > 3 && (i = function (t, l, r) {
    return n.call(this, t, l, r, e);
  }) : i = function (t, l, r) {
    return n.call(this, t, tx(l), r, e);
  }), r[t](i, ...l);
}
function eY(e, t, n) {
  let l = tS(e);
  eH(l, "iterate", e$);
  let r = l[t](...n);
  return (-1 === r || !1 === r) && tb(n[0]) ? (n[0] = tS(n[0]), l[t](...n)) : r;
}
function eQ(e, t, n = []) {
  eM(), eS++;
  let l = tS(e)[t].apply(e, n);
  return ex(), eI(), l;
}
let e0 = h("__proto__,__v_isRef,__isVue"),
  e1 = new Set(Object.getOwnPropertyNames(Symbol).filter(e => "arguments" !== e && "caller" !== e).map(e => Symbol[e]).filter(M));
function e2(e) {
  M(e) || (e = String(e));
  let t = tS(this);
  return eH(t, "has", e), t.hasOwnProperty(e);
}
class e6 {
  constructor(e = !1, t = !1) {
    this._isReadonly = e, this._isShallow = t;
  }
  get(e, t, n) {
    if ("__v_skip" === t) return e.__v_skip;
    let l = this._isReadonly,
      r = this._isShallow;
    if ("__v_isReactive" === t) return !l;
    if ("__v_isReadonly" === t) return l;
    if ("__v_isShallow" === t) return r;
    if ("__v_raw" === t) return n === (l ? r ? tf : tc : r ? tu : ta).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
    let i = k(e);
    if (!l) {
      let e;
      if (i && (e = eq[t])) return e;
      if ("hasOwnProperty" === t) return e2;
    }
    let s = Reflect.get(e, t, tw(e) ? e : n);
    return (M(t) ? e1.has(t) : e0(t)) ? s : (l || eH(e, "get", t), r) ? s : tw(s) ? i && j(t) ? s : s.value : I(s) ? l ? th(s) : tp(s) : s;
  }
}
class e4 extends e6 {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, t, n, l) {
    let r = e[t];
    if (!this._isShallow) {
      let t = t_(r);
      if (ty(n) || t_(n) || (r = tS(r), n = tS(n)), !k(e) && tw(r) && !tw(n)) return !t && (r.value = n, !0);
    }
    let i = k(e) && j(t) ? Number(t) < e.length : w(e, t),
      s = Reflect.set(e, t, n, tw(e) ? e : l);
    return e === tS(l) && (i ? J(n, r) && eW(e, "set", t, n) : eW(e, "add", t, n)), s;
  }
  deleteProperty(e, t) {
    let n = w(e, t);
    e[t];
    let l = Reflect.deleteProperty(e, t);
    return l && n && eW(e, "delete", t, void 0), l;
  }
  has(e, t) {
    let n = Reflect.has(e, t);
    return M(t) && e1.has(t) || eH(e, "has", t), n;
  }
  ownKeys(e) {
    return eH(e, "iterate", k(e) ? "length" : ej), Reflect.ownKeys(e);
  }
}
class e8 extends e6 {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, t) {
    return !0;
  }
  deleteProperty(e, t) {
    return !0;
  }
}
let e3 = new e4(),
  e5 = new e8(),
  e9 = new e4(!0),
  e7 = new e8(!0),
  te = e => e,
  tt = e => Reflect.getPrototypeOf(e);
function tn(e) {
  return function (...t) {
    return "delete" !== e && ("clear" === e ? void 0 : this);
  };
}
function tl(e, t) {
  let n = function (e, t) {
    let n = {
      get(n) {
        let l = this.__v_raw,
          r = tS(l),
          i = tS(n);
        e || (J(n, i) && eH(r, "get", n), eH(r, "get", i));
        let {
            has: s
          } = tt(r),
          o = t ? te : e ? tE : tx;
        return s.call(r, n) ? o(l.get(n)) : s.call(r, i) ? o(l.get(i)) : void (l !== r && l.get(n));
      },
      get size() {
        let t = this.__v_raw;
        return e || eH(tS(t), "iterate", ej), Reflect.get(t, "size", t);
      },
      has(t) {
        let n = this.__v_raw,
          l = tS(n),
          r = tS(t);
        return e || (J(t, r) && eH(l, "has", t), eH(l, "has", r)), t === r ? n.has(t) : n.has(t) || n.has(r);
      },
      forEach(n, l) {
        let r = this,
          i = r.__v_raw,
          s = tS(i),
          o = t ? te : e ? tE : tx;
        return e || eH(s, "iterate", ej), i.forEach((e, t) => n.call(l, o(e), o(t), r));
      }
    };
    return C(n, e ? {
      add: tn("add"),
      set: tn("set"),
      delete: tn("delete"),
      clear: tn("clear")
    } : {
      add(e) {
        t || ty(e) || t_(e) || (e = tS(e));
        let n = tS(this);
        return tt(n).has.call(n, e) || (n.add(e), eW(n, "add", e, e)), this;
      },
      set(e, n) {
        t || ty(n) || t_(n) || (n = tS(n));
        let l = tS(this),
          {
            has: r,
            get: i
          } = tt(l),
          s = r.call(l, e);
        s || (e = tS(e), s = r.call(l, e));
        let o = i.call(l, e);
        return l.set(e, n), s ? J(n, o) && eW(l, "set", e, n) : eW(l, "add", e, n), this;
      },
      delete(e) {
        let t = tS(this),
          {
            has: n,
            get: l
          } = tt(t),
          r = n.call(t, e);
        r || (e = tS(e), r = n.call(t, e)), l && l.call(t, e);
        let i = t.delete(e);
        return r && eW(t, "delete", e, void 0), i;
      },
      clear() {
        let e = tS(this),
          t = 0 !== e.size,
          n = e.clear();
        return t && eW(e, "clear", void 0, void 0), n;
      }
    }), ["keys", "values", "entries", Symbol.iterator].forEach(l => {
      n[l] = function (...n) {
        let r = this.__v_raw,
          i = tS(r),
          s = T(i),
          o = "entries" === l || l === Symbol.iterator && s,
          a = r[l](...n),
          u = t ? te : e ? tE : tx;
        return e || eH(i, "iterate", "keys" === l && s ? eB : ej), {
          next() {
            let {
              value: e,
              done: t
            } = a.next();
            return t ? {
              value: e,
              done: t
            } : {
              value: o ? [u(e[0]), u(e[1])] : u(e),
              done: t
            };
          },
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }), n;
  }(e, t);
  return (t, l, r) => "__v_isReactive" === l ? !e : "__v_isReadonly" === l ? e : "__v_raw" === l ? t : Reflect.get(w(n, l) && l in t ? n : t, l, r);
}
let tr = {
    get: tl(!1, !1)
  },
  ti = {
    get: tl(!1, !0)
  },
  ts = {
    get: tl(!0, !1)
  },
  to = {
    get: tl(!0, !0)
  },
  ta = new WeakMap(),
  tu = new WeakMap(),
  tc = new WeakMap(),
  tf = new WeakMap();
function tp(e) {
  return t_(e) ? e : tv(e, !1, e3, tr, ta);
}
function td(e) {
  return tv(e, !1, e9, ti, tu);
}
function th(e) {
  return tv(e, !0, e5, ts, tc);
}
function tg(e) {
  return tv(e, !0, e7, to, tf);
}
function tv(e, t, n, l, r) {
  if (!I(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
  let i = r.get(e);
  if (i) return i;
  let s = e.__v_skip || !Object.isExtensible(e) ? 0 : function (e) {
    switch (e) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }(V(e));
  if (0 === s) return e;
  let o = new Proxy(e, 2 === s ? l : n);
  return r.set(e, o), o;
}
function tm(e) {
  return t_(e) ? tm(e.__v_raw) : !!(e && e.__v_isReactive);
}
function t_(e) {
  return !!(e && e.__v_isReadonly);
}
function ty(e) {
  return !!(e && e.__v_isShallow);
}
function tb(e) {
  return !!e && !!e.__v_raw;
}
function tS(e) {
  let t = e && e.__v_raw;
  return t ? tS(t) : e;
}
function tC(e) {
  return !w(e, "__v_skip") && Object.isExtensible(e) && Z(e, "__v_skip", !0), e;
}
let tx = e => I(e) ? tp(e) : e,
  tE = e => I(e) ? th(e) : e;
function tw(e) {
  return !!e && !0 === e.__v_isRef;
}
function tk(e) {
  return tA(e, !1);
}
function tT(e) {
  return tA(e, !0);
}
function tA(e, t) {
  return tw(e) ? e : new tR(e, t);
}
class tR {
  constructor(e, t) {
    this.dep = new eV(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : tS(e), this._value = t ? e : tx(e), this.__v_isShallow = t;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    let t = this._rawValue,
      n = this.__v_isShallow || ty(e) || t_(e);
    J(e = n ? e : tS(e), t) && (this._rawValue = e, this._value = n ? e : tx(e), this.dep.trigger());
  }
}
function tN(e) {
  e.dep && e.dep.trigger();
}
function tO(e) {
  return tw(e) ? e.value : e;
}
function tP(e) {
  return O(e) ? e() : tO(e);
}
let tM = {
  get: (e, t, n) => "__v_raw" === t ? e : tO(Reflect.get(e, t, n)),
  set: (e, t, n, l) => {
    let r = e[t];
    return tw(r) && !tw(n) ? (r.value = n, !0) : Reflect.set(e, t, n, l);
  }
};
function tI(e) {
  return tm(e) ? e : new Proxy(e, tM);
}
class tL {
  constructor(e) {
    this.__v_isRef = !0, this._value = void 0;
    let t = this.dep = new eV(),
      {
        get: n,
        set: l
      } = e(t.track.bind(t), t.trigger.bind(t));
    this._get = n, this._set = l;
  }
  get value() {
    return this._value = this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function tD(e) {
  return new tL(e);
}
function tF(e) {
  let t = k(e) ? Array(e.length) : {};
  for (let n in e) t[n] = tB(e, n);
  return t;
}
class tV {
  constructor(e, t, n) {
    this._object = e, this._key = t, this._defaultValue = n, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    let e = this._object[this._key];
    return this._value = void 0 === e ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return function (e, t) {
      let n = eU.get(e);
      return n && n.get(t);
    }(tS(this._object), this._key);
  }
}
class tU {
  constructor(e) {
    this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function tj(e, t, n) {
  return tw(e) ? e : O(e) ? new tU(e) : I(e) && arguments.length > 1 ? tB(e, t, n) : tk(e);
}
function tB(e, t, n) {
  let l = e[t];
  return tw(l) ? l : new tV(e, t, n);
}
class t$ {
  constructor(e, t, n) {
    this.fn = e, this.setter = t, this._value = void 0, this.dep = new eV(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = eD - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !t, this.isSSR = n;
  }
  notify() {
    if (this.flags |= 16, !(8 & this.flags) && r !== this) return eC(this, !0), !0;
  }
  get value() {
    let e = this.dep.track();
    return eT(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
let tH = {
    GET: "get",
    HAS: "has",
    ITERATE: "iterate"
  },
  tW = {
    SET: "set",
    ADD: "add",
    DELETE: "delete",
    CLEAR: "clear"
  },
  tK = {},
  tz = new WeakMap();
function tq() {
  return p;
}
function tG(e, t = !1, n = p) {
  if (n) {
    let t = tz.get(n);
    t || tz.set(n, t = []), t.push(e);
  }
}
function tJ(e, t = 1 / 0, n) {
  if (t <= 0 || !I(e) || e.__v_skip || (n = n || new Set()).has(e)) return e;
  if (n.add(e), t--, tw(e)) tJ(e.value, t, n);else if (k(e)) for (let l = 0; l < e.length; l++) tJ(e[l], t, n);else if (A(e) || T(e)) e.forEach(e => {
    tJ(e, t, n);
  });else if (U(e)) {
    for (let l in e) tJ(e[l], t, n);
    for (let l of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, l) && tJ(e[l], t, n);
  }
  return e;
}
function tX(e, t) {}
let tZ = {
  SETUP_FUNCTION: 0,
  0: "SETUP_FUNCTION",
  RENDER_FUNCTION: 1,
  1: "RENDER_FUNCTION",
  NATIVE_EVENT_HANDLER: 5,
  5: "NATIVE_EVENT_HANDLER",
  COMPONENT_EVENT_HANDLER: 6,
  6: "COMPONENT_EVENT_HANDLER",
  VNODE_HOOK: 7,
  7: "VNODE_HOOK",
  DIRECTIVE_HOOK: 8,
  8: "DIRECTIVE_HOOK",
  TRANSITION_HOOK: 9,
  9: "TRANSITION_HOOK",
  APP_ERROR_HANDLER: 10,
  10: "APP_ERROR_HANDLER",
  APP_WARN_HANDLER: 11,
  11: "APP_WARN_HANDLER",
  FUNCTION_REF: 12,
  12: "FUNCTION_REF",
  ASYNC_COMPONENT_LOADER: 13,
  13: "ASYNC_COMPONENT_LOADER",
  SCHEDULER: 14,
  14: "SCHEDULER",
  COMPONENT_UPDATE: 15,
  15: "COMPONENT_UPDATE",
  APP_UNMOUNT_CLEANUP: 16,
  16: "APP_UNMOUNT_CLEANUP"
};
function tY(e, t, n, l) {
  try {
    return l ? e(...l) : e();
  } catch (e) {
    t0(e, t, n);
  }
}
function tQ(e, t, n, l) {
  if (O(e)) {
    let r = tY(e, t, n, l);
    return r && L(r) && r.catch(e => {
      t0(e, t, n);
    }), r;
  }
  if (k(e)) {
    let r = [];
    for (let i = 0; i < e.length; i++) r.push(tQ(e[i], t, n, l));
    return r;
  }
}
function t0(e, t, n, l = !0) {
  t && t.vnode;
  let {
    errorHandler: r,
    throwUnhandledErrorInProduction: i
  } = t && t.appContext.config || g;
  if (t) {
    let l = t.parent,
      i = t.proxy,
      s = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l;) {
      let t = l.ec;
      if (t) {
        for (let n = 0; n < t.length; n++) if (!1 === t[n](e, i, s)) return;
      }
      l = l.parent;
    }
    if (r) {
      eM(), tY(r, null, 10, [e, i, s]), eI();
      return;
    }
  }
  !function (e, t, n, l = !0, r = !1) {
    if (r) throw e;
    console.error(e);
  }(e, 0, 0, l, i);
}
let t1 = [],
  t2 = -1,
  t6 = [],
  t4 = null,
  t8 = 0,
  t3 = Promise.resolve(),
  t5 = null;
function t9(e) {
  let t = t5 || t3;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function t7(e) {
  if (!(1 & e.flags)) {
    let t = nr(e),
      n = t1[t1.length - 1];
    !n || !(2 & e.flags) && t >= nr(n) ? t1.push(e) : t1.splice(function (e) {
      let t = t2 + 1,
        n = t1.length;
      for (; t < n;) {
        let l = t + n >>> 1,
          r = t1[l],
          i = nr(r);
        i < e || i === e && 2 & r.flags ? t = l + 1 : n = l;
      }
      return t;
    }(t), 0, e), e.flags |= 1, ne();
  }
}
function ne() {
  t5 || (t5 = t3.then(function e(t) {
    try {
      for (t2 = 0; t2 < t1.length; t2++) {
        let e = t1[t2];
        !e || 8 & e.flags || (4 & e.flags && (e.flags &= -2), tY(e, e.i, e.i ? 15 : 14), 4 & e.flags || (e.flags &= -2));
      }
    } finally {
      for (; t2 < t1.length; t2++) {
        let e = t1[t2];
        e && (e.flags &= -2);
      }
      t2 = -1, t1.length = 0, nl(), t5 = null, (t1.length || t6.length) && e();
    }
  }));
}
function nt(e) {
  k(e) ? t6.push(...e) : t4 && -1 === e.id ? t4.splice(t8 + 1, 0, e) : 1 & e.flags || (t6.push(e), e.flags |= 1), ne();
}
function nn(e, t, n = t2 + 1) {
  for (; n < t1.length; n++) {
    let t = t1[n];
    if (t && 2 & t.flags) {
      if (e && t.id !== e.uid) continue;
      t1.splice(n, 1), n--, 4 & t.flags && (t.flags &= -2), t(), 4 & t.flags || (t.flags &= -2);
    }
  }
}
function nl(e) {
  if (t6.length) {
    let e = [...new Set(t6)].sort((e, t) => nr(e) - nr(t));
    if (t6.length = 0, t4) {
      t4.push(...e);
      return;
    }
    for (t8 = 0, t4 = e; t8 < t4.length; t8++) {
      let e = t4[t8];
      4 & e.flags && (e.flags &= -2), 8 & e.flags || e(), e.flags &= -2;
    }
    t4 = null, t8 = 0;
  }
}
let nr = e => null == e.id ? 2 & e.flags ? -1 : 1 / 0 : e.id,
  ni = null,
  ns = null;
function no(e) {
  let t = ni;
  return ni = e, ns = e && e.type.__scopeId || null, t;
}
function na(e) {
  ns = e;
}
function nu() {
  ns = null;
}
let nc = e => nf;
function nf(e, t = ni, n) {
  if (!t || e._n) return e;
  let l = (...n) => {
    let r;
    l._d && r7(-1);
    let i = no(t);
    try {
      r = e(...n);
    } finally {
      no(i), l._d && r7(1);
    }
    return r;
  };
  return l._n = !0, l._c = !0, l._d = !0, l;
}
function np(e, t) {
  if (null === ni) return e;
  let n = iV(ni),
    l = e.dirs || (e.dirs = []);
  for (let e = 0; e < t.length; e++) {
    let [r, i, s, o = g] = t[e];
    r && (O(r) && (r = {
      mounted: r,
      updated: r
    }), r.deep && tJ(i), l.push({
      dir: r,
      instance: n,
      value: i,
      oldValue: void 0,
      arg: s,
      modifiers: o
    }));
  }
  return e;
}
function nd(e, t, n, l) {
  let r = e.dirs,
    i = t && t.dirs;
  for (let s = 0; s < r.length; s++) {
    let o = r[s];
    i && (o.oldValue = i[s].value);
    let a = o.dir[l];
    a && (eM(), tQ(a, n, 8, [e.el, o, e, t]), eI());
  }
}
let nh = Symbol("_vte"),
  ng = e => e.__isTeleport,
  nv = e => e && (e.disabled || "" === e.disabled),
  nm = e => e && (e.defer || "" === e.defer),
  n_ = e => "undefined" != typeof SVGElement && e instanceof SVGElement,
  ny = e => "function" == typeof MathMLElement && e instanceof MathMLElement,
  nb = (e, t) => {
    let n = e && e.to;
    return P(n) ? t ? t(n) : null : n;
  },
  nS = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, n, l, r, i, s, o, a, u) {
      let {
          mc: c,
          pc: f,
          pbc: p,
          o: {
            insert: d,
            querySelector: h,
            createText: g,
            createComment: m
          }
        } = u,
        _ = nv(t.props),
        {
          shapeFlag: y,
          children: b,
          dynamicChildren: S
        } = t;
      if (null == e) {
        let e = t.el = g(""),
          u = t.anchor = g("");
        d(e, n, l), d(u, n, l);
        let f = (e, t) => {
            16 & y && (r && r.isCE && (r.ce._teleportTarget = e), c(b, e, t, r, i, s, o, a));
          },
          p = () => {
            let e = t.target = nb(t.props, h),
              n = nw(e, t, g, d);
            e && ("svg" !== s && n_(e) ? s = "svg" : "mathml" !== s && ny(e) && (s = "mathml"), _ || (f(e, n), nE(t, !1)));
          };
        _ && (f(n, u), nE(t, !0)), nm(t.props) ? ry(() => {
          p(), t.el.__isMounted = !0;
        }, i) : p();
      } else {
        if (nm(t.props) && !e.el.__isMounted) {
          ry(() => {
            nS.process(e, t, n, l, r, i, s, o, a, u), delete e.el.__isMounted;
          }, i);
          return;
        }
        t.el = e.el, t.targetStart = e.targetStart;
        let c = t.anchor = e.anchor,
          d = t.target = e.target,
          g = t.targetAnchor = e.targetAnchor,
          m = nv(e.props),
          y = m ? n : d;
        if ("svg" === s || n_(d) ? s = "svg" : ("mathml" === s || ny(d)) && (s = "mathml"), S ? (p(e.dynamicChildren, S, y, r, i, s, o), rk(e, t, !0)) : a || f(e, t, y, m ? c : g, r, i, s, o, !1), _) m ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : nC(t, n, c, u, 1);else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
          let e = t.target = nb(t.props, h);
          e && nC(t, e, null, u, 0);
        } else m && nC(t, d, g, u, 1);
        nE(t, _);
      }
    },
    remove(e, t, n, {
      um: l,
      o: {
        remove: r
      }
    }, i) {
      let {
        shapeFlag: s,
        children: o,
        anchor: a,
        targetStart: u,
        targetAnchor: c,
        target: f,
        props: p
      } = e;
      if (f && (r(u), r(c)), i && r(a), 16 & s) {
        let e = i || !nv(p);
        for (let r = 0; r < o.length; r++) {
          let i = o[r];
          l(i, t, n, e, !!i.dynamicChildren);
        }
      }
    },
    move: nC,
    hydrate: function (e, t, n, l, r, i, {
      o: {
        nextSibling: s,
        parentNode: o,
        querySelector: a,
        insert: u,
        createText: c
      }
    }, f) {
      let p = t.target = nb(t.props, a);
      if (p) {
        let a = nv(t.props),
          d = p._lpa || p.firstChild;
        if (16 & t.shapeFlag) {
          if (a) t.anchor = f(s(e), t, o(e), n, l, r, i), t.targetStart = d, t.targetAnchor = d && s(d);else {
            t.anchor = s(e);
            let o = d;
            for (; o;) {
              if (o && 8 === o.nodeType) {
                if ("teleport start anchor" === o.data) t.targetStart = o;else if ("teleport anchor" === o.data) {
                  t.targetAnchor = o, p._lpa = t.targetAnchor && s(t.targetAnchor);
                  break;
                }
              }
              o = s(o);
            }
            t.targetAnchor || nw(p, t, c, u), f(d && s(d), t, p, n, l, r, i);
          }
        }
        nE(t, a);
      }
      return t.anchor && s(t.anchor);
    }
  };
function nC(e, t, n, {
  o: {
    insert: l
  },
  m: r
}, i = 2) {
  0 === i && l(e.targetAnchor, t, n);
  let {
      el: s,
      anchor: o,
      shapeFlag: a,
      children: u,
      props: c
    } = e,
    f = 2 === i;
  if (f && l(s, t, n), (!f || nv(c)) && 16 & a) for (let e = 0; e < u.length; e++) r(u[e], t, n, 2);
  f && l(o, t, n);
}
let nx = (/* unused pure expression or super */ null && (nS));
function nE(e, t) {
  let n = e.ctx;
  if (n && n.ut) {
    let l, r;
    for (t ? (l = e.el, r = e.anchor) : (l = e.targetStart, r = e.targetAnchor); l && l !== r;) 1 === l.nodeType && l.setAttribute("data-v-owner", n.uid), l = l.nextSibling;
    n.ut();
  }
}
function nw(e, t, n, l) {
  let r = t.targetStart = n(""),
    i = t.targetAnchor = n("");
  return r[nh] = i, e && (l(r, e), l(i, e)), i;
}
let nk = Symbol("_leaveCb"),
  nT = Symbol("_enterCb");
function nA() {
  let e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: new Map()
  };
  return lf(() => {
    e.isMounted = !0;
  }), lh(() => {
    e.isUnmounting = !0;
  }), e;
}
let nR = [Function, Array],
  nN = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: nR,
    onEnter: nR,
    onAfterEnter: nR,
    onEnterCancelled: nR,
    onBeforeLeave: nR,
    onLeave: nR,
    onAfterLeave: nR,
    onLeaveCancelled: nR,
    onBeforeAppear: nR,
    onAppear: nR,
    onAfterAppear: nR,
    onAppearCancelled: nR
  },
  nO = e => {
    let t = e.subTree;
    return t.component ? nO(t.component) : t;
  };
function nP(e) {
  let t = e[0];
  if (e.length > 1) {
    for (let n of e) if (n.type !== r2) {
      t = n;
      break;
    }
  }
  return t;
}
let nM = {
  name: "BaseTransition",
  props: nN,
  setup(e, {
    slots: t
  }) {
    let n = ik(),
      l = nA();
    return () => {
      let r = t.default && nU(t.default(), !0);
      if (!r || !r.length) return;
      let i = nP(r),
        s = tS(e),
        {
          mode: o
        } = s;
      if (l.isLeaving) return nD(i);
      let a = nF(i);
      if (!a) return nD(i);
      let u = nL(a, s, l, n, e => u = e);
      a.type !== r2 && nV(a, u);
      let c = n.subTree && nF(n.subTree);
      if (c && c.type !== r2 && !ii(a, c) && nO(n).type !== r2) {
        let e = nL(c, s, l, n);
        if (nV(c, e), "out-in" === o && a.type !== r2) return l.isLeaving = !0, e.afterLeave = () => {
          l.isLeaving = !1, 8 & n.job.flags || n.update(), delete e.afterLeave, c = void 0;
        }, nD(i);
        "in-out" === o && a.type !== r2 ? e.delayLeave = (e, t, n) => {
          nI(l, c)[String(c.key)] = c, e[nk] = () => {
            t(), e[nk] = void 0, delete u.delayedLeave, c = void 0;
          }, u.delayedLeave = () => {
            n(), delete u.delayedLeave, c = void 0;
          };
        } : c = void 0;
      } else c && (c = void 0);
      return i;
    };
  }
};
function nI(e, t) {
  let {
      leavingVNodes: n
    } = e,
    l = n.get(t.type);
  return l || (l = Object.create(null), n.set(t.type, l)), l;
}
function nL(e, t, n, l, r) {
  let {
      appear: i,
      mode: s,
      persisted: o = !1,
      onBeforeEnter: a,
      onEnter: u,
      onAfterEnter: c,
      onEnterCancelled: f,
      onBeforeLeave: p,
      onLeave: d,
      onAfterLeave: h,
      onLeaveCancelled: g,
      onBeforeAppear: m,
      onAppear: _,
      onAfterAppear: y,
      onAppearCancelled: b
    } = t,
    S = String(e.key),
    C = nI(n, e),
    x = (e, t) => {
      e && tQ(e, l, 9, t);
    },
    E = (e, t) => {
      let n = t[1];
      x(e, t), k(e) ? e.every(e => e.length <= 1) && n() : e.length <= 1 && n();
    },
    w = {
      mode: s,
      persisted: o,
      beforeEnter(t) {
        let l = a;
        if (!n.isMounted) {
          if (!i) return;
          l = m || a;
        }
        t[nk] && t[nk](!0);
        let r = C[S];
        r && ii(e, r) && r.el[nk] && r.el[nk](), x(l, [t]);
      },
      enter(e) {
        let t = u,
          l = c,
          r = f;
        if (!n.isMounted) {
          if (!i) return;
          t = _ || u, l = y || c, r = b || f;
        }
        let s = !1,
          o = e[nT] = t => {
            s || (s = !0, t ? x(r, [e]) : x(l, [e]), w.delayedLeave && w.delayedLeave(), e[nT] = void 0);
          };
        t ? E(t, [e, o]) : o();
      },
      leave(t, l) {
        let r = String(e.key);
        if (t[nT] && t[nT](!0), n.isUnmounting) return l();
        x(p, [t]);
        let i = !1,
          s = t[nk] = n => {
            i || (i = !0, l(), n ? x(g, [t]) : x(h, [t]), t[nk] = void 0, C[r] !== e || delete C[r]);
          };
        C[r] = e, d ? E(d, [t, s]) : s();
      },
      clone(e) {
        let i = nL(e, t, n, l, r);
        return r && r(i), i;
      }
    };
  return w;
}
function nD(e) {
  if (le(e)) return (e = id(e)).children = null, e;
}
function nF(e) {
  if (!le(e)) return ng(e.type) && e.children ? nP(e.children) : e;
  let {
    shapeFlag: t,
    children: n
  } = e;
  if (n) {
    if (16 & t) return n[0];
    if (32 & t && O(n.default)) return n.default();
  }
}
function nV(e, t) {
  6 & e.shapeFlag && e.component ? (e.transition = t, nV(e.component.subTree, t)) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
function nU(e, t = !1, n) {
  let l = [],
    r = 0;
  for (let i = 0; i < e.length; i++) {
    let s = e[i],
      o = null == n ? s.key : String(n) + String(null != s.key ? s.key : i);
    s.type === r0 ? (128 & s.patchFlag && r++, l = l.concat(nU(s.children, t, o))) : (t || s.type !== r2) && l.push(null != o ? id(s, {
      key: o
    }) : s);
  }
  if (r > 1) for (let e = 0; e < l.length; e++) l[e].patchFlag = -2;
  return l;
}
function nj(e, t) {
  return O(e) ? C({
    name: e.name
  }, t, {
    setup: e
  }) : e;
}
function nB() {
  let e = ik();
  return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : "";
}
function n$(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
function nH(e) {
  let t = ik(),
    n = tT(null);
  return t && Object.defineProperty(t.refs === g ? t.refs = {} : t.refs, e, {
    enumerable: !0,
    get: () => n.value,
    set: e => n.value = e
  }), n;
}
function nW(e, t, n, l, r = !1) {
  if (k(e)) {
    e.forEach((e, i) => nW(e, t && (k(t) ? t[i] : t), n, l, r));
    return;
  }
  if (n5(l) && !r) {
    512 & l.shapeFlag && l.type.__asyncResolved && l.component.subTree.component && nW(e, t, n, l.component.subTree);
    return;
  }
  let i = 4 & l.shapeFlag ? iV(l.component) : l.el,
    s = r ? null : i,
    {
      i: o,
      r: a
    } = e,
    u = t && t.r,
    c = o.refs === g ? o.refs = {} : o.refs,
    f = o.setupState,
    p = tS(f),
    d = f === g ? () => !1 : e => w(p, e);
  if (null != u && u !== a && (P(u) ? (c[u] = null, d(u) && (f[u] = null)) : tw(u) && (u.value = null)), O(a)) tY(a, o, 12, [s, c]);else {
    let t = P(a),
      l = tw(a);
    if (t || l) {
      let o = () => {
        if (e.f) {
          let n = t ? d(a) ? f[a] : c[a] : a.value;
          r ? k(n) && x(n, i) : k(n) ? n.includes(i) || n.push(i) : t ? (c[a] = [i], d(a) && (f[a] = c[a])) : (a.value = [i], e.k && (c[e.k] = a.value));
        } else t ? (c[a] = s, d(a) && (f[a] = s)) : l && (a.value = s, e.k && (c[e.k] = s));
      };
      s ? (o.id = -1, ry(o, n)) : o();
    }
  }
}
let nK = (/* unused pure expression or super */ null && (!1)),
  nz = () => {
    nK || (console.error("Hydration completed but contains mismatches."), nK = !0);
  },
  nq = e => e.namespaceURI.includes("svg") && "foreignObject" !== e.tagName,
  nG = e => e.namespaceURI.includes("MathML"),
  nJ = e => {
    if (1 === e.nodeType) {
      if (nq(e)) return "svg";
      if (nG(e)) return "mathml";
    }
  },
  nX = e => 8 === e.nodeType;
function nZ(e) {
  let {
      mt: t,
      p: n,
      o: {
        patchProp: l,
        createText: r,
        nextSibling: i,
        parentNode: s,
        remove: o,
        insert: a,
        createComment: u
      }
    } = e,
    c = (n, l, o, u, y, b = !1) => {
      b = b || !!l.dynamicChildren;
      let S = nX(n) && "[" === n.data,
        C = () => h(n, l, o, u, y, S),
        {
          type: x,
          ref: E,
          shapeFlag: w,
          patchFlag: k
        } = l,
        T = n.nodeType;
      l.el = n, -2 === k && (b = !1, l.dynamicChildren = null);
      let A = null;
      switch (x) {
        case r1:
          3 !== T ? "" === l.children ? (a(l.el = r(""), s(n), n), A = n) : A = C() : (n.data !== l.children && (nz(), n.data = l.children), A = i(n));
          break;
        case r2:
          _(n) ? (A = i(n), m(l.el = n.content.firstChild, n, o)) : A = 8 !== T || S ? C() : i(n);
          break;
        case r6:
          if (S && (T = (n = i(n)).nodeType), 1 === T || 3 === T) {
            A = n;
            let e = !l.children.length;
            for (let t = 0; t < l.staticCount; t++) e && (l.children += 1 === A.nodeType ? A.outerHTML : A.data), t === l.staticCount - 1 && (l.anchor = A), A = i(A);
            return S ? i(A) : A;
          }
          C();
          break;
        case r0:
          A = S ? d(n, l, o, u, y, b) : C();
          break;
        default:
          if (1 & w) A = 1 === T && l.type.toLowerCase() === n.tagName.toLowerCase() || _(n) ? f(n, l, o, u, y, b) : C();else if (6 & w) {
            l.slotScopeIds = y;
            let e = s(n);
            if (A = S ? g(n) : nX(n) && "teleport start" === n.data ? g(n, n.data, "teleport end") : i(n), t(l, e, null, o, u, nJ(e), b), n5(l) && !l.type.__asyncResolved) {
              let t;
              S ? (t = ic(r0)).anchor = A ? A.previousSibling : e.lastChild : t = 3 === n.nodeType ? ih("") : ic("div"), t.el = n, l.component.subTree = t;
            }
          } else 64 & w ? A = 8 !== T ? C() : l.type.hydrate(n, l, o, u, y, b, e, p) : 128 & w && (A = l.type.hydrate(n, l, o, u, nJ(s(n)), y, b, e, c));
      }
      return null != E && nW(E, null, u, l), A;
    },
    f = (e, t, n, r, i, s) => {
      s = s || !!t.dynamicChildren;
      let {
          type: a,
          props: u,
          patchFlag: c,
          shapeFlag: f,
          dirs: d,
          transition: h
        } = t,
        g = "input" === a || "option" === a;
      if (g || -1 !== c) {
        let a;
        d && nd(t, null, n, "created");
        let y = !1;
        if (_(e)) {
          y = rw(null, h) && n && n.vnode.props && n.vnode.props.appear;
          let l = e.content.firstChild;
          y && h.beforeEnter(l), m(l, e, n), t.el = e = l;
        }
        if (16 & f && !(u && (u.innerHTML || u.textContent))) {
          let l = p(e.firstChild, t, e, n, r, i, s);
          for (; l;) {
            n0(e, 1) || nz();
            let t = l;
            l = l.nextSibling, o(t);
          }
        } else if (8 & f) {
          let n = t.children;
          "\n" === n[0] && ("PRE" === e.tagName || "TEXTAREA" === e.tagName) && (n = n.slice(1)), e.textContent !== n && (n0(e, 0) || nz(), e.textContent = t.children);
        }
        if (u) {
          if (g || !s || 48 & c) {
            let t = e.tagName.includes("-");
            for (let r in u) (g && (r.endsWith("value") || "indeterminate" === r) || b(r) && !B(r) || "." === r[0] || t) && l(e, r, null, u[r], void 0, n);
          } else if (u.onClick) l(e, "onClick", null, u.onClick, void 0, n);else if (4 & c && tm(u.style)) for (let e in u.style) u.style[e];
        }
        (a = u && u.onVnodeBeforeMount) && iS(a, n, t), d && nd(t, null, n, "beforeMount"), ((a = u && u.onVnodeMounted) || d || y) && rY(() => {
          a && iS(a, n, t), y && h.enter(e), d && nd(t, null, n, "mounted");
        }, r);
      }
      return e.nextSibling;
    },
    p = (e, t, l, s, o, u, f) => {
      f = f || !!t.dynamicChildren;
      let p = t.children,
        d = p.length;
      for (let t = 0; t < d; t++) {
        let h = f ? p[t] : p[t] = im(p[t]),
          g = h.type === r1;
        e ? (g && !f && t + 1 < d && im(p[t + 1]).type === r1 && (a(r(e.data.slice(h.children.length)), l, i(e)), e.data = h.children), e = c(e, h, s, o, u, f)) : g && !h.children ? a(h.el = r(""), l) : (n0(l, 1) || nz(), n(null, h, l, null, s, o, nJ(l), u));
      }
      return e;
    },
    d = (e, t, n, l, r, o) => {
      let {
        slotScopeIds: c
      } = t;
      c && (r = r ? r.concat(c) : c);
      let f = s(e),
        d = p(i(e), t, f, n, l, r, o);
      return d && nX(d) && "]" === d.data ? i(t.anchor = d) : (nz(), a(t.anchor = u("]"), f, d), d);
    },
    h = (e, t, l, r, a, u) => {
      if (n0(e.parentElement, 1) || nz(), t.el = null, u) {
        let t = g(e);
        for (;;) {
          let n = i(e);
          if (n && n !== t) o(n);else break;
        }
      }
      let c = i(e),
        f = s(e);
      return o(e), n(null, t, f, c, l, r, nJ(f), a), l && (l.vnode.el = t.el, rK(l, t.el)), c;
    },
    g = (e, t = "[", n = "]") => {
      let l = 0;
      for (; e;) if ((e = i(e)) && nX(e) && (e.data === t && l++, e.data === n)) {
        if (0 === l) return i(e);
        l--;
      }
      return e;
    },
    m = (e, t, n) => {
      let l = t.parentNode;
      l && l.replaceChild(e, t);
      let r = n;
      for (; r;) r.vnode.el === t && (r.vnode.el = r.subTree.el = e), r = r.parent;
    },
    _ = e => 1 === e.nodeType && "TEMPLATE" === e.tagName;
  return [(e, t) => {
    if (!t.hasChildNodes()) {
      n(null, e, t), nl(), t._vnode = e;
      return;
    }
    c(t.firstChild, e, null, null, null), nl(), t._vnode = e;
  }, c];
}
let nY = "data-allow-mismatch",
  nQ = {
    0: "text",
    1: "children",
    2: "class",
    3: "style",
    4: "attribute"
  };
function n0(e, t) {
  if (0 === t || 1 === t) for (; e && !e.hasAttribute(nY);) e = e.parentElement;
  let n = e && e.getAttribute(nY);
  if (null == n) return !1;
  if ("" === n) return !0;
  {
    let e = n.split(",");
    return !!(0 === t && e.includes("children")) || n.split(",").includes(nQ[t]);
  }
}
let n1 = ee().requestIdleCallback || (e => setTimeout(e, 1)),
  n2 = ee().cancelIdleCallback || (e => clearTimeout(e)),
  n6 = (e = 1e4) => t => {
    let n = n1(t, {
      timeout: e
    });
    return () => n2(n);
  },
  n4 = e => (t, n) => {
    let l = new IntersectionObserver(e => {
      for (let n of e) if (n.isIntersecting) {
        l.disconnect(), t();
        break;
      }
    }, e);
    return n(e => {
      if (e instanceof Element) {
        if (function (e) {
          let {
              top: t,
              left: n,
              bottom: l,
              right: r
            } = e.getBoundingClientRect(),
            {
              innerHeight: i,
              innerWidth: s
            } = window;
          return (t > 0 && t < i || l > 0 && l < i) && (n > 0 && n < s || r > 0 && r < s);
        }(e)) return t(), l.disconnect(), !1;
        l.observe(e);
      }
    }), () => l.disconnect();
  },
  n8 = e => t => {
    if (e) {
      let n = matchMedia(e);
      if (!n.matches) return n.addEventListener("change", t, {
        once: !0
      }), () => n.removeEventListener("change", t);
      t();
    }
  },
  n3 = (e = []) => (t, n) => {
    P(e) && (e = [e]);
    let l = !1,
      r = e => {
        l || (l = !0, i(), t(), e.target.dispatchEvent(new e.constructor(e.type, e)));
      },
      i = () => {
        n(t => {
          for (let n of e) t.removeEventListener(n, r);
        });
      };
    return n(t => {
      for (let n of e) t.addEventListener(n, r, {
        once: !0
      });
    }), i;
  },
  n5 = e => !!e.type.__asyncLoader;
function n9(e) {
  let t;
  O(e) && (e = {
    loader: e
  });
  let {
      loader: n,
      loadingComponent: l,
      errorComponent: r,
      delay: i = 200,
      hydrate: s,
      timeout: o,
      suspensible: a = !0,
      onError: u
    } = e,
    c = null,
    f = 0,
    p = () => (f++, c = null, d()),
    d = () => {
      let e;
      return c || (e = c = n().catch(e => {
        if (e = e instanceof Error ? e : Error(String(e)), u) return new Promise((t, n) => {
          u(e, () => t(p()), () => n(e), f + 1);
        });
        throw e;
      }).then(n => e !== c && c ? c : (n && (n.__esModule || "Module" === n[Symbol.toStringTag]) && (n = n.default), t = n, n)));
    };
  return nj({
    name: "AsyncComponentWrapper",
    __asyncLoader: d,
    __asyncHydrate(e, n, l) {
      let r = s ? () => {
        let t = s(l, t => function (e, t) {
          if (nX(e) && "[" === e.data) {
            let n = 1,
              l = e.nextSibling;
            for (; l;) {
              if (1 === l.nodeType) {
                if (!1 === t(l)) break;
              } else if (nX(l)) {
                if ("]" === l.data) {
                  if (0 == --n) break;
                } else "[" === l.data && n++;
              }
              l = l.nextSibling;
            }
          } else t(e);
        }(e, t));
        t && (n.bum || (n.bum = [])).push(t);
      } : l;
      t ? r() : d().then(() => !n.isUnmounted && r());
    },
    get __asyncResolved() {
      return t;
    },
    setup() {
      let e = iw;
      if (n$(e), t) return () => n7(t, e);
      let n = t => {
        c = null, t0(t, e, 13, !r);
      };
      if (a && e.suspense || iN) return d().then(t => () => n7(t, e)).catch(e => (n(e), () => r ? ic(r, {
        error: e
      }) : null));
      let s = tk(!1),
        u = tk(),
        f = tk(!!i);
      return i && setTimeout(() => {
        f.value = !1;
      }, i), null != o && setTimeout(() => {
        if (!s.value && !u.value) {
          let e = Error(`Async component timed out after ${o}ms.`);
          n(e), u.value = e;
        }
      }, o), d().then(() => {
        s.value = !0, e.parent && le(e.parent.vnode) && e.parent.update();
      }).catch(e => {
        n(e), u.value = e;
      }), () => s.value && t ? n7(t, e) : u.value && r ? ic(r, {
        error: u.value
      }) : l && !f.value ? ic(l) : void 0;
    }
  });
}
function n7(e, t) {
  let {
      ref: n,
      props: l,
      children: r,
      ce: i
    } = t.vnode,
    s = ic(e, l, r);
  return s.ref = n, s.ce = i, delete t.vnode.ce, s;
}
let le = e => e.type.__isKeepAlive,
  lt = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number]
    },
    setup(e, {
      slots: t
    }) {
      let n = ik(),
        l = n.ctx;
      if (!l.renderer) return () => {
        let e = t.default && t.default();
        return e && 1 === e.length ? e[0] : e;
      };
      let r = new Map(),
        i = new Set(),
        s = null,
        o = n.suspense,
        {
          renderer: {
            p: a,
            m: u,
            um: c,
            o: {
              createElement: f
            }
          }
        } = l,
        p = f("div");
      function d(e) {
        ls(e), c(e, n, o, !0);
      }
      function h(e) {
        r.forEach((t, n) => {
          let l = iU(t.type);
          l && !e(l) && g(n);
        });
      }
      function g(e) {
        let t = r.get(e);
        !t || s && ii(t, s) ? s && ls(s) : d(t), r.delete(e), i.delete(e);
      }
      l.activate = (e, t, n, l, r) => {
        let i = e.component;
        u(e, t, n, 0, o), a(i.vnode, e, t, n, i, o, l, e.slotScopeIds, r), ry(() => {
          i.isDeactivated = !1, i.a && X(i.a);
          let t = e.props && e.props.onVnodeMounted;
          t && iS(t, i.parent, e);
        }, o);
      }, l.deactivate = e => {
        let t = e.component;
        rT(t.m), rT(t.a), u(e, p, null, 1, o), ry(() => {
          t.da && X(t.da);
          let n = e.props && e.props.onVnodeUnmounted;
          n && iS(n, t.parent, e), t.isDeactivated = !0;
        }, o);
      }, rM(() => [e.include, e.exclude], ([e, t]) => {
        e && h(t => ln(e, t)), t && h(e => !ln(t, e));
      }, {
        flush: "post",
        deep: !0
      });
      let m = null,
        _ = () => {
          null != m && (rz(n.subTree.type) ? ry(() => {
            r.set(m, lo(n.subTree));
          }, n.subTree.suspense) : r.set(m, lo(n.subTree)));
        };
      return lf(_), ld(_), lh(() => {
        r.forEach(e => {
          let {
              subTree: t,
              suspense: l
            } = n,
            r = lo(t);
          if (e.type === r.type && e.key === r.key) {
            ls(r);
            let e = r.component.da;
            e && ry(e, l);
            return;
          }
          d(e);
        });
      }), () => {
        if (m = null, !t.default) return s = null;
        let n = t.default(),
          l = n[0];
        if (n.length > 1) return s = null, n;
        if (!ir(l) || !(4 & l.shapeFlag) && !(128 & l.shapeFlag)) return s = null, l;
        let o = lo(l);
        if (o.type === r2) return s = null, o;
        let a = o.type,
          u = iU(n5(o) ? o.type.__asyncResolved || {} : a),
          {
            include: c,
            exclude: f,
            max: p
          } = e;
        if (c && (!u || !ln(c, u)) || f && u && ln(f, u)) return o.shapeFlag &= -257, s = o, l;
        let d = null == o.key ? a : o.key,
          h = r.get(d);
        return o.el && (o = id(o), 128 & l.shapeFlag && (l.ssContent = o)), m = d, h ? (o.el = h.el, o.component = h.component, o.transition && nV(o, o.transition), o.shapeFlag |= 512, i.delete(d), i.add(d)) : (i.add(d), p && i.size > parseInt(p, 10) && g(i.values().next().value)), o.shapeFlag |= 256, s = o, rz(l.type) ? l : o;
      };
    }
  };
function ln(e, t) {
  return k(e) ? e.some(e => ln(e, t)) : P(e) ? e.split(",").includes(t) : !!N(e) && (e.lastIndex = 0, e.test(t));
}
function ll(e, t) {
  li(e, "a", t);
}
function lr(e, t) {
  li(e, "da", t);
}
function li(e, t, n = iw) {
  let l = e.__wdc || (e.__wdc = () => {
    let t = n;
    for (; t;) {
      if (t.isDeactivated) return;
      t = t.parent;
    }
    return e();
  });
  if (la(t, l, n), n) {
    let e = n.parent;
    for (; e && e.parent;) le(e.parent.vnode) && function (e, t, n, l) {
      let r = la(t, e, l, !0);
      lg(() => {
        x(l[t], r);
      }, n);
    }(l, t, n, e), e = e.parent;
  }
}
function ls(e) {
  e.shapeFlag &= -257, e.shapeFlag &= -513;
}
function lo(e) {
  return 128 & e.shapeFlag ? e.ssContent : e;
}
function la(e, t, n = iw, l = !1) {
  if (n) {
    let r = n[e] || (n[e] = []),
      i = t.__weh || (t.__weh = (...l) => {
        eM();
        let r = iT(n),
          i = tQ(t, n, e, l);
        return r(), eI(), i;
      });
    return l ? r.unshift(i) : r.push(i), i;
  }
}
let lu = e => (t, n = iw) => {
    iN && "sp" !== e || la(e, (...e) => t(...e), n);
  },
  lc = lu("bm"),
  lf = lu("m"),
  lp = lu("bu"),
  ld = lu("u"),
  lh = lu("bum"),
  lg = lu("um"),
  lv = lu("sp"),
  lm = lu("rtg"),
  l_ = lu("rtc");
function ly(e, t = iw) {
  la("ec", e, t);
}
let lb = "components";
function lS(e, t) {
  return lw(lb, e, !0, t) || e;
}
let lC = Symbol.for("v-ndc");
function lx(e) {
  return P(e) ? lw(lb, e, !1) || e : e || lC;
}
function lE(e) {
  return lw("directives", e);
}
function lw(e, t, n = !0, l = !1) {
  let r = ni || iw;
  if (r) {
    let n = r.type;
    if (e === lb) {
      let e = iU(n, !1);
      if (e && (e === t || e === W(t) || e === q(W(t)))) return n;
    }
    let i = lk(r[e] || n[e], t) || lk(r.appContext[e], t);
    return !i && l ? n : i;
  }
}
function lk(e, t) {
  return e && (e[t] || e[W(t)] || e[q(W(t))]);
}
function lT(e, t, n, l) {
  let r;
  let i = n && n[l],
    s = k(e);
  if (s || P(e)) {
    let n = s && tm(e),
      l = !1;
    n && (l = !ty(e), e = ez(e)), r = Array(e.length);
    for (let n = 0, s = e.length; n < s; n++) r[n] = t(l ? tx(e[n]) : e[n], n, void 0, i && i[n]);
  } else if ("number" == typeof e) {
    r = Array(e);
    for (let n = 0; n < e; n++) r[n] = t(n + 1, n, void 0, i && i[n]);
  } else if (I(e)) {
    if (e[Symbol.iterator]) r = Array.from(e, (e, n) => t(e, n, void 0, i && i[n]));else {
      let n = Object.keys(e);
      r = Array(n.length);
      for (let l = 0, s = n.length; l < s; l++) {
        let s = n[l];
        r[l] = t(e[s], s, l, i && i[l]);
      }
    }
  } else r = [];
  return n && (n[l] = r), r;
}
function lA(e, t) {
  for (let n = 0; n < t.length; n++) {
    let l = t[n];
    if (k(l)) for (let t = 0; t < l.length; t++) e[l[t].name] = l[t].fn;else l && (e[l.name] = l.key ? (...e) => {
      let t = l.fn(...e);
      return t && (t.key = l.key), t;
    } : l.fn);
  }
  return e;
}
function lR(e, t, n = {}, l, r) {
  if (ni.ce || ni.parent && n5(ni.parent) && ni.parent.ce) return "default" !== t && (n.name = t), r3(), il(r0, null, [ic("slot", n, l && l())], 64);
  let i = e[t];
  i && i._c && (i._d = !1), r3();
  let s = i && lN(i(n)),
    o = n.key || s && s.key,
    a = il(r0, {
      key: (o && !M(o) ? o : `_${t}`) + (!s && l ? "_fb" : "")
    }, s || (l ? l() : []), s && 1 === e._ ? 64 : -2);
  return !r && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), i && i._c && (i._d = !0), a;
}
function lN(e) {
  return e.some(e => !ir(e) || !!(e.type !== r2 && (e.type !== r0 || lN(e.children)))) ? e : null;
}
function lO(e, t) {
  let n = {};
  for (let l in e) n[t && /[A-Z]/.test(l) ? `on:${l}` : G(l)] = e[l];
  return n;
}
let lP = e => e ? iR(e) ? iV(e) : lP(e.parent) : null,
  lM = C(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => lP(e.parent),
    $root: e => lP(e.root),
    $host: e => e.ce,
    $emit: e => e.emit,
    $options: e => l0(e),
    $forceUpdate: e => e.f || (e.f = () => {
      t7(e.update);
    }),
    $nextTick: e => e.n || (e.n = t9.bind(e.proxy)),
    $watch: e => rL.bind(e)
  }),
  lI = (e, t) => e !== g && !e.__isScriptSetup && w(e, t),
  lL = {
    get({
      _: e
    }, t) {
      let n, l, r;
      if ("__v_skip" === t) return !0;
      let {
        ctx: i,
        setupState: s,
        data: o,
        props: a,
        accessCache: u,
        type: c,
        appContext: f
      } = e;
      if ("$" !== t[0]) {
        let l = u[t];
        if (void 0 !== l) switch (l) {
          case 1:
            return s[t];
          case 2:
            return o[t];
          case 4:
            return i[t];
          case 3:
            return a[t];
        } else {
          if (lI(s, t)) return u[t] = 1, s[t];
          if (o !== g && w(o, t)) return u[t] = 2, o[t];
          if ((n = e.propsOptions[0]) && w(n, t)) return u[t] = 3, a[t];
          if (i !== g && w(i, t)) return u[t] = 4, i[t];
          lY && (u[t] = 0);
        }
      }
      let p = lM[t];
      return p ? ("$attrs" === t && eH(e.attrs, "get", ""), p(e)) : (l = c.__cssModules) && (l = l[t]) ? l : i !== g && w(i, t) ? (u[t] = 4, i[t]) : w(r = f.config.globalProperties, t) ? r[t] : void 0;
    },
    set({
      _: e
    }, t, n) {
      let {
        data: l,
        setupState: r,
        ctx: i
      } = e;
      return lI(r, t) ? (r[t] = n, !0) : l !== g && w(l, t) ? (l[t] = n, !0) : !w(e.props, t) && !("$" === t[0] && t.slice(1) in e) && (i[t] = n, !0);
    },
    has({
      _: {
        data: e,
        setupState: t,
        accessCache: n,
        ctx: l,
        appContext: r,
        propsOptions: i
      }
    }, s) {
      let o;
      return !!n[s] || e !== g && w(e, s) || lI(t, s) || (o = i[0]) && w(o, s) || w(l, s) || w(lM, s) || w(r.config.globalProperties, s);
    },
    defineProperty(e, t, n) {
      return null != n.get ? e._.accessCache[t] = 0 : w(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n);
    }
  },
  lD = C({}, lL, {
    get(e, t) {
      if (t !== Symbol.unscopables) return lL.get(e, t, e);
    },
    has: (e, t) => "_" !== t[0] && !et(t)
  });
function lF() {
  return null;
}
function lV() {
  return null;
}
function lU(e) {}
function lj(e) {}
function lB() {
  return null;
}
function l$() {}
function lH(e, t) {
  return null;
}
function lW() {
  return lz().slots;
}
function lK() {
  return lz().attrs;
}
function lz() {
  let e = ik();
  return e.setupContext || (e.setupContext = iF(e));
}
function lq(e) {
  return k(e) ? e.reduce((e, t) => (e[t] = null, e), {}) : e;
}
function lG(e, t) {
  let n = lq(e);
  for (let e in t) {
    if (e.startsWith("__skip")) continue;
    let l = n[e];
    l ? k(l) || O(l) ? l = n[e] = {
      type: l,
      default: t[e]
    } : l.default = t[e] : null === l && (l = n[e] = {
      default: t[e]
    }), l && t[`__skip_${e}`] && (l.skipFactory = !0);
  }
  return n;
}
function lJ(e, t) {
  return e && t ? k(e) && k(t) ? e.concat(t) : C({}, lq(e), lq(t)) : e || t;
}
function lX(e, t) {
  let n = {};
  for (let l in e) t.includes(l) || Object.defineProperty(n, l, {
    enumerable: !0,
    get: () => e[l]
  });
  return n;
}
function lZ(e) {
  let t = ik(),
    n = e();
  return iA(), L(n) && (n = n.catch(e => {
    throw iT(t), e;
  })), [n, () => iT(t)];
}
let lY = !0;
function lQ(e, t, n) {
  tQ(k(e) ? e.map(e => e.bind(t.proxy)) : e.bind(t.proxy), t, n);
}
function l0(e) {
  let t;
  let n = e.type,
    {
      mixins: l,
      extends: r
    } = n,
    {
      mixins: i,
      optionsCache: s,
      config: {
        optionMergeStrategies: o
      }
    } = e.appContext,
    a = s.get(n);
  return a ? t = a : i.length || l || r ? (t = {}, i.length && i.forEach(e => l1(t, e, o, !0)), l1(t, n, o)) : t = n, I(n) && s.set(n, t), t;
}
function l1(e, t, n, l = !1) {
  let {
    mixins: r,
    extends: i
  } = t;
  for (let s in i && l1(e, i, n, !0), r && r.forEach(t => l1(e, t, n, !0)), t) if (l && "expose" === s) ;else {
    let l = l2[s] || n && n[s];
    e[s] = l ? l(e[s], t[s]) : t[s];
  }
  return e;
}
let l2 = {
  data: l6,
  props: l5,
  emits: l5,
  methods: l3,
  computed: l3,
  beforeCreate: l8,
  created: l8,
  beforeMount: l8,
  mounted: l8,
  beforeUpdate: l8,
  updated: l8,
  beforeDestroy: l8,
  beforeUnmount: l8,
  destroyed: l8,
  unmounted: l8,
  activated: l8,
  deactivated: l8,
  errorCaptured: l8,
  serverPrefetch: l8,
  components: l3,
  directives: l3,
  watch: function (e, t) {
    if (!e) return t;
    if (!t) return e;
    let n = C(Object.create(null), e);
    for (let l in t) n[l] = l8(e[l], t[l]);
    return n;
  },
  provide: l6,
  inject: function (e, t) {
    return l3(l4(e), l4(t));
  }
};
function l6(e, t) {
  return t ? e ? function () {
    return C(O(e) ? e.call(this, this) : e, O(t) ? t.call(this, this) : t);
  } : t : e;
}
function l4(e) {
  if (k(e)) {
    let t = {};
    for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
    return t;
  }
  return e;
}
function l8(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function l3(e, t) {
  return e ? C(Object.create(null), e, t) : t;
}
function l5(e, t) {
  return e ? k(e) && k(t) ? [...new Set([...e, ...t])] : C(Object.create(null), lq(e), lq(null != t ? t : {})) : t;
}
function l9() {
  return {
    app: null,
    config: {
      isNativeTag: y,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  };
}
let l7 = 0,
  re = null;
function rt(e, t) {
  if (iw) {
    let n = iw.provides,
      l = iw.parent && iw.parent.provides;
    l === n && (n = iw.provides = Object.create(l)), n[e] = t;
  }
}
function rn(e, t, n = !1) {
  let l = iw || ni;
  if (l || re) {
    let r = re ? re._context.provides : l ? null == l.parent ? l.vnode.appContext && l.vnode.appContext.provides : l.parent.provides : void 0;
    if (r && e in r) return r[e];
    if (arguments.length > 1) return n && O(t) ? t.call(l && l.proxy) : t;
  }
}
function rl() {
  return !!(iw || ni || re);
}
let rr = {},
  ri = () => Object.create(rr),
  rs = e => Object.getPrototypeOf(e) === rr;
function ro(e, t, n, l) {
  let r;
  let [i, s] = e.propsOptions,
    o = !1;
  if (t) for (let a in t) {
    let u;
    if (B(a)) continue;
    let c = t[a];
    i && w(i, u = W(a)) ? s && s.includes(u) ? (r || (r = {}))[u] = c : n[u] = c : rj(e.emitsOptions, a) || a in l && c === l[a] || (l[a] = c, o = !0);
  }
  if (s) {
    let t = tS(n),
      l = r || g;
    for (let r = 0; r < s.length; r++) {
      let o = s[r];
      n[o] = ra(i, t, o, l[o], e, !w(l, o));
    }
  }
  return o;
}
function ra(e, t, n, l, r, i) {
  let s = e[n];
  if (null != s) {
    let e = w(s, "default");
    if (e && void 0 === l) {
      let e = s.default;
      if (s.type !== Function && !s.skipFactory && O(e)) {
        let {
          propsDefaults: i
        } = r;
        if (n in i) l = i[n];else {
          let s = iT(r);
          l = i[n] = e.call(null, t), s();
        }
      } else l = e;
      r.ce && r.ce._setProp(n, l);
    }
    s[0] && (i && !e ? l = !1 : s[1] && ("" === l || l === z(n)) && (l = !0));
  }
  return l;
}
let ru = new WeakMap();
function rc(e) {
  return !("$" === e[0] || B(e));
}
let rf = e => "_" === e[0] || "$stable" === e,
  rp = e => k(e) ? e.map(im) : [im(e)],
  rd = (e, t, n) => {
    if (t._n) return t;
    let l = nf((...e) => rp(t(...e)), n);
    return l._c = !1, l;
  },
  rh = (e, t, n) => {
    let l = e._ctx;
    for (let n in e) {
      if (rf(n)) continue;
      let r = e[n];
      if (O(r)) t[n] = rd(n, r, l);else if (null != r) {
        let e = rp(r);
        t[n] = () => e;
      }
    }
  },
  rg = (e, t) => {
    let n = rp(t);
    e.slots.default = () => n;
  },
  rv = (e, t, n) => {
    for (let l in t) (n || "_" !== l) && (e[l] = t[l]);
  },
  rm = (e, t, n) => {
    let l = e.slots = ri();
    if (32 & e.vnode.shapeFlag) {
      let e = t._;
      e ? (rv(l, t, n), n && Z(l, "_", e, !0)) : rh(t, l);
    } else t && rg(e, t);
  },
  r_ = (e, t, n) => {
    let {
        vnode: l,
        slots: r
      } = e,
      i = !0,
      s = g;
    if (32 & l.shapeFlag) {
      let e = t._;
      e ? n && 1 === e ? i = !1 : rv(r, t, n) : (i = !t.$stable, rh(t, r)), s = t;
    } else t && (rg(e, t), s = {
      default: 1
    });
    if (i) for (let e in r) rf(e) || null != s[e] || delete r[e];
  },
  ry = rY;
function rb(e) {
  return rC(e);
}
function rS(e) {
  return rC(e, nZ);
}
function rC(e, t) {
  var n;
  let l, r;
  ee().__VUE__ = !0;
  let {
      insert: i,
      remove: s,
      patchProp: o,
      createElement: a,
      createText: u,
      createComment: c,
      setText: f,
      setElementText: p,
      parentNode: d,
      nextSibling: h,
      setScopeId: y = _,
      insertStaticContent: b
    } = e,
    S = (e, t, n, l = null, r = null, i = null, s, o = null, a = !!t.dynamicChildren) => {
      if (e === t) return;
      e && !ii(e, t) && (l = er(e), Y(e, r, i, !0), e = null), -2 === t.patchFlag && (a = !1, t.dynamicChildren = null);
      let {
        type: u,
        ref: c,
        shapeFlag: f
      } = t;
      switch (u) {
        case r1:
          x(e, t, n, l);
          break;
        case r2:
          E(e, t, n, l);
          break;
        case r6:
          null == e && k(t, n, l, s);
          break;
        case r0:
          V(e, t, n, l, r, i, s, o, a);
          break;
        default:
          1 & f ? R(e, t, n, l, r, i, s, o, a) : 6 & f ? U(e, t, n, l, r, i, s, o, a) : 64 & f ? u.process(e, t, n, l, r, i, s, o, a, eo) : 128 & f && u.process(e, t, n, l, r, i, s, o, a, eo);
      }
      null != c && r && nW(c, e && e.ref, i, t || e, !t);
    },
    x = (e, t, n, l) => {
      if (null == e) i(t.el = u(t.children), n, l);else {
        let n = t.el = e.el;
        t.children !== e.children && f(n, t.children);
      }
    },
    E = (e, t, n, l) => {
      null == e ? i(t.el = c(t.children || ""), n, l) : t.el = e.el;
    },
    k = (e, t, n, l) => {
      [e.el, e.anchor] = b(e.children, t, n, l, e.el, e.anchor);
    },
    T = ({
      el: e,
      anchor: t
    }, n, l) => {
      let r;
      for (; e && e !== t;) r = h(e), i(e, n, l), e = r;
      i(t, n, l);
    },
    A = ({
      el: e,
      anchor: t
    }) => {
      let n;
      for (; e && e !== t;) n = h(e), s(e), e = n;
      s(t);
    },
    R = (e, t, n, l, r, i, s, o, a) => {
      "svg" === t.type ? s = "svg" : "math" === t.type && (s = "mathml"), null == e ? N(t, n, l, r, i, s, o, a) : L(e, t, r, i, s, o, a);
    },
    N = (e, t, n, l, r, s, u, c) => {
      let f, d;
      let {
        props: h,
        shapeFlag: g,
        transition: m,
        dirs: _
      } = e;
      if (f = e.el = a(e.type, s, h && h.is, h), 8 & g ? p(f, e.children) : 16 & g && M(e.children, f, null, l, r, rx(e, s), u, c), _ && nd(e, null, l, "created"), P(f, e, e.scopeId, u, l), h) {
        for (let e in h) "value" === e || B(e) || o(f, e, null, h[e], s, l);
        "value" in h && o(f, "value", null, h.value, s), (d = h.onVnodeBeforeMount) && iS(d, l, e);
      }
      _ && nd(e, null, l, "beforeMount");
      let y = rw(r, m);
      y && m.beforeEnter(f), i(f, t, n), ((d = h && h.onVnodeMounted) || y || _) && ry(() => {
        d && iS(d, l, e), y && m.enter(f), _ && nd(e, null, l, "mounted");
      }, r);
    },
    P = (e, t, n, l, r) => {
      if (n && y(e, n), l) for (let t = 0; t < l.length; t++) y(e, l[t]);
      if (r) {
        let n = r.subTree;
        if (t === n || rz(n.type) && (n.ssContent === t || n.ssFallback === t)) {
          let t = r.vnode;
          P(e, t, t.scopeId, t.slotScopeIds, r.parent);
        }
      }
    },
    M = (e, t, n, l, r, i, s, o, a = 0) => {
      for (let u = a; u < e.length; u++) S(null, e[u] = o ? i_(e[u]) : im(e[u]), t, n, l, r, i, s, o);
    },
    L = (e, t, n, l, r, i, s) => {
      let a;
      let u = t.el = e.el,
        {
          patchFlag: c,
          dynamicChildren: f,
          dirs: d
        } = t;
      c |= 16 & e.patchFlag;
      let h = e.props || g,
        m = t.props || g;
      if (n && rE(n, !1), (a = m.onVnodeBeforeUpdate) && iS(a, n, t, e), d && nd(t, e, n, "beforeUpdate"), n && rE(n, !0), (h.innerHTML && null == m.innerHTML || h.textContent && null == m.textContent) && p(u, ""), f ? D(e.dynamicChildren, f, u, n, l, rx(t, r), i) : s || q(e, t, u, null, n, l, rx(t, r), i, !1), c > 0) {
        if (16 & c) F(u, h, m, n, r);else if (2 & c && h.class !== m.class && o(u, "class", null, m.class, r), 4 & c && o(u, "style", h.style, m.style, r), 8 & c) {
          let e = t.dynamicProps;
          for (let t = 0; t < e.length; t++) {
            let l = e[t],
              i = h[l],
              s = m[l];
            (s !== i || "value" === l) && o(u, l, i, s, r, n);
          }
        }
        1 & c && e.children !== t.children && p(u, t.children);
      } else s || null != f || F(u, h, m, n, r);
      ((a = m.onVnodeUpdated) || d) && ry(() => {
        a && iS(a, n, t, e), d && nd(t, e, n, "updated");
      }, l);
    },
    D = (e, t, n, l, r, i, s) => {
      for (let o = 0; o < t.length; o++) {
        let a = e[o],
          u = t[o],
          c = a.el && (a.type === r0 || !ii(a, u) || 70 & a.shapeFlag) ? d(a.el) : n;
        S(a, u, c, null, l, r, i, s, !0);
      }
    },
    F = (e, t, n, l, r) => {
      if (t !== n) {
        if (t !== g) for (let i in t) B(i) || i in n || o(e, i, t[i], null, r, l);
        for (let i in n) {
          if (B(i)) continue;
          let s = n[i],
            a = t[i];
          s !== a && "value" !== i && o(e, i, a, s, r, l);
        }
        "value" in n && o(e, "value", t.value, n.value, r);
      }
    },
    V = (e, t, n, l, r, s, o, a, c) => {
      let f = t.el = e ? e.el : u(""),
        p = t.anchor = e ? e.anchor : u(""),
        {
          patchFlag: d,
          dynamicChildren: h,
          slotScopeIds: g
        } = t;
      g && (a = a ? a.concat(g) : g), null == e ? (i(f, n, l), i(p, n, l), M(t.children || [], n, p, r, s, o, a, c)) : d > 0 && 64 & d && h && e.dynamicChildren ? (D(e.dynamicChildren, h, n, r, s, o, a), (null != t.key || r && t === r.subTree) && rk(e, t, !0)) : q(e, t, n, p, r, s, o, a, c);
    },
    U = (e, t, n, l, r, i, s, o, a) => {
      t.slotScopeIds = o, null == e ? 512 & t.shapeFlag ? r.ctx.activate(t, n, l, s, a) : j(t, n, l, r, i, s, a) : $(e, t, a);
    },
    j = (e, t, n, l, r, i, s) => {
      let o = e.component = iE(e, l, r);
      le(e) && (o.ctx.renderer = eo), iO(o, !1, s), o.asyncDep ? (r && r.registerDep(o, H, s), e.el || E(null, o.subTree = ic(r2), t, n)) : H(o, e, t, n, r, i, s);
    },
    $ = (e, t, n) => {
      let l = t.component = e.component;
      if (function (e, t, n) {
        let {
            props: l,
            children: r,
            component: i
          } = e,
          {
            props: s,
            children: o,
            patchFlag: a
          } = t,
          u = i.emitsOptions;
        if (t.dirs || t.transition) return !0;
        if (!n || !(a >= 0)) return (!!r || !!o) && (!o || !o.$stable) || l !== s && (l ? !s || rW(l, s, u) : !!s);
        if (1024 & a) return !0;
        if (16 & a) return l ? rW(l, s, u) : !!s;
        if (8 & a) {
          let e = t.dynamicProps;
          for (let t = 0; t < e.length; t++) {
            let n = e[t];
            if (s[n] !== l[n] && !rj(u, n)) return !0;
          }
        }
        return !1;
      }(e, t, n)) {
        if (l.asyncDep && !l.asyncResolved) {
          K(l, t, n);
          return;
        }
        l.next = t, l.update();
      } else t.el = e.el, l.vnode = t;
    },
    H = (e, t, n, l, i, s, o) => {
      let a = () => {
        if (e.isMounted) {
          let t,
            {
              next: n,
              bu: l,
              u: r,
              parent: u,
              vnode: c
            } = e;
          {
            let t = function e(t) {
              let n = t.subTree.component;
              if (n) return n.asyncDep && !n.asyncResolved ? n : e(n);
            }(e);
            if (t) {
              n && (n.el = c.el, K(e, n, o)), t.asyncDep.then(() => {
                e.isUnmounted || a();
              });
              return;
            }
          }
          let f = n;
          rE(e, !1), n ? (n.el = c.el, K(e, n, o)) : n = c, l && X(l), (t = n.props && n.props.onVnodeBeforeUpdate) && iS(t, u, n, c), rE(e, !0);
          let p = rB(e),
            h = e.subTree;
          e.subTree = p, S(h, p, d(h.el), er(h), e, i, s), n.el = p.el, null === f && rK(e, p.el), r && ry(r, i), (t = n.props && n.props.onVnodeUpdated) && ry(() => iS(t, u, n, c), i);
        } else {
          let o;
          let {
              el: a,
              props: u
            } = t,
            {
              bm: c,
              m: f,
              parent: p,
              root: d,
              type: h
            } = e,
            g = n5(t);
          if (rE(e, !1), c && X(c), !g && (o = u && u.onVnodeBeforeMount) && iS(o, p, t), rE(e, !0), a && r) {
            let t = () => {
              e.subTree = rB(e), r(a, e.subTree, e, i, null);
            };
            g && h.__asyncHydrate ? h.__asyncHydrate(a, e, t) : t();
          } else {
            d.ce && d.ce._injectChildStyle(h);
            let r = e.subTree = rB(e);
            S(null, r, n, l, e, i, s), t.el = r.el;
          }
          if (f && ry(f, i), !g && (o = u && u.onVnodeMounted)) {
            let e = t;
            ry(() => iS(o, p, e), i);
          }
          (256 & t.shapeFlag || p && n5(p.vnode) && 256 & p.vnode.shapeFlag) && e.a && ry(e.a, i), e.isMounted = !0, t = n = l = null;
        }
      };
      e.scope.on();
      let u = e.effect = new eb(a);
      e.scope.off();
      let c = e.update = u.run.bind(u),
        f = e.job = u.runIfDirty.bind(u);
      f.i = e, f.id = e.uid, u.scheduler = () => t7(f), rE(e, !0), c();
    },
    K = (e, t, n) => {
      t.component = e;
      let l = e.vnode.props;
      e.vnode = t, e.next = null, function (e, t, n, l) {
        let {
            props: r,
            attrs: i,
            vnode: {
              patchFlag: s
            }
          } = e,
          o = tS(r),
          [a] = e.propsOptions,
          u = !1;
        if ((l || s > 0) && !(16 & s)) {
          if (8 & s) {
            let n = e.vnode.dynamicProps;
            for (let l = 0; l < n.length; l++) {
              let s = n[l];
              if (rj(e.emitsOptions, s)) continue;
              let c = t[s];
              if (a) {
                if (w(i, s)) c !== i[s] && (i[s] = c, u = !0);else {
                  let t = W(s);
                  r[t] = ra(a, o, t, c, e, !1);
                }
              } else c !== i[s] && (i[s] = c, u = !0);
            }
          }
        } else {
          let l;
          for (let s in ro(e, t, r, i) && (u = !0), o) t && (w(t, s) || (l = z(s)) !== s && w(t, l)) || (a ? n && (void 0 !== n[s] || void 0 !== n[l]) && (r[s] = ra(a, o, s, void 0, e, !0)) : delete r[s]);
          if (i !== o) for (let e in i) t && w(t, e) || (delete i[e], u = !0);
        }
        u && eW(e.attrs, "set", "");
      }(e, t.props, l, n), r_(e, t.children, n), eM(), nn(e), eI();
    },
    q = (e, t, n, l, r, i, s, o, a = !1) => {
      let u = e && e.children,
        c = e ? e.shapeFlag : 0,
        f = t.children,
        {
          patchFlag: d,
          shapeFlag: h
        } = t;
      if (d > 0) {
        if (128 & d) {
          J(u, f, n, l, r, i, s, o, a);
          return;
        }
        if (256 & d) {
          G(u, f, n, l, r, i, s, o, a);
          return;
        }
      }
      8 & h ? (16 & c && el(u, r, i), f !== u && p(n, f)) : 16 & c ? 16 & h ? J(u, f, n, l, r, i, s, o, a) : el(u, r, i, !0) : (8 & c && p(n, ""), 16 & h && M(f, n, l, r, i, s, o, a));
    },
    G = (e, t, n, l, r, i, s, o, a) => {
      let u;
      e = e || m, t = t || m;
      let c = e.length,
        f = t.length,
        p = Math.min(c, f);
      for (u = 0; u < p; u++) {
        let l = t[u] = a ? i_(t[u]) : im(t[u]);
        S(e[u], l, n, null, r, i, s, o, a);
      }
      c > f ? el(e, r, i, !0, !1, p) : M(t, n, l, r, i, s, o, a, p);
    },
    J = (e, t, n, l, r, i, s, o, a) => {
      let u = 0,
        c = t.length,
        f = e.length - 1,
        p = c - 1;
      for (; u <= f && u <= p;) {
        let l = e[u],
          c = t[u] = a ? i_(t[u]) : im(t[u]);
        if (ii(l, c)) S(l, c, n, null, r, i, s, o, a);else break;
        u++;
      }
      for (; u <= f && u <= p;) {
        let l = e[f],
          u = t[p] = a ? i_(t[p]) : im(t[p]);
        if (ii(l, u)) S(l, u, n, null, r, i, s, o, a);else break;
        f--, p--;
      }
      if (u > f) {
        if (u <= p) {
          let e = p + 1,
            f = e < c ? t[e].el : l;
          for (; u <= p;) S(null, t[u] = a ? i_(t[u]) : im(t[u]), n, f, r, i, s, o, a), u++;
        }
      } else if (u > p) for (; u <= f;) Y(e[u], r, i, !0), u++;else {
        let d;
        let h = u,
          g = u,
          _ = new Map();
        for (u = g; u <= p; u++) {
          let e = t[u] = a ? i_(t[u]) : im(t[u]);
          null != e.key && _.set(e.key, u);
        }
        let y = 0,
          b = p - g + 1,
          C = !1,
          x = 0,
          E = Array(b);
        for (u = 0; u < b; u++) E[u] = 0;
        for (u = h; u <= f; u++) {
          let l;
          let c = e[u];
          if (y >= b) {
            Y(c, r, i, !0);
            continue;
          }
          if (null != c.key) l = _.get(c.key);else for (d = g; d <= p; d++) if (0 === E[d - g] && ii(c, t[d])) {
            l = d;
            break;
          }
          void 0 === l ? Y(c, r, i, !0) : (E[l - g] = u + 1, l >= x ? x = l : C = !0, S(c, t[l], n, null, r, i, s, o, a), y++);
        }
        let w = C ? function (e) {
          let t, n, l, r, i;
          let s = e.slice(),
            o = [0],
            a = e.length;
          for (t = 0; t < a; t++) {
            let a = e[t];
            if (0 !== a) {
              if (e[n = o[o.length - 1]] < a) {
                s[t] = n, o.push(t);
                continue;
              }
              for (l = 0, r = o.length - 1; l < r;) e[o[i = l + r >> 1]] < a ? l = i + 1 : r = i;
              a < e[o[l]] && (l > 0 && (s[t] = o[l - 1]), o[l] = t);
            }
          }
          for (l = o.length, r = o[l - 1]; l-- > 0;) o[l] = r, r = s[r];
          return o;
        }(E) : m;
        for (d = w.length - 1, u = b - 1; u >= 0; u--) {
          let e = g + u,
            f = t[e],
            p = e + 1 < c ? t[e + 1].el : l;
          0 === E[u] ? S(null, f, n, p, r, i, s, o, a) : C && (d < 0 || u !== w[d] ? Z(f, n, p, 2) : d--);
        }
      }
    },
    Z = (e, t, n, l, r = null) => {
      let {
        el: s,
        type: o,
        transition: a,
        children: u,
        shapeFlag: c
      } = e;
      if (6 & c) {
        Z(e.component.subTree, t, n, l);
        return;
      }
      if (128 & c) {
        e.suspense.move(t, n, l);
        return;
      }
      if (64 & c) {
        o.move(e, t, n, eo);
        return;
      }
      if (o === r0) {
        i(s, t, n);
        for (let e = 0; e < u.length; e++) Z(u[e], t, n, l);
        i(e.anchor, t, n);
        return;
      }
      if (o === r6) {
        T(e, t, n);
        return;
      }
      if (2 !== l && 1 & c && a) {
        if (0 === l) a.beforeEnter(s), i(s, t, n), ry(() => a.enter(s), r);else {
          let {
              leave: e,
              delayLeave: l,
              afterLeave: r
            } = a,
            o = () => i(s, t, n),
            u = () => {
              e(s, () => {
                o(), r && r();
              });
            };
          l ? l(s, o, u) : u();
        }
      } else i(s, t, n);
    },
    Y = (e, t, n, l = !1, r = !1) => {
      let i;
      let {
        type: s,
        props: o,
        ref: a,
        children: u,
        dynamicChildren: c,
        shapeFlag: f,
        patchFlag: p,
        dirs: d,
        cacheIndex: h
      } = e;
      if (-2 === p && (r = !1), null != a && nW(a, null, n, e, !0), null != h && (t.renderCache[h] = void 0), 256 & f) {
        t.ctx.deactivate(e);
        return;
      }
      let g = 1 & f && d,
        m = !n5(e);
      if (m && (i = o && o.onVnodeBeforeUnmount) && iS(i, t, e), 6 & f) en(e.component, n, l);else {
        if (128 & f) {
          e.suspense.unmount(n, l);
          return;
        }
        g && nd(e, null, t, "beforeUnmount"), 64 & f ? e.type.remove(e, t, n, eo, l) : c && !c.hasOnce && (s !== r0 || p > 0 && 64 & p) ? el(c, t, n, !1, !0) : (s === r0 && 384 & p || !r && 16 & f) && el(u, t, n), l && Q(e);
      }
      (m && (i = o && o.onVnodeUnmounted) || g) && ry(() => {
        i && iS(i, t, e), g && nd(e, null, t, "unmounted");
      }, n);
    },
    Q = e => {
      let {
        type: t,
        el: n,
        anchor: l,
        transition: r
      } = e;
      if (t === r0) {
        et(n, l);
        return;
      }
      if (t === r6) {
        A(e);
        return;
      }
      let i = () => {
        s(n), r && !r.persisted && r.afterLeave && r.afterLeave();
      };
      if (1 & e.shapeFlag && r && !r.persisted) {
        let {
            leave: t,
            delayLeave: l
          } = r,
          s = () => t(n, i);
        l ? l(e.el, i, s) : s();
      } else i();
    },
    et = (e, t) => {
      let n;
      for (; e !== t;) n = h(e), s(e), e = n;
      s(t);
    },
    en = (e, t, n) => {
      let {
        bum: l,
        scope: r,
        job: i,
        subTree: s,
        um: o,
        m: a,
        a: u
      } = e;
      rT(a), rT(u), l && X(l), r.stop(), i && (i.flags |= 8, Y(s, e, t, n)), o && ry(o, t), ry(() => {
        e.isUnmounted = !0;
      }, t), t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--, 0 === t.deps && t.resolve());
    },
    el = (e, t, n, l = !1, r = !1, i = 0) => {
      for (let s = i; s < e.length; s++) Y(e[s], t, n, l, r);
    },
    er = e => {
      if (6 & e.shapeFlag) return er(e.component.subTree);
      if (128 & e.shapeFlag) return e.suspense.next();
      let t = h(e.anchor || e.el),
        n = t && t[nh];
      return n ? h(n) : t;
    },
    ei = !1,
    es = (e, t, n) => {
      null == e ? t._vnode && Y(t._vnode, null, null, !0) : S(t._vnode || null, e, t, null, null, null, n), t._vnode = e, ei || (ei = !0, nn(), nl(), ei = !1);
    },
    eo = {
      p: S,
      um: Y,
      m: Z,
      r: Q,
      mt: j,
      mc: M,
      pc: q,
      pbc: D,
      n: er,
      o: e
    };
  return t && ([l, r] = t(eo)), {
    render: es,
    hydrate: l,
    createApp: (n = l, function (e, t = null) {
      O(e) || (e = C({}, e)), null == t || I(t) || (t = null);
      let l = l9(),
        r = new WeakSet(),
        i = [],
        s = !1,
        o = l.app = {
          _uid: l7++,
          _component: e,
          _props: t,
          _container: null,
          _context: l,
          _instance: null,
          version: iK,
          get config() {
            return l.config;
          },
          set config(v) {},
          use: (e, ...t) => (r.has(e) || (e && O(e.install) ? (r.add(e), e.install(o, ...t)) : O(e) && (r.add(e), e(o, ...t))), o),
          mixin: e => (l.mixins.includes(e) || l.mixins.push(e), o),
          component: (e, t) => t ? (l.components[e] = t, o) : l.components[e],
          directive: (e, t) => t ? (l.directives[e] = t, o) : l.directives[e],
          mount(r, i, a) {
            if (!s) {
              let u = o._ceVNode || ic(e, t);
              return u.appContext = l, !0 === a ? a = "svg" : !1 === a && (a = void 0), i && n ? n(u, r) : es(u, r, a), s = !0, o._container = r, r.__vue_app__ = o, iV(u.component);
            }
          },
          onUnmount(e) {
            i.push(e);
          },
          unmount() {
            s && (tQ(i, o._instance, 16), es(null, o._container), delete o._container.__vue_app__);
          },
          provide: (e, t) => (l.provides[e] = t, o),
          runWithContext(e) {
            let t = re;
            re = o;
            try {
              return e();
            } finally {
              re = t;
            }
          }
        };
      return o;
    })
  };
}
function rx({
  type: e,
  props: t
}, n) {
  return "svg" === n && "foreignObject" === e || "mathml" === n && "annotation-xml" === e && t && t.encoding && t.encoding.includes("html") ? void 0 : n;
}
function rE({
  effect: e,
  job: t
}, n) {
  n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5);
}
function rw(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted;
}
function rk(e, t, n = !1) {
  let l = e.children,
    r = t.children;
  if (k(l) && k(r)) for (let e = 0; e < l.length; e++) {
    let t = l[e],
      i = r[e];
    !(1 & i.shapeFlag) || i.dynamicChildren || ((i.patchFlag <= 0 || 32 === i.patchFlag) && ((i = r[e] = i_(r[e])).el = t.el), n || -2 === i.patchFlag || rk(t, i)), i.type === r1 && (i.el = t.el);
  }
}
function rT(e) {
  if (e) for (let t = 0; t < e.length; t++) e[t].flags |= 8;
}
let rA = Symbol.for("v-scx"),
  rR = () => rn(rA);
function rN(e, t) {
  return rI(e, null, t);
}
function rO(e, t) {
  return rI(e, null, {
    flush: "post"
  });
}
function rP(e, t) {
  return rI(e, null, {
    flush: "sync"
  });
}
function rM(e, t, n) {
  return rI(e, t, n);
}
function rI(e, t, n = g) {
  let l;
  let {
      immediate: r,
      deep: i,
      flush: s,
      once: o
    } = n,
    a = C({}, n),
    u = t && r || !t && "post" !== s;
  if (iN) {
    if ("sync" === s) {
      let e = rR();
      l = e.__watcherHandles || (e.__watcherHandles = []);
    } else if (!u) {
      let e = () => {};
      return e.stop = _, e.resume = _, e.pause = _, e;
    }
  }
  let c = iw;
  a.call = (e, t, n) => tQ(e, c, t, n);
  let f = !1;
  "post" === s ? a.scheduler = e => {
    ry(e, c && c.suspense);
  } : "sync" !== s && (f = !0, a.scheduler = (e, t) => {
    t ? e() : t7(e);
  }), a.augmentJob = e => {
    t && (e.flags |= 4), f && (e.flags |= 2, c && (e.id = c.uid, e.i = c));
  };
  let d = function (e, t, n = g) {
    let l, r, i, s;
    let {
        immediate: o,
        deep: a,
        once: u,
        scheduler: c,
        augmentJob: f,
        call: d
      } = n,
      h = e => a ? e : ty(e) || !1 === a || 0 === a ? tJ(e, 1) : tJ(e),
      m = !1,
      y = !1;
    if (tw(e) ? (r = () => e.value, m = ty(e)) : tm(e) ? (r = () => h(e), m = !0) : k(e) ? (y = !0, m = e.some(e => tm(e) || ty(e)), r = () => e.map(e => tw(e) ? e.value : tm(e) ? h(e) : O(e) ? d ? d(e, 2) : e() : void 0)) : r = O(e) ? t ? d ? () => d(e, 2) : e : () => {
      if (i) {
        eM();
        try {
          i();
        } finally {
          eI();
        }
      }
      let t = p;
      p = l;
      try {
        return d ? d(e, 3, [s]) : e(s);
      } finally {
        p = t;
      }
    } : _, t && a) {
      let e = r,
        t = !0 === a ? 1 / 0 : a;
      r = () => tJ(e(), t);
    }
    let b = em(),
      S = () => {
        l.stop(), b && b.active && x(b.effects, l);
      };
    if (u && t) {
      let e = t;
      t = (...t) => {
        e(...t), S();
      };
    }
    let C = y ? Array(e.length).fill(tK) : tK,
      E = e => {
        if (1 & l.flags && (l.dirty || e)) {
          if (t) {
            let e = l.run();
            if (a || m || (y ? e.some((e, t) => J(e, C[t])) : J(e, C))) {
              i && i();
              let n = p;
              p = l;
              try {
                let n = [e, C === tK ? void 0 : y && C[0] === tK ? [] : C, s];
                d ? d(t, 3, n) : t(...n), C = e;
              } finally {
                p = n;
              }
            }
          } else l.run();
        }
      };
    return f && f(E), (l = new eb(r)).scheduler = c ? () => c(E, !1) : E, s = e => tG(e, !1, l), i = l.onStop = () => {
      let e = tz.get(l);
      if (e) {
        if (d) d(e, 4);else for (let t of e) t();
        tz.delete(l);
      }
    }, t ? o ? E(!0) : C = l.run() : c ? c(E.bind(null, !0), !0) : l.run(), S.pause = l.pause.bind(l), S.resume = l.resume.bind(l), S.stop = S, S;
  }(e, t, a);
  return iN && (l ? l.push(d) : u && d()), d;
}
function rL(e, t, n) {
  let l;
  let r = this.proxy,
    i = P(e) ? e.includes(".") ? rD(r, e) : () => r[e] : e.bind(r, r);
  O(t) ? l = t : (l = t.handler, n = t);
  let s = iT(this),
    o = rI(i, l.bind(r), n);
  return s(), o;
}
function rD(e, t) {
  let n = t.split(".");
  return () => {
    let t = e;
    for (let e = 0; e < n.length && t; e++) t = t[n[e]];
    return t;
  };
}
function rF(e, t, n = g) {
  let l = ik(),
    r = W(t),
    i = z(t),
    s = rV(e, r),
    o = tD((s, o) => {
      let a, u;
      let c = g;
      return rP(() => {
        let t = e[r];
        J(a, t) && (a = t, o());
      }), {
        get: () => (s(), n.get ? n.get(a) : a),
        set(e) {
          let s = n.set ? n.set(e) : e;
          if (!J(s, a) && !(c !== g && J(e, c))) return;
          let f = l.vnode.props;
          f && (t in f || r in f || i in f) && (`onUpdate:${t}` in f || `onUpdate:${r}` in f || `onUpdate:${i}` in f) || (a = e, o()), l.emit(`update:${t}`, s), J(e, s) && J(e, c) && !J(s, u) && o(), c = e, u = s;
        }
      };
    });
  return o[Symbol.iterator] = () => {
    let e = 0;
    return {
      next: () => e < 2 ? {
        value: e++ ? s || g : o,
        done: !1
      } : {
        done: !0
      }
    };
  }, o;
}
let rV = (e, t) => "modelValue" === t || "model-value" === t ? e.modelModifiers : e[`${t}Modifiers`] || e[`${W(t)}Modifiers`] || e[`${z(t)}Modifiers`];
function rU(e, t, ...n) {
  let l;
  if (e.isUnmounted) return;
  let r = e.vnode.props || g,
    i = n,
    s = t.startsWith("update:"),
    o = s && rV(r, t.slice(7));
  o && (o.trim && (i = n.map(e => P(e) ? e.trim() : e)), o.number && (i = n.map(Y)));
  let a = r[l = G(t)] || r[l = G(W(t))];
  !a && s && (a = r[l = G(z(t))]), a && tQ(a, e, 6, i);
  let u = r[l + "Once"];
  if (u) {
    if (e.emitted) {
      if (e.emitted[l]) return;
    } else e.emitted = {};
    e.emitted[l] = !0, tQ(u, e, 6, i);
  }
}
function rj(e, t) {
  return !!(e && b(t)) && (w(e, (t = t.slice(2).replace(/Once$/, ""))[0].toLowerCase() + t.slice(1)) || w(e, z(t)) || w(e, t));
}
function rB(e) {
  let t, n;
  let {
      type: l,
      vnode: r,
      proxy: i,
      withProxy: s,
      propsOptions: [o],
      slots: a,
      attrs: u,
      emit: c,
      render: f,
      renderCache: p,
      props: d,
      data: h,
      setupState: g,
      ctx: m,
      inheritAttrs: _
    } = e,
    y = no(e);
  try {
    if (4 & r.shapeFlag) {
      let e = s || i;
      t = im(f.call(e, e, p, d, g, h, m)), n = u;
    } else t = im(l.length > 1 ? l(d, {
      attrs: u,
      slots: a,
      emit: c
    }) : l(d, null)), n = l.props ? u : r$(u);
  } catch (n) {
    r4.length = 0, t0(n, e, 1), t = ic(r2);
  }
  let b = t;
  if (n && !1 !== _) {
    let e = Object.keys(n),
      {
        shapeFlag: t
      } = b;
    e.length && 7 & t && (o && e.some(S) && (n = rH(n, o)), b = id(b, n, !1, !0));
  }
  return r.dirs && ((b = id(b, null, !1, !0)).dirs = b.dirs ? b.dirs.concat(r.dirs) : r.dirs), r.transition && nV(b, r.transition), t = b, no(y), t;
}
let r$ = e => {
    let t;
    for (let n in e) ("class" === n || "style" === n || b(n)) && ((t || (t = {}))[n] = e[n]);
    return t;
  },
  rH = (e, t) => {
    let n = {};
    for (let l in e) S(l) && l.slice(9) in t || (n[l] = e[l]);
    return n;
  };
function rW(e, t, n) {
  let l = Object.keys(t);
  if (l.length !== Object.keys(e).length) return !0;
  for (let r = 0; r < l.length; r++) {
    let i = l[r];
    if (t[i] !== e[i] && !rj(n, i)) return !0;
  }
  return !1;
}
function rK({
  vnode: e,
  parent: t
}, n) {
  for (; t;) {
    let l = t.subTree;
    if (l.suspense && l.suspense.activeBranch === e && (l.el = e.el), l === e) (e = t.vnode).el = n, t = t.parent;else break;
  }
}
let rz = e => e.__isSuspense,
  rq = 0,
  rG = {
    name: "Suspense",
    __isSuspense: !0,
    process(e, t, n, l, r, i, s, o, a, u) {
      if (null == e) !function (e, t, n, l, r, i, s, o, a) {
        let {
            p: u,
            o: {
              createElement: c
            }
          } = a,
          f = c("div"),
          p = e.suspense = rX(e, r, l, t, f, n, i, s, o, a);
        u(null, p.pendingBranch = e.ssContent, f, null, l, p, i, s), p.deps > 0 ? (rJ(e, "onPending"), rJ(e, "onFallback"), u(null, e.ssFallback, t, n, l, null, i, s), rQ(p, e.ssFallback)) : p.resolve(!1, !0);
      }(t, n, l, r, i, s, o, a, u);else {
        if (i && i.deps > 0 && !e.suspense.isInFallback) {
          t.suspense = e.suspense, t.suspense.vnode = t, t.el = e.el;
          return;
        }
        !function (e, t, n, l, r, i, s, o, {
          p: a,
          um: u,
          o: {
            createElement: c
          }
        }) {
          let f = t.suspense = e.suspense;
          f.vnode = t, t.el = e.el;
          let p = t.ssContent,
            d = t.ssFallback,
            {
              activeBranch: h,
              pendingBranch: g,
              isInFallback: m,
              isHydrating: _
            } = f;
          if (g) f.pendingBranch = p, ii(p, g) ? (a(g, p, f.hiddenContainer, null, r, f, i, s, o), f.deps <= 0 ? f.resolve() : m && !_ && (a(h, d, n, l, r, null, i, s, o), rQ(f, d))) : (f.pendingId = rq++, _ ? (f.isHydrating = !1, f.activeBranch = g) : u(g, r, f), f.deps = 0, f.effects.length = 0, f.hiddenContainer = c("div"), m ? (a(null, p, f.hiddenContainer, null, r, f, i, s, o), f.deps <= 0 ? f.resolve() : (a(h, d, n, l, r, null, i, s, o), rQ(f, d))) : h && ii(p, h) ? (a(h, p, n, l, r, f, i, s, o), f.resolve(!0)) : (a(null, p, f.hiddenContainer, null, r, f, i, s, o), f.deps <= 0 && f.resolve()));else if (h && ii(p, h)) a(h, p, n, l, r, f, i, s, o), rQ(f, p);else if (rJ(t, "onPending"), f.pendingBranch = p, 512 & p.shapeFlag ? f.pendingId = p.component.suspenseId : f.pendingId = rq++, a(null, p, f.hiddenContainer, null, r, f, i, s, o), f.deps <= 0) f.resolve();else {
            let {
              timeout: e,
              pendingId: t
            } = f;
            e > 0 ? setTimeout(() => {
              f.pendingId === t && f.fallback(d);
            }, e) : 0 === e && f.fallback(d);
          }
        }(e, t, n, l, r, s, o, a, u);
      }
    },
    hydrate: function (e, t, n, l, r, i, s, o, a) {
      let u = t.suspense = rX(t, l, n, e.parentNode, document.createElement("div"), null, r, i, s, o, !0),
        c = a(e, u.pendingBranch = t.ssContent, n, u, i, s);
      return 0 === u.deps && u.resolve(!1, !0), c;
    },
    normalize: function (e) {
      let {
          shapeFlag: t,
          children: n
        } = e,
        l = 32 & t;
      e.ssContent = rZ(l ? n.default : n), e.ssFallback = l ? rZ(n.fallback) : ic(r2);
    }
  };
function rJ(e, t) {
  let n = e.props && e.props[t];
  O(n) && n();
}
function rX(e, t, n, l, r, i, s, o, a, u, c = !1) {
  let f;
  let {
      p: p,
      m: d,
      um: h,
      n: g,
      o: {
        parentNode: m,
        remove: _
      }
    } = u,
    y = function (e) {
      let t = e.props && e.props.suspensible;
      return null != t && !1 !== t;
    }(e);
  y && t && t.pendingBranch && (f = t.pendingId, t.deps++);
  let b = e.props ? Q(e.props.timeout) : void 0,
    S = i,
    C = {
      vnode: e,
      parent: t,
      parentComponent: n,
      namespace: s,
      container: l,
      hiddenContainer: r,
      deps: 0,
      pendingId: rq++,
      timeout: "number" == typeof b ? b : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !c,
      isHydrating: c,
      isUnmounted: !1,
      effects: [],
      resolve(e = !1, n = !1) {
        let {
            vnode: l,
            activeBranch: r,
            pendingBranch: s,
            pendingId: o,
            effects: a,
            parentComponent: u,
            container: c
          } = C,
          p = !1;
        C.isHydrating ? C.isHydrating = !1 : e || ((p = r && s.transition && "out-in" === s.transition.mode) && (r.transition.afterLeave = () => {
          o === C.pendingId && (d(s, c, i === S ? g(r) : i, 0), nt(a));
        }), r && (m(r.el) === c && (i = g(r)), h(r, u, C, !0)), p || d(s, c, i, 0)), rQ(C, s), C.pendingBranch = null, C.isInFallback = !1;
        let _ = C.parent,
          b = !1;
        for (; _;) {
          if (_.pendingBranch) {
            _.effects.push(...a), b = !0;
            break;
          }
          _ = _.parent;
        }
        b || p || nt(a), C.effects = [], y && t && t.pendingBranch && f === t.pendingId && (t.deps--, 0 !== t.deps || n || t.resolve()), rJ(l, "onResolve");
      },
      fallback(e) {
        if (!C.pendingBranch) return;
        let {
          vnode: t,
          activeBranch: n,
          parentComponent: l,
          container: r,
          namespace: i
        } = C;
        rJ(t, "onFallback");
        let s = g(n),
          u = () => {
            C.isInFallback && (p(null, e, r, s, l, null, i, o, a), rQ(C, e));
          },
          c = e.transition && "out-in" === e.transition.mode;
        c && (n.transition.afterLeave = u), C.isInFallback = !0, h(n, l, null, !0), c || u();
      },
      move(e, t, n) {
        C.activeBranch && d(C.activeBranch, e, t, n), C.container = e;
      },
      next: () => C.activeBranch && g(C.activeBranch),
      registerDep(e, t, n) {
        let l = !!C.pendingBranch;
        l && C.deps++;
        let r = e.vnode.el;
        e.asyncDep.catch(t => {
          t0(t, e, 0);
        }).then(i => {
          if (e.isUnmounted || C.isUnmounted || C.pendingId !== e.suspenseId) return;
          e.asyncResolved = !0;
          let {
            vnode: o
          } = e;
          iP(e, i, !1), r && (o.el = r);
          let a = !r && e.subTree.el;
          t(e, o, m(r || e.subTree.el), r ? null : g(e.subTree), C, s, n), a && _(a), rK(e, o.el), l && 0 == --C.deps && C.resolve();
        });
      },
      unmount(e, t) {
        C.isUnmounted = !0, C.activeBranch && h(C.activeBranch, n, e, t), C.pendingBranch && h(C.pendingBranch, n, e, t);
      }
    };
  return C;
}
function rZ(e) {
  let t;
  if (O(e)) {
    let n = r9 && e._c;
    n && (e._d = !1, r3()), e = e(), n && (e._d = !0, t = r8, r5());
  }
  return k(e) && (e = function (e, t = !0) {
    let n;
    for (let t = 0; t < e.length; t++) {
      let l = e[t];
      if (!ir(l)) return;
      if (l.type !== r2 || "v-if" === l.children) {
        if (n) return;
        n = l;
      }
    }
    return n;
  }(e)), e = im(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(t => t !== e)), e;
}
function rY(e, t) {
  t && t.pendingBranch ? k(e) ? t.effects.push(...e) : t.effects.push(e) : nt(e);
}
function rQ(e, t) {
  e.activeBranch = t;
  let {
      vnode: n,
      parentComponent: l
    } = e,
    r = t.el;
  for (; !r && t.component;) r = (t = t.component.subTree).el;
  n.el = r, l && l.subTree === n && (l.vnode.el = r, rK(l, r));
}
let r0 = Symbol.for("v-fgt"),
  r1 = Symbol.for("v-txt"),
  r2 = Symbol.for("v-cmt"),
  r6 = Symbol.for("v-stc"),
  r4 = [],
  r8 = null;
function r3(e = !1) {
  r4.push(r8 = e ? null : []);
}
function r5() {
  r4.pop(), r8 = r4[r4.length - 1] || null;
}
let r9 = 1;
function r7(e, t = !1) {
  r9 += e, e < 0 && r8 && t && (r8.hasOnce = !0);
}
function ie(e) {
  return e.dynamicChildren = r9 > 0 ? r8 || m : null, r5(), r9 > 0 && r8 && r8.push(e), e;
}
function it(e, t, n, l, r, i) {
  return ie(iu(e, t, n, l, r, i, !0));
}
function il(e, t, n, l, r) {
  return ie(ic(e, t, n, l, r, !0));
}
function ir(e) {
  return !!e && !0 === e.__v_isVNode;
}
function ii(e, t) {
  return e.type === t.type && e.key === t.key;
}
function is(e) {}
let io = ({
    key: e
  }) => null != e ? e : null,
  ia = ({
    ref: e,
    ref_key: t,
    ref_for: n
  }) => ("number" == typeof e && (e = "" + e), null != e ? P(e) || tw(e) || O(e) ? {
    i: ni,
    r: e,
    k: t,
    f: !!n
  } : e : null);
function iu(e, t = null, n = null, l = 0, r = null, i = e === r0 ? 0 : 1, s = !1, o = !1) {
  let a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && io(t),
    ref: t && ia(t),
    scopeId: ns,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: i,
    patchFlag: l,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: ni
  };
  return o ? (iy(a, n), 128 & i && e.normalize(a)) : n && (a.shapeFlag |= P(n) ? 8 : 16), r9 > 0 && !s && r8 && (a.patchFlag > 0 || 6 & i) && 32 !== a.patchFlag && r8.push(a), a;
}
let ic = function (e, t = null, n = null, l = 0, r = null, i = !1) {
  var s;
  if (e && e !== lC || (e = r2), ir(e)) {
    let l = id(e, t, !0);
    return n && iy(l, n), r9 > 0 && !i && r8 && (6 & l.shapeFlag ? r8[r8.indexOf(e)] = l : r8.push(l)), l.patchFlag = -2, l;
  }
  if (O(s = e) && "__vccOpts" in s && (e = e.__vccOpts), t) {
    let {
      class: e,
      style: n
    } = t = ip(t);
    e && !P(e) && (t.class = es(e)), I(n) && (tb(n) && !k(n) && (n = C({}, n)), t.style = en(n));
  }
  let o = P(e) ? 1 : rz(e) ? 128 : ng(e) ? 64 : I(e) ? 4 : O(e) ? 2 : 0;
  return iu(e, t, n, l, r, o, i, !0);
};
function ip(e) {
  return e ? tb(e) || rs(e) ? C({}, e) : e : null;
}
function id(e, t, n = !1, l = !1) {
  let {
      props: r,
      ref: i,
      patchFlag: s,
      children: o,
      transition: a
    } = e,
    u = t ? ib(r || {}, t) : r,
    c = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: u,
      key: u && io(u),
      ref: t && t.ref ? n && i ? k(i) ? i.concat(ia(t)) : [i, ia(t)] : ia(t) : i,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: o,
      target: e.target,
      targetStart: e.targetStart,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      patchFlag: t && e.type !== r0 ? -1 === s ? 16 : 16 | s : s,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: a,
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && id(e.ssContent),
      ssFallback: e.ssFallback && id(e.ssFallback),
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce
    };
  return a && l && nV(c, a.clone(c)), c;
}
function ih(e = " ", t = 0) {
  return ic(r1, null, e, t);
}
function ig(e, t) {
  let n = ic(r6, null, e);
  return n.staticCount = t, n;
}
function iv(e = "", t = !1) {
  return t ? (r3(), il(r2, null, e)) : ic(r2, null, e);
}
function im(e) {
  return null == e || "boolean" == typeof e ? ic(r2) : k(e) ? ic(r0, null, e.slice()) : ir(e) ? i_(e) : ic(r1, null, String(e));
}
function i_(e) {
  return null === e.el && -1 !== e.patchFlag || e.memo ? e : id(e);
}
function iy(e, t) {
  let n = 0,
    {
      shapeFlag: l
    } = e;
  if (null == t) t = null;else if (k(t)) n = 16;else if ("object" == typeof t) {
    if (65 & l) {
      let n = t.default;
      n && (n._c && (n._d = !1), iy(e, n()), n._c && (n._d = !0));
      return;
    }
    {
      n = 32;
      let l = t._;
      l || rs(t) ? 3 === l && ni && (1 === ni.slots._ ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) : t._ctx = ni;
    }
  } else O(t) ? (t = {
    default: t,
    _ctx: ni
  }, n = 32) : (t = String(t), 64 & l ? (n = 16, t = [ih(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n;
}
function ib(...e) {
  let t = {};
  for (let n = 0; n < e.length; n++) {
    let l = e[n];
    for (let e in l) if ("class" === e) t.class !== l.class && (t.class = es([t.class, l.class]));else if ("style" === e) t.style = en([t.style, l.style]);else if (b(e)) {
      let n = t[e],
        r = l[e];
      r && n !== r && !(k(n) && n.includes(r)) && (t[e] = n ? [].concat(n, r) : r);
    } else "" !== e && (t[e] = l[e]);
  }
  return t;
}
function iS(e, t, n, l = null) {
  tQ(e, t, 7, [n, l]);
}
let iC = l9(),
  ix = 0;
function iE(e, t, n) {
  let l = e.type,
    r = (t ? t.appContext : e.appContext) || iC,
    i = {
      uid: ix++,
      vnode: e,
      type: l,
      parent: t,
      appContext: r,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      job: null,
      scope: new eg(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(r.provides),
      ids: t ? t.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: function e(t, n, l = !1) {
        let r = l ? ru : n.propsCache,
          i = r.get(t);
        if (i) return i;
        let s = t.props,
          o = {},
          a = [],
          u = !1;
        if (!O(t)) {
          let r = t => {
            u = !0;
            let [l, r] = e(t, n, !0);
            C(o, l), r && a.push(...r);
          };
          !l && n.mixins.length && n.mixins.forEach(r), t.extends && r(t.extends), t.mixins && t.mixins.forEach(r);
        }
        if (!s && !u) return I(t) && r.set(t, m), m;
        if (k(s)) for (let e = 0; e < s.length; e++) {
          let t = W(s[e]);
          rc(t) && (o[t] = g);
        } else if (s) for (let e in s) {
          let t = W(e);
          if (rc(t)) {
            let n = s[e],
              l = o[t] = k(n) || O(n) ? {
                type: n
              } : C({}, n),
              r = l.type,
              i = !1,
              u = !0;
            if (k(r)) for (let e = 0; e < r.length; ++e) {
              let t = r[e],
                n = O(t) && t.name;
              if ("Boolean" === n) {
                i = !0;
                break;
              }
              "String" === n && (u = !1);
            } else i = O(r) && "Boolean" === r.name;
            l[0] = i, l[1] = u, (i || w(l, "default")) && a.push(t);
          }
        }
        let c = [o, a];
        return I(t) && r.set(t, c), c;
      }(l, r),
      emitsOptions: function e(t, n, l = !1) {
        let r = n.emitsCache,
          i = r.get(t);
        if (void 0 !== i) return i;
        let s = t.emits,
          o = {},
          a = !1;
        if (!O(t)) {
          let r = t => {
            let l = e(t, n, !0);
            l && (a = !0, C(o, l));
          };
          !l && n.mixins.length && n.mixins.forEach(r), t.extends && r(t.extends), t.mixins && t.mixins.forEach(r);
        }
        return s || a ? (k(s) ? s.forEach(e => o[e] = null) : C(o, s), I(t) && r.set(t, o), o) : (I(t) && r.set(t, null), null);
      }(l, r),
      emit: null,
      emitted: null,
      propsDefaults: g,
      inheritAttrs: l.inheritAttrs,
      ctx: g,
      data: g,
      props: g,
      attrs: g,
      slots: g,
      refs: g,
      setupState: g,
      setupContext: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
  return i.ctx = {
    _: i
  }, i.root = t ? t.root : i, i.emit = rU.bind(null, i), e.ce && e.ce(i), i;
}
let iw = null,
  ik = () => iw || ni;
{
  let e = ee(),
    t = (t, n) => {
      let l;
      return (l = e[t]) || (l = e[t] = []), l.push(n), e => {
        l.length > 1 ? l.forEach(t => t(e)) : l[0](e);
      };
    };
  o = t("__VUE_INSTANCE_SETTERS__", e => iw = e), a = t("__VUE_SSR_SETTERS__", e => iN = e);
}
let iT = e => {
    let t = iw;
    return o(e), e.scope.on(), () => {
      e.scope.off(), o(t);
    };
  },
  iA = () => {
    iw && iw.scope.off(), o(null);
  };
function iR(e) {
  return 4 & e.vnode.shapeFlag;
}
let iN = !1;
function iO(e, t = !1, n = !1) {
  t && a(t);
  let {
      props: l,
      children: r
    } = e.vnode,
    i = iR(e);
  !function (e, t, n, l = !1) {
    let r = {},
      i = ri();
    for (let n in e.propsDefaults = Object.create(null), ro(e, t, r, i), e.propsOptions[0]) n in r || (r[n] = void 0);
    n ? e.props = l ? r : td(r) : e.type.props ? e.props = r : e.props = i, e.attrs = i;
  }(e, l, i, t), rm(e, r, n);
  let s = i ? function (e, t) {
    let n = e.type;
    e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, lL);
    let {
      setup: l
    } = n;
    if (l) {
      eM();
      let n = e.setupContext = l.length > 1 ? iF(e) : null,
        r = iT(e),
        i = tY(l, e, 0, [e.props, n]),
        s = L(i);
      if (eI(), r(), (s || e.sp) && !n5(e) && n$(e), s) {
        if (i.then(iA, iA), t) return i.then(n => {
          iP(e, n, t);
        }).catch(t => {
          t0(t, e, 0);
        });
        e.asyncDep = i;
      } else iP(e, i, t);
    } else iL(e, t);
  }(e, t) : void 0;
  return t && a(!1), s;
}
function iP(e, t, n) {
  O(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : I(t) && (e.setupState = tI(t)), iL(e, n);
}
function iM(e) {
  u = e, c = e => {
    e.render._rc && (e.withProxy = new Proxy(e.ctx, lD));
  };
}
let iI = () => !u;
function iL(e, t, n) {
  let l = e.type;
  if (!e.render) {
    if (!t && u && !l.render) {
      let t = l.template || l0(e).template;
      if (t) {
        let {
            isCustomElement: n,
            compilerOptions: r
          } = e.appContext.config,
          {
            delimiters: i,
            compilerOptions: s
          } = l,
          o = C(C({
            isCustomElement: n,
            delimiters: i
          }, r), s);
        l.render = u(t, o);
      }
    }
    e.render = l.render || _, c && c(e);
  }
  {
    let t = iT(e);
    eM();
    try {
      !function (e) {
        let t = l0(e),
          n = e.proxy,
          l = e.ctx;
        lY = !1, t.beforeCreate && lQ(t.beforeCreate, e, "bc");
        let {
          data: r,
          computed: i,
          methods: s,
          watch: o,
          provide: a,
          inject: u,
          created: c,
          beforeMount: f,
          mounted: p,
          beforeUpdate: d,
          updated: h,
          activated: g,
          deactivated: m,
          beforeDestroy: y,
          beforeUnmount: b,
          destroyed: S,
          unmounted: C,
          render: x,
          renderTracked: E,
          renderTriggered: w,
          errorCaptured: T,
          serverPrefetch: A,
          expose: R,
          inheritAttrs: N,
          components: M,
          directives: L,
          filters: D
        } = t;
        if (u && function (e, t, n = _) {
          for (let n in k(e) && (e = l4(e)), e) {
            let l;
            let r = e[n];
            tw(l = I(r) ? "default" in r ? rn(r.from || n, r.default, !0) : rn(r.from || n) : rn(r)) ? Object.defineProperty(t, n, {
              enumerable: !0,
              configurable: !0,
              get: () => l.value,
              set: e => l.value = e
            }) : t[n] = l;
          }
        }(u, l, null), s) for (let e in s) {
          let t = s[e];
          O(t) && (l[e] = t.bind(n));
        }
        if (r) {
          let t = r.call(n, n);
          I(t) && (e.data = tp(t));
        }
        if (lY = !0, i) for (let e in i) {
          let t = i[e],
            r = O(t) ? t.bind(n, n) : O(t.get) ? t.get.bind(n, n) : _,
            s = ij({
              get: r,
              set: !O(t) && O(t.set) ? t.set.bind(n) : _
            });
          Object.defineProperty(l, e, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: e => s.value = e
          });
        }
        if (o) for (let e in o) !function e(t, n, l, r) {
          let i = r.includes(".") ? rD(l, r) : () => l[r];
          if (P(t)) {
            let e = n[t];
            O(e) && rM(i, e);
          } else if (O(t)) rM(i, t.bind(l));else if (I(t)) {
            if (k(t)) t.forEach(t => e(t, n, l, r));else {
              let e = O(t.handler) ? t.handler.bind(l) : n[t.handler];
              O(e) && rM(i, e, t);
            }
          }
        }(o[e], l, n, e);
        if (a) {
          let e = O(a) ? a.call(n) : a;
          Reflect.ownKeys(e).forEach(t => {
            rt(t, e[t]);
          });
        }
        function F(e, t) {
          k(t) ? t.forEach(t => e(t.bind(n))) : t && e(t.bind(n));
        }
        if (c && lQ(c, e, "c"), F(lc, f), F(lf, p), F(lp, d), F(ld, h), F(ll, g), F(lr, m), F(ly, T), F(l_, E), F(lm, w), F(lh, b), F(lg, C), F(lv, A), k(R)) {
          if (R.length) {
            let t = e.exposed || (e.exposed = {});
            R.forEach(e => {
              Object.defineProperty(t, e, {
                get: () => n[e],
                set: t => n[e] = t
              });
            });
          } else e.exposed || (e.exposed = {});
        }
        x && e.render === _ && (e.render = x), null != N && (e.inheritAttrs = N), M && (e.components = M), L && (e.directives = L), A && n$(e);
      }(e);
    } finally {
      eI(), t();
    }
  }
}
let iD = {
  get: (e, t) => (eH(e, "get", ""), e[t])
};
function iF(e) {
  return {
    attrs: new Proxy(e.attrs, iD),
    slots: e.slots,
    emit: e.emit,
    expose: t => {
      e.exposed = t || {};
    }
  };
}
function iV(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(tI(tC(e.exposed)), {
    get: (t, n) => n in t ? t[n] : n in lM ? lM[n](e) : void 0,
    has: (e, t) => t in e || t in lM
  })) : e.proxy;
}
function iU(e, t = !0) {
  return O(e) ? e.displayName || e.name : e.name || t && e.__name;
}
let ij = (e, t) => function (e, t, n = !1) {
  let l, r;
  return O(e) ? l = e : (l = e.get, r = e.set), new t$(l, r, n);
}(e, 0, iN);
function iB(e, t, n) {
  let l = arguments.length;
  return 2 !== l ? (l > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === l && ir(n) && (n = [n]), ic(e, t, n)) : !I(t) || k(t) ? ic(e, null, t) : ir(t) ? ic(e, null, [t]) : ic(e, t);
}
function i$() {}
function iH(e, t, n, l) {
  let r = n[l];
  if (r && iW(r, e)) return r;
  let i = t();
  return i.memo = e.slice(), i.cacheIndex = l, n[l] = i;
}
function iW(e, t) {
  let n = e.memo;
  if (n.length != t.length) return !1;
  for (let e = 0; e < n.length; e++) if (J(n[e], t[e])) return !1;
  return r9 > 0 && r8 && r8.push(e), !0;
}
let iK = "3.5.13",
  iz = (/* unused pure expression or super */ null && (_)),
  iq = null,
  iG = void 0,
  iJ = (/* unused pure expression or super */ null && (_)),
  iX = {
    createComponentInstance: iE,
    setupComponent: iO,
    renderComponentRoot: rB,
    setCurrentRenderingInstance: no,
    isVNode: ir,
    normalizeVNode: im,
    getComponentPublicInstance: iV,
    ensureValidVNode: lN,
    pushWarningContext: function (e) {},
    popWarningContext: function () {}
  },
  iZ = null,
  iY = null,
  iQ = null,
  i0 = "undefined" != typeof window && window.trustedTypes;
if (i0) try {
  d = i0.createPolicy("vue", {
    createHTML: e => e
  });
} catch (e) {}
let i1 = d ? e => d.createHTML(e) : e => e,
  i2 = "undefined" != typeof document ? document : null,
  i6 = i2 && i2.createElement("template"),
  i4 = "transition",
  i8 = "animation",
  i3 = Symbol("_vtc"),
  i5 = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  },
  i9 = C({}, nN, i5),
  i7 = ((e = (e, {
    slots: t
  }) => iB(nM, sn(e), t)).displayName = "Transition", e.props = i9, e),
  se = (e, t = []) => {
    k(e) ? e.forEach(e => e(...t)) : e && e(...t);
  },
  st = e => !!e && (k(e) ? e.some(e => e.length > 1) : e.length > 1);
function sn(e) {
  let t = {};
  for (let n in e) n in i5 || (t[n] = e[n]);
  if (!1 === e.css) return t;
  let {
      name: n = "v",
      type: l,
      duration: r,
      enterFromClass: i = `${n}-enter-from`,
      enterActiveClass: s = `${n}-enter-active`,
      enterToClass: o = `${n}-enter-to`,
      appearFromClass: a = i,
      appearActiveClass: u = s,
      appearToClass: c = o,
      leaveFromClass: f = `${n}-leave-from`,
      leaveActiveClass: p = `${n}-leave-active`,
      leaveToClass: d = `${n}-leave-to`
    } = e,
    h = function (e) {
      if (null == e) return null;
      if (I(e)) return [Q(e.enter), Q(e.leave)];
      {
        let t = Q(e);
        return [t, t];
      }
    }(r),
    g = h && h[0],
    m = h && h[1],
    {
      onBeforeEnter: _,
      onEnter: y,
      onEnterCancelled: b,
      onLeave: S,
      onLeaveCancelled: x,
      onBeforeAppear: E = _,
      onAppear: w = y,
      onAppearCancelled: k = b
    } = t,
    T = (e, t, n, l) => {
      e._enterCancelled = l, sr(e, t ? c : o), sr(e, t ? u : s), n && n();
    },
    A = (e, t) => {
      e._isLeaving = !1, sr(e, f), sr(e, d), sr(e, p), t && t();
    },
    R = e => (t, n) => {
      let r = e ? w : y,
        s = () => T(t, e, n);
      se(r, [t, s]), si(() => {
        sr(t, e ? a : i), sl(t, e ? c : o), st(r) || so(t, l, g, s);
      });
    };
  return C(t, {
    onBeforeEnter(e) {
      se(_, [e]), sl(e, i), sl(e, s);
    },
    onBeforeAppear(e) {
      se(E, [e]), sl(e, a), sl(e, u);
    },
    onEnter: R(!1),
    onAppear: R(!0),
    onLeave(e, t) {
      e._isLeaving = !0;
      let n = () => A(e, t);
      sl(e, f), e._enterCancelled ? (sl(e, p), sf()) : (sf(), sl(e, p)), si(() => {
        e._isLeaving && (sr(e, f), sl(e, d), st(S) || so(e, l, m, n));
      }), se(S, [e, n]);
    },
    onEnterCancelled(e) {
      T(e, !1, void 0, !0), se(b, [e]);
    },
    onAppearCancelled(e) {
      T(e, !0, void 0, !0), se(k, [e]);
    },
    onLeaveCancelled(e) {
      A(e), se(x, [e]);
    }
  });
}
function sl(e, t) {
  t.split(/\s+/).forEach(t => t && e.classList.add(t)), (e[i3] || (e[i3] = new Set())).add(t);
}
function sr(e, t) {
  t.split(/\s+/).forEach(t => t && e.classList.remove(t));
  let n = e[i3];
  n && (n.delete(t), n.size || (e[i3] = void 0));
}
function si(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let ss = 0;
function so(e, t, n, l) {
  let r = e._endId = ++ss,
    i = () => {
      r === e._endId && l();
    };
  if (null != n) return setTimeout(i, n);
  let {
    type: s,
    timeout: o,
    propCount: a
  } = sa(e, t);
  if (!s) return l();
  let u = s + "end",
    c = 0,
    f = () => {
      e.removeEventListener(u, p), i();
    },
    p = t => {
      t.target === e && ++c >= a && f();
    };
  setTimeout(() => {
    c < a && f();
  }, o + 1), e.addEventListener(u, p);
}
function sa(e, t) {
  let n = window.getComputedStyle(e),
    l = e => (n[e] || "").split(", "),
    r = l(`${i4}Delay`),
    i = l(`${i4}Duration`),
    s = su(r, i),
    o = l(`${i8}Delay`),
    a = l(`${i8}Duration`),
    u = su(o, a),
    c = null,
    f = 0,
    p = 0;
  t === i4 ? s > 0 && (c = i4, f = s, p = i.length) : t === i8 ? u > 0 && (c = i8, f = u, p = a.length) : p = (c = (f = Math.max(s, u)) > 0 ? s > u ? i4 : i8 : null) ? c === i4 ? i.length : a.length : 0;
  let d = c === i4 && /\b(transform|all)(,|$)/.test(l(`${i4}Property`).toString());
  return {
    type: c,
    timeout: f,
    propCount: p,
    hasTransform: d
  };
}
function su(e, t) {
  for (; e.length < t.length;) e = e.concat(e);
  return Math.max(...t.map((t, n) => sc(t) + sc(e[n])));
}
function sc(e) {
  return "auto" === e ? 0 : 1e3 * Number(e.slice(0, -1).replace(",", "."));
}
function sf() {
  return document.body.offsetHeight;
}
let sp = Symbol("_vod"),
  sd = Symbol("_vsh"),
  sh = {
    beforeMount(e, {
      value: t
    }, {
      transition: n
    }) {
      e[sp] = "none" === e.style.display ? "" : e.style.display, n && t ? n.beforeEnter(e) : sg(e, t);
    },
    mounted(e, {
      value: t
    }, {
      transition: n
    }) {
      n && t && n.enter(e);
    },
    updated(e, {
      value: t,
      oldValue: n
    }, {
      transition: l
    }) {
      !t != !n && (l ? t ? (l.beforeEnter(e), sg(e, !0), l.enter(e)) : l.leave(e, () => {
        sg(e, !1);
      }) : sg(e, t));
    },
    beforeUnmount(e, {
      value: t
    }) {
      sg(e, t);
    }
  };
function sg(e, t) {
  e.style.display = t ? e[sp] : "none", e[sd] = !t;
}
let sv = Symbol("");
function sm(e) {
  let t = ik();
  if (!t) return;
  let n = t.ut = (n = e(t.proxy)) => {
      Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(e => s_(e, n));
    },
    l = () => {
      let l = e(t.proxy);
      t.ce ? s_(t.ce, l) : function e(t, n) {
        if (128 & t.shapeFlag) {
          let l = t.suspense;
          t = l.activeBranch, l.pendingBranch && !l.isHydrating && l.effects.push(() => {
            e(l.activeBranch, n);
          });
        }
        for (; t.component;) t = t.component.subTree;
        if (1 & t.shapeFlag && t.el) s_(t.el, n);else if (t.type === r0) t.children.forEach(t => e(t, n));else if (t.type === r6) {
          let {
            el: e,
            anchor: l
          } = t;
          for (; e && (s_(e, n), e !== l);) e = e.nextSibling;
        }
      }(t.subTree, l), n(l);
    };
  lp(() => {
    nt(l);
  }), lf(() => {
    rM(l, _, {
      flush: "post"
    });
    let e = new MutationObserver(l);
    e.observe(t.subTree.el.parentNode, {
      childList: !0
    }), lg(() => e.disconnect());
  });
}
function s_(e, t) {
  if (1 === e.nodeType) {
    let n = e.style,
      l = "";
    for (let e in t) n.setProperty(`--${e}`, t[e]), l += `--${e}: ${t[e]};`;
    n[sv] = l;
  }
}
let sy = /(^|;)\s*display\s*:/,
  sb = /\s*!important$/;
function sS(e, t, n) {
  if (k(n)) n.forEach(n => sS(e, t, n));else if (null == n && (n = ""), t.startsWith("--")) e.setProperty(t, n);else {
    let l = function (e, t) {
      let n = sx[t];
      if (n) return n;
      let l = W(t);
      if ("filter" !== l && l in e) return sx[t] = l;
      l = q(l);
      for (let n = 0; n < sC.length; n++) {
        let r = sC[n] + l;
        if (r in e) return sx[t] = r;
      }
      return t;
    }(e, t);
    sb.test(n) ? e.setProperty(z(l), n.replace(sb, ""), "important") : e[l] = n;
  }
}
let sC = ["Webkit", "Moz", "ms"],
  sx = {},
  sE = "http://www.w3.org/1999/xlink";
function sw(e, t, n, l, r, i = ea(t)) {
  l && t.startsWith("xlink:") ? null == n ? e.removeAttributeNS(sE, t.slice(6, t.length)) : e.setAttributeNS(sE, t, n) : null == n || i && !(n || "" === n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : M(n) ? String(n) : n);
}
function sk(e, t, n, l, r) {
  if ("innerHTML" === t || "textContent" === t) {
    null != n && (e[t] = "innerHTML" === t ? i1(n) : n);
    return;
  }
  let i = e.tagName;
  if ("value" === t && "PROGRESS" !== i && !i.includes("-")) {
    let l = "OPTION" === i ? e.getAttribute("value") || "" : e.value,
      r = null == n ? "checkbox" === e.type ? "on" : "" : String(n);
    l === r && "_value" in e || (e.value = r), null == n && e.removeAttribute(t), e._value = n;
    return;
  }
  let s = !1;
  if ("" === n || null == n) {
    let l = typeof e[t];
    if ("boolean" === l) {
      var o;
      n = !!(o = n) || "" === o;
    } else null == n && "string" === l ? (n = "", s = !0) : "number" === l && (n = 0, s = !0);
  }
  try {
    e[t] = n;
  } catch (e) {}
  s && e.removeAttribute(r || t);
}
function sT(e, t, n, l) {
  e.addEventListener(t, n, l);
}
let sA = Symbol("_vei"),
  sR = /(?:Once|Passive|Capture)$/,
  sN = 0,
  sO = Promise.resolve(),
  sP = () => sN || (sO.then(() => sN = 0), sN = Date.now()),
  sM = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) > 96 && 123 > e.charCodeAt(2),
  sI = {};
function sL(e, t, n) {
  let l = nj(e, t);
  U(l) && C(l, t);
  class r extends sV {
    constructor(e) {
      super(l, e, n);
    }
  }
  return r.def = l, r;
}
let sD = (e, t) => sL(e, t, op),
  sF = "undefined" != typeof HTMLElement ? HTMLElement : class {};
class sV extends sF {
  constructor(e, t = {}, n = of) {
    super(), this._def = e, this._props = t, this._createApp = n, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = new WeakSet(), this._ob = null, this.shadowRoot && n !== of ? this._root = this.shadowRoot : !1 !== e.shadowRoot ? (this.attachShadow({
      mode: "open"
    }), this._root = this.shadowRoot) : this._root = this, this._def.__asyncLoader || this._resolveProps(this._def);
  }
  connectedCallback() {
    if (!this.isConnected) return;
    this.shadowRoot || this._parseSlots(), this._connected = !0;
    let e = this;
    for (; e = e && (e.parentNode || e.host);) if (e instanceof sV) {
      this._parent = e;
      break;
    }
    this._instance || (this._resolved ? (this._setParent(), this._update()) : e && e._pendingResolve ? this._pendingResolve = e._pendingResolve.then(() => {
      this._pendingResolve = void 0, this._resolveDef();
    }) : this._resolveDef());
  }
  _setParent(e = this._parent) {
    e && (this._instance.parent = e._instance, this._instance.provides = e._instance.provides);
  }
  disconnectedCallback() {
    this._connected = !1, t9(() => {
      this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null);
    });
  }
  _resolveDef() {
    if (this._pendingResolve) return;
    for (let e = 0; e < this.attributes.length; e++) this._setAttr(this.attributes[e].name);
    this._ob = new MutationObserver(e => {
      for (let t of e) this._setAttr(t.attributeName);
    }), this._ob.observe(this, {
      attributes: !0
    });
    let e = (e, t = !1) => {
        let n;
        this._resolved = !0, this._pendingResolve = void 0;
        let {
          props: l,
          styles: r
        } = e;
        if (l && !k(l)) for (let e in l) {
          let t = l[e];
          (t === Number || t && t.type === Number) && (e in this._props && (this._props[e] = Q(this._props[e])), (n || (n = Object.create(null)))[W(e)] = !0);
        }
        this._numberProps = n, t && this._resolveProps(e), this.shadowRoot && this._applyStyles(r), this._mount(e);
      },
      t = this._def.__asyncLoader;
    t ? this._pendingResolve = t().then(t => e(this._def = t, !0)) : e(this._def);
  }
  _mount(e) {
    this._app = this._createApp(e), e.configureApp && e.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root);
    let t = this._instance && this._instance.exposed;
    if (t) for (let e in t) w(this, e) || Object.defineProperty(this, e, {
      get: () => tO(t[e])
    });
  }
  _resolveProps(e) {
    let {
        props: t
      } = e,
      n = k(t) ? t : Object.keys(t || {});
    for (let e of Object.keys(this)) "_" !== e[0] && n.includes(e) && this._setProp(e, this[e]);
    for (let e of n.map(W)) Object.defineProperty(this, e, {
      get() {
        return this._getProp(e);
      },
      set(t) {
        this._setProp(e, t, !0, !0);
      }
    });
  }
  _setAttr(e) {
    if (e.startsWith("data-v-")) return;
    let t = this.hasAttribute(e),
      n = t ? this.getAttribute(e) : sI,
      l = W(e);
    t && this._numberProps && this._numberProps[l] && (n = Q(n)), this._setProp(l, n, !1, !0);
  }
  _getProp(e) {
    return this._props[e];
  }
  _setProp(e, t, n = !0, l = !1) {
    if (t !== this._props[e] && (t === sI ? delete this._props[e] : (this._props[e] = t, "key" === e && this._app && (this._app._ceVNode.key = t)), l && this._instance && this._update(), n)) {
      let n = this._ob;
      n && n.disconnect(), !0 === t ? this.setAttribute(z(e), "") : "string" == typeof t || "number" == typeof t ? this.setAttribute(z(e), t + "") : t || this.removeAttribute(z(e)), n && n.observe(this, {
        attributes: !0
      });
    }
  }
  _update() {
    ou(this._createVNode(), this._root);
  }
  _createVNode() {
    let e = {};
    this.shadowRoot || (e.onVnodeMounted = e.onVnodeUpdated = this._renderSlots.bind(this));
    let t = ic(this._def, C(e, this._props));
    return this._instance || (t.ce = e => {
      this._instance = e, e.ce = this, e.isCE = !0;
      let t = (e, t) => {
        this.dispatchEvent(new CustomEvent(e, U(t[0]) ? C({
          detail: t
        }, t[0]) : {
          detail: t
        }));
      };
      e.emit = (e, ...n) => {
        t(e, n), z(e) !== e && t(z(e), n);
      }, this._setParent();
    }), t;
  }
  _applyStyles(e, t) {
    if (!e) return;
    if (t) {
      if (t === this._def || this._styleChildren.has(t)) return;
      this._styleChildren.add(t);
    }
    let n = this._nonce;
    for (let t = e.length - 1; t >= 0; t--) {
      let l = document.createElement("style");
      n && l.setAttribute("nonce", n), l.textContent = e[t], this.shadowRoot.prepend(l);
    }
  }
  _parseSlots() {
    let e;
    let t = this._slots = {};
    for (; e = this.firstChild;) {
      let n = 1 === e.nodeType && e.getAttribute("slot") || "default";
      (t[n] || (t[n] = [])).push(e), this.removeChild(e);
    }
  }
  _renderSlots() {
    let e = (this._teleportTarget || this).querySelectorAll("slot"),
      t = this._instance.type.__scopeId;
    for (let n = 0; n < e.length; n++) {
      let l = e[n],
        r = l.getAttribute("name") || "default",
        i = this._slots[r],
        s = l.parentNode;
      if (i) for (let e of i) {
        if (t && 1 === e.nodeType) {
          let n;
          let l = t + "-s",
            r = document.createTreeWalker(e, 1);
          for (e.setAttribute(l, ""); n = r.nextNode();) n.setAttribute(l, "");
        }
        s.insertBefore(e, l);
      } else for (; l.firstChild;) s.insertBefore(l.firstChild, l);
      s.removeChild(l);
    }
  }
  _injectChildStyle(e) {
    this._applyStyles(e.styles, e);
  }
  _removeChildStyle(e) {}
}
function sU(e) {
  let t = ik();
  return t && t.ce || null;
}
function sj() {
  let e = sU();
  return e && e.shadowRoot;
}
function sB(e = "$style") {
  {
    let t = ik();
    if (!t) return g;
    let n = t.type.__cssModules;
    return n && n[e] || g;
  }
}
let s$ = new WeakMap(),
  sH = new WeakMap(),
  sW = Symbol("_moveCb"),
  sK = Symbol("_enterCb"),
  sz = (t = {
    name: "TransitionGroup",
    props: C({}, i9, {
      tag: String,
      moveClass: String
    }),
    setup(e, {
      slots: t
    }) {
      let n, l;
      let r = ik(),
        i = nA();
      return ld(() => {
        if (!n.length) return;
        let t = e.moveClass || `${e.name || "v"}-move`;
        if (!function (e, t, n) {
          let l = e.cloneNode(),
            r = e[i3];
          r && r.forEach(e => {
            e.split(/\s+/).forEach(e => e && l.classList.remove(e));
          }), n.split(/\s+/).forEach(e => e && l.classList.add(e)), l.style.display = "none";
          let i = 1 === t.nodeType ? t : t.parentNode;
          i.appendChild(l);
          let {
            hasTransform: s
          } = sa(l);
          return i.removeChild(l), s;
        }(n[0].el, r.vnode.el, t)) return;
        n.forEach(sq), n.forEach(sG);
        let l = n.filter(sJ);
        sf(), l.forEach(e => {
          let n = e.el,
            l = n.style;
          sl(n, t), l.transform = l.webkitTransform = l.transitionDuration = "";
          let r = n[sW] = e => {
            (!e || e.target === n) && (!e || /transform$/.test(e.propertyName)) && (n.removeEventListener("transitionend", r), n[sW] = null, sr(n, t));
          };
          n.addEventListener("transitionend", r);
        });
      }), () => {
        let s = tS(e),
          o = sn(s),
          a = s.tag || r0;
        if (n = [], l) for (let e = 0; e < l.length; e++) {
          let t = l[e];
          t.el && t.el instanceof Element && (n.push(t), nV(t, nL(t, o, i, r)), s$.set(t, t.el.getBoundingClientRect()));
        }
        l = t.default ? nU(t.default()) : [];
        for (let e = 0; e < l.length; e++) {
          let t = l[e];
          null != t.key && nV(t, nL(t, o, i, r));
        }
        return ic(a, null, l);
      };
    }
  }, delete t.props.mode, t);
function sq(e) {
  let t = e.el;
  t[sW] && t[sW](), t[sK] && t[sK]();
}
function sG(e) {
  sH.set(e, e.el.getBoundingClientRect());
}
function sJ(e) {
  let t = s$.get(e),
    n = sH.get(e),
    l = t.left - n.left,
    r = t.top - n.top;
  if (l || r) {
    let t = e.el.style;
    return t.transform = t.webkitTransform = `translate(${l}px,${r}px)`, t.transitionDuration = "0s", e;
  }
}
let sX = e => {
  let t = e.props["onUpdate:modelValue"] || !1;
  return k(t) ? e => X(t, e) : t;
};
function sZ(e) {
  e.target.composing = !0;
}
function sY(e) {
  let t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
}
let sQ = Symbol("_assign"),
  s0 = {
    created(e, {
      modifiers: {
        lazy: t,
        trim: n,
        number: l
      }
    }, r) {
      e[sQ] = sX(r);
      let i = l || r.props && "number" === r.props.type;
      sT(e, t ? "change" : "input", t => {
        if (t.target.composing) return;
        let l = e.value;
        n && (l = l.trim()), i && (l = Y(l)), e[sQ](l);
      }), n && sT(e, "change", () => {
        e.value = e.value.trim();
      }), t || (sT(e, "compositionstart", sZ), sT(e, "compositionend", sY), sT(e, "change", sY));
    },
    mounted(e, {
      value: t
    }) {
      e.value = null == t ? "" : t;
    },
    beforeUpdate(e, {
      value: t,
      oldValue: n,
      modifiers: {
        lazy: l,
        trim: r,
        number: i
      }
    }, s) {
      if (e[sQ] = sX(s), e.composing) return;
      let o = (i || "number" === e.type) && !/^0\d/.test(e.value) ? Y(e.value) : e.value,
        a = null == t ? "" : t;
      o === a || document.activeElement === e && "range" !== e.type && (l && t === n || r && e.value.trim() === a) || (e.value = a);
    }
  },
  s1 = {
    deep: !0,
    created(e, t, n) {
      e[sQ] = sX(n), sT(e, "change", () => {
        let t = e._modelValue,
          n = s3(e),
          l = e.checked,
          r = e[sQ];
        if (k(t)) {
          let e = ec(t, n),
            i = -1 !== e;
          if (l && !i) r(t.concat(n));else if (!l && i) {
            let n = [...t];
            n.splice(e, 1), r(n);
          }
        } else if (A(t)) {
          let e = new Set(t);
          l ? e.add(n) : e.delete(n), r(e);
        } else r(s5(e, l));
      });
    },
    mounted: s2,
    beforeUpdate(e, t, n) {
      e[sQ] = sX(n), s2(e, t, n);
    }
  };
function s2(e, {
  value: t,
  oldValue: n
}, l) {
  let r;
  if (e._modelValue = t, k(t)) r = ec(t, l.props.value) > -1;else if (A(t)) r = t.has(l.props.value);else {
    if (t === n) return;
    r = eu(t, s5(e, !0));
  }
  e.checked !== r && (e.checked = r);
}
let s6 = {
    created(e, {
      value: t
    }, n) {
      e.checked = eu(t, n.props.value), e[sQ] = sX(n), sT(e, "change", () => {
        e[sQ](s3(e));
      });
    },
    beforeUpdate(e, {
      value: t,
      oldValue: n
    }, l) {
      e[sQ] = sX(l), t !== n && (e.checked = eu(t, l.props.value));
    }
  },
  s4 = {
    deep: !0,
    created(e, {
      value: t,
      modifiers: {
        number: n
      }
    }, l) {
      let r = A(t);
      sT(e, "change", () => {
        let t = Array.prototype.filter.call(e.options, e => e.selected).map(e => n ? Y(s3(e)) : s3(e));
        e[sQ](e.multiple ? r ? new Set(t) : t : t[0]), e._assigning = !0, t9(() => {
          e._assigning = !1;
        });
      }), e[sQ] = sX(l);
    },
    mounted(e, {
      value: t
    }) {
      s8(e, t);
    },
    beforeUpdate(e, t, n) {
      e[sQ] = sX(n);
    },
    updated(e, {
      value: t
    }) {
      e._assigning || s8(e, t);
    }
  };
function s8(e, t) {
  let n = e.multiple,
    l = k(t);
  if (!n || l || A(t)) {
    for (let r = 0, i = e.options.length; r < i; r++) {
      let i = e.options[r],
        s = s3(i);
      if (n) {
        if (l) {
          let e = typeof s;
          "string" === e || "number" === e ? i.selected = t.some(e => String(e) === String(s)) : i.selected = ec(t, s) > -1;
        } else i.selected = t.has(s);
      } else if (eu(s3(i), t)) {
        e.selectedIndex !== r && (e.selectedIndex = r);
        return;
      }
    }
    n || -1 === e.selectedIndex || (e.selectedIndex = -1);
  }
}
function s3(e) {
  return "_value" in e ? e._value : e.value;
}
function s5(e, t) {
  let n = t ? "_trueValue" : "_falseValue";
  return n in e ? e[n] : t;
}
let s9 = {
  created(e, t, n) {
    oe(e, t, n, null, "created");
  },
  mounted(e, t, n) {
    oe(e, t, n, null, "mounted");
  },
  beforeUpdate(e, t, n, l) {
    oe(e, t, n, l, "beforeUpdate");
  },
  updated(e, t, n, l) {
    oe(e, t, n, l, "updated");
  }
};
function s7(e, t) {
  switch (e) {
    case "SELECT":
      return s4;
    case "TEXTAREA":
      return s0;
    default:
      switch (t) {
        case "checkbox":
          return s1;
        case "radio":
          return s6;
        default:
          return s0;
      }
  }
}
function oe(e, t, n, l, r) {
  let i = s7(e.tagName, n.props && n.props.type)[r];
  i && i(e, t, n, l);
}
let ot = ["ctrl", "shift", "alt", "meta"],
  on = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => "button" in e && 0 !== e.button,
    middle: e => "button" in e && 1 !== e.button,
    right: e => "button" in e && 2 !== e.button,
    exact: (e, t) => ot.some(n => e[`${n}Key`] && !t.includes(n))
  },
  ol = (e, t) => {
    let n = e._withMods || (e._withMods = {}),
      l = t.join(".");
    return n[l] || (n[l] = (n, ...l) => {
      for (let e = 0; e < t.length; e++) {
        let l = on[t[e]];
        if (l && l(n, t)) return;
      }
      return e(n, ...l);
    });
  },
  or = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  },
  oi = (e, t) => {
    let n = e._withKeys || (e._withKeys = {}),
      l = t.join(".");
    return n[l] || (n[l] = n => {
      if (!("key" in n)) return;
      let l = z(n.key);
      if (t.some(e => e === l || or[e] === l)) return e(n);
    });
  },
  os = C({
    patchProp: (e, t, n, l, r, i) => {
      let s = "svg" === r;
      "class" === t ? function (e, t, n) {
        let l = e[i3];
        l && (t = (t ? [t, ...l] : [...l]).join(" ")), null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t;
      }(e, l, s) : "style" === t ? function (e, t, n) {
        let l = e.style,
          r = P(n),
          i = !1;
        if (n && !r) {
          if (t) {
            if (P(t)) for (let e of t.split(";")) {
              let t = e.slice(0, e.indexOf(":")).trim();
              null == n[t] && sS(l, t, "");
            } else for (let e in t) null == n[e] && sS(l, e, "");
          }
          for (let e in n) "display" === e && (i = !0), sS(l, e, n[e]);
        } else if (r) {
          if (t !== n) {
            let e = l[sv];
            e && (n += ";" + e), l.cssText = n, i = sy.test(n);
          }
        } else t && e.removeAttribute("style");
        sp in e && (e[sp] = i ? l.display : "", e[sd] && (l.display = "none"));
      }(e, n, l) : b(t) ? S(t) || function (e, t, n, l, r = null) {
        let i = e[sA] || (e[sA] = {}),
          s = i[t];
        if (l && s) s.value = l;else {
          let [n, o] = function (e) {
            let t;
            if (sR.test(e)) {
              let n;
              for (t = {}; n = e.match(sR);) e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0;
            }
            return [":" === e[2] ? e.slice(3) : z(e.slice(2)), t];
          }(t);
          l ? sT(e, n, i[t] = function (e, t) {
            let n = e => {
              if (e._vts) {
                if (e._vts <= n.attached) return;
              } else e._vts = Date.now();
              tQ(function (e, t) {
                if (!k(t)) return t;
                {
                  let n = e.stopImmediatePropagation;
                  return e.stopImmediatePropagation = () => {
                    n.call(e), e._stopped = !0;
                  }, t.map(e => t => !t._stopped && e && e(t));
                }
              }(e, n.value), t, 5, [e]);
            };
            return n.value = e, n.attached = sP(), n;
          }(l, r), o) : s && (!function (e, t, n, l) {
            e.removeEventListener(t, n, l);
          }(e, n, s, o), i[t] = void 0);
        }
      }(e, t, 0, l, i) : ("." === t[0] ? (t = t.slice(1), 0) : "^" === t[0] ? (t = t.slice(1), 1) : !function (e, t, n, l) {
        if (l) return !!("innerHTML" === t || "textContent" === t || t in e && sM(t) && O(n));
        if ("spellcheck" === t || "draggable" === t || "translate" === t || "form" === t || "list" === t && "INPUT" === e.tagName || "type" === t && "TEXTAREA" === e.tagName) return !1;
        if ("width" === t || "height" === t) {
          let t = e.tagName;
          if ("IMG" === t || "VIDEO" === t || "CANVAS" === t || "SOURCE" === t) return !1;
        }
        return !(sM(t) && P(n)) && t in e;
      }(e, t, l, s)) ? e._isVueCE && (/[A-Z]/.test(t) || !P(l)) ? sk(e, W(t), l, i, t) : ("true-value" === t ? e._trueValue = l : "false-value" === t && (e._falseValue = l), sw(e, t, l, s)) : (sk(e, t, l), e.tagName.includes("-") || "value" !== t && "checked" !== t && "selected" !== t || sw(e, t, l, s, i, "value" !== t));
    }
  }, {
    insert: (e, t, n) => {
      t.insertBefore(e, n || null);
    },
    remove: e => {
      let t = e.parentNode;
      t && t.removeChild(e);
    },
    createElement: (e, t, n, l) => {
      let r = "svg" === t ? i2.createElementNS("http://www.w3.org/2000/svg", e) : "mathml" === t ? i2.createElementNS("http://www.w3.org/1998/Math/MathML", e) : n ? i2.createElement(e, {
        is: n
      }) : i2.createElement(e);
      return "select" === e && l && null != l.multiple && r.setAttribute("multiple", l.multiple), r;
    },
    createText: e => i2.createTextNode(e),
    createComment: e => i2.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t;
    },
    setElementText: (e, t) => {
      e.textContent = t;
    },
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => i2.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, "");
    },
    insertStaticContent(e, t, n, l, r, i) {
      let s = n ? n.previousSibling : t.lastChild;
      if (r && (r === i || r.nextSibling)) for (; t.insertBefore(r.cloneNode(!0), n), r !== i && (r = r.nextSibling););else {
        i6.innerHTML = i1("svg" === l ? `<svg>${e}</svg>` : "mathml" === l ? `<math>${e}</math>` : e);
        let r = i6.content;
        if ("svg" === l || "mathml" === l) {
          let e = r.firstChild;
          for (; e.firstChild;) r.appendChild(e.firstChild);
          r.removeChild(e);
        }
        t.insertBefore(r, n);
      }
      return [s ? s.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild];
    }
  }),
  oo = (/* unused pure expression or super */ null && (!1));
function oa() {
  return f = oo ? f : rS(os), oo = !0, f;
}
let ou = (...e) => {
    (f || (f = rb(os))).render(...e);
  },
  oc = (...e) => {
    oa().hydrate(...e);
  },
  of = (...e) => {
    let t = (f || (f = rb(os))).createApp(...e),
      {
        mount: n
      } = t;
    return t.mount = e => {
      let l = oh(e);
      if (!l) return;
      let r = t._component;
      O(r) || r.render || r.template || (r.template = l.innerHTML), 1 === l.nodeType && (l.textContent = "");
      let i = n(l, !1, od(l));
      return l instanceof Element && (l.removeAttribute("v-cloak"), l.setAttribute("data-v-app", "")), i;
    }, t;
  },
  op = (...e) => {
    let t = oa().createApp(...e),
      {
        mount: n
      } = t;
    return t.mount = e => {
      let t = oh(e);
      if (t) return n(t, !0, od(t));
    }, t;
  };
function od(e) {
  return e instanceof SVGElement ? "svg" : "function" == typeof MathMLElement && e instanceof MathMLElement ? "mathml" : void 0;
}
function oh(e) {
  return P(e) ? document.querySelector(e) : e;
}
let og = (/* unused pure expression or super */ null && (!1)),
  ov = () => {
    og || (og = !0, s0.getSSRProps = ({
      value: e
    }) => ({
      value: e
    }), s6.getSSRProps = ({
      value: e
    }, t) => {
      if (t.props && eu(t.props.value, e)) return {
        checked: !0
      };
    }, s1.getSSRProps = ({
      value: e
    }, t) => {
      if (k(e)) {
        if (t.props && ec(e, t.props.value) > -1) return {
          checked: !0
        };
      } else if (A(e)) {
        if (t.props && e.has(t.props.value)) return {
          checked: !0
        };
      } else if (e) return {
        checked: !0
      };
    }, s9.getSSRProps = (e, t) => {
      if ("string" != typeof t.type) return;
      let n = s7(t.type.toUpperCase(), t.props && t.props.type);
      if (n.getSSRProps) return n.getSSRProps(e, t);
    }, sh.getSSRProps = ({
      value: e
    }) => {
      if (!e) return {
        style: {
          display: "none"
        }
      };
    });
  },
  om = () => {};


/***/ }),

/***/ 23884:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = void 0;
var METADATA_KEY = __webpack_require__(94725);
var metadata_1 = __webpack_require__(88390);
var traverseAncerstors = function (request, constraint) {
  var parent = request.parentRequest;
  if (parent !== null) {
    return constraint(parent) ? true : traverseAncerstors(parent, constraint);
  } else {
    return false;
  }
};
exports.traverseAncerstors = traverseAncerstors;
var taggedConstraint = function (key) {
  return function (value) {
    var constraint = function (request) {
      return request !== null && request.target !== null && request.target.matchesTag(key)(value);
    };
    constraint.metaData = new metadata_1.Metadata(key, value);
    return constraint;
  };
};
exports.taggedConstraint = taggedConstraint;
var namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);
exports.namedConstraint = namedConstraint;
var typeConstraint = function (type) {
  return function (request) {
    var binding = null;
    if (request !== null) {
      binding = request.bindings[0];
      if (typeof type === "string") {
        var serviceIdentifier = binding.serviceIdentifier;
        return serviceIdentifier === type;
      } else {
        var constructor = request.bindings[0].implementationType;
        return type === constructor;
      }
    }
    return false;
  };
};
exports.typeConstraint = typeConstraint;

/***/ }),

/***/ 24984:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.multiBindToService = void 0;
exports.multiBindToService = function (container) {
  return function (service) {
    return function () {
      var types = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        types[_i] = arguments[_i];
      }
      return types.forEach(function (t) {
        return container.bind(t).toService(service);
      });
    };
  };
};

/***/ }),

/***/ 27718:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.STACK_OVERFLOW = exports.CIRCULAR_DEPENDENCY_IN_FACTORY = exports.POST_CONSTRUCT_ERROR = exports.MULTIPLE_POST_CONSTRUCT_METHODS = exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = exports.ARGUMENTS_LENGTH_MISMATCH = exports.INVALID_DECORATOR_OPERATION = exports.INVALID_TO_SELF_VALUE = exports.INVALID_FUNCTION_BINDING = exports.INVALID_MIDDLEWARE_RETURN = exports.NO_MORE_SNAPSHOTS_AVAILABLE = exports.INVALID_BINDING_TYPE = exports.NOT_IMPLEMENTED = exports.CIRCULAR_DEPENDENCY = exports.UNDEFINED_INJECT_ANNOTATION = exports.MISSING_INJECT_ANNOTATION = exports.MISSING_INJECTABLE_ANNOTATION = exports.NOT_REGISTERED = exports.CANNOT_UNBIND = exports.AMBIGUOUS_MATCH = exports.KEY_NOT_FOUND = exports.NULL_ARGUMENT = exports.DUPLICATED_METADATA = exports.DUPLICATED_INJECTABLE_DECORATOR = void 0;
exports.DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
exports.DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
exports.NULL_ARGUMENT = "NULL argument";
exports.KEY_NOT_FOUND = "Key Not Found";
exports.AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
exports.CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
exports.NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
exports.MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
exports.MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
exports.UNDEFINED_INJECT_ANNOTATION = function (name) {
  return "@inject called with undefined this could mean that the class " + name + " has " + "a circular dependency problem. You can use a LazyServiceIdentifer to  " + "overcome this limitation.";
};
exports.CIRCULAR_DEPENDENCY = "Circular dependency found:";
exports.NOT_IMPLEMENTED = "Sorry, this feature is not fully implemented yet.";
exports.INVALID_BINDING_TYPE = "Invalid binding type:";
exports.NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
exports.INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
exports.INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
exports.INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is " + "used as service identifier";
exports.INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators " + "must be applied to the parameters of a class constructor or a class property.";
exports.ARGUMENTS_LENGTH_MISMATCH = function () {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return "The number of constructor arguments in the derived class " + (values[0] + " must be >= than the number of constructor arguments of its base class.");
};
exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options " + "must be an object.";
exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = "Invalid Container option. Default scope must " + "be a string ('singleton' or 'transient').";
exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must " + "be a boolean";
exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must " + "be a boolean";
exports.MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
exports.POST_CONSTRUCT_ERROR = function () {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return "@postConstruct error in class " + values[0] + ": " + values[1];
};
exports.CIRCULAR_DEPENDENCY_IN_FACTORY = function () {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return "It looks like there is a circular dependency " + ("in one of the '" + values[0] + "' bindings. Please investigate bindings with") + ("service identifier '" + values[1] + "'.");
};
exports.STACK_OVERFLOW = "Maximum call stack size exceeded";

/***/ }),

/***/ 27802:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = void 0;
var BindingScopeEnum = {
  Request: "Request",
  Singleton: "Singleton",
  Transient: "Transient"
};
exports.BindingScopeEnum = BindingScopeEnum;
var BindingTypeEnum = {
  ConstantValue: "ConstantValue",
  Constructor: "Constructor",
  DynamicValue: "DynamicValue",
  Factory: "Factory",
  Function: "Function",
  Instance: "Instance",
  Invalid: "Invalid",
  Provider: "Provider"
};
exports.BindingTypeEnum = BindingTypeEnum;
var TargetTypeEnum = {
  ClassProperty: "ClassProperty",
  ConstructorArgument: "ConstructorArgument",
  Variable: "Variable"
};
exports.TargetTypeEnum = TargetTypeEnum;

/***/ }),

/***/ 29600:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ CosmosSrpCustomEvents)
/* harmony export */ });
var CosmosSrpCustomEvents;
(function (CosmosSrpCustomEvents) {
    CosmosSrpCustomEvents["FilterLoadStart"] = "do.filterloadstart";
    CosmosSrpCustomEvents["FilterLoadEnd"] = "do.filterloadend";
    CosmosSrpCustomEvents["VehicleLoadStart"] = "do.vehicleloadstart";
    CosmosSrpCustomEvents["VehicleLoadEnd"] = "do.vehicleloadend";
    CosmosSrpCustomEvents["VehicleCompareCheckboxChange"] = "do.vehiclecomparecheckboxchange";
    CosmosSrpCustomEvents["VehicleCompareButtonClick"] = "do.vehiclecomparebuttonclick";
    CosmosSrpCustomEvents["VehicleCompareCheckboxToggle"] = "do.vehiclecomparecheckboxtoggle";
    CosmosSrpCustomEvents["VehicleCompareButtonDisplay"] = "do.vehiclecomparebuttondisplay";
    CosmosSrpCustomEvents["VehicleCompareCountRequest"] = "do.vehiclecomparerequestcount";
    CosmosSrpCustomEvents["VehicleCompareCountResponse"] = "do.vehiclecompareresponsecount";
    CosmosSrpCustomEvents["SearchValetCleared"] = "do.searchvaletcleared";
    CosmosSrpCustomEvents["RemoveFilterPill"] = "do.removeFilterPill";
    CosmosSrpCustomEvents["SwitchPricingTab"] = "do.switchPricingTab";
    CosmosSrpCustomEvents["VehicleCardLoaded"] = "do.vehiclecardloaded";
    CosmosSrpCustomEvents["VehicleDeckLoaded"] = "do.vehicledeckloaded";
    CosmosSrpCustomEvents["VehicleSearchEnd"] = "do.vehiclesearchend";
    CosmosSrpCustomEvents["ClearFilters"] = "do.clearFilters";
    CosmosSrpCustomEvents["UpdateFilterState"] = "do.updateFilterState";
    CosmosSrpCustomEvents["MobileFilterPanelOpened"] = "do.mobileFilterPanelOpened";
    CosmosSrpCustomEvents["PricingVisibilityAdjusted"] = "do.pricingVisibilityAdjusted";
})(CosmosSrpCustomEvents || (CosmosSrpCustomEvents = {}));


/***/ }),

/***/ 30721:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  d: () => (/* binding */ SrpWasabiGeneral)
});

// EXTERNAL MODULE: ./node_modules/inversify/lib/inversify.js
var inversify = __webpack_require__(90260);
// EXTERNAL MODULE: ./src/types/types.ts
var types = __webpack_require__(45644);
;// ./src/components/searchFilter/srpWasab_PageNav.ts
class SrpWasabiPageNav {
    srpFiltersMore() {
        $('.srp-filters-more .toggle').click(function () {
            if ($('.srp-filters-more').hasClass('active')) {
                $('.srp-filters-more').removeClass('active');
            }
            else {
                $('.srp-filters-more').addClass('active');
            }
        });
        $(document).on('click', function (event) {
            if (!$(event.target).closest('.srp-filters-more').length && !$(event.target).closest('.filter-item-minimized button').length) {
                if ($('.srp-filters-more').hasClass('active')) {
                    $('.srp-filters-more').removeClass('active');
                }
            }
        });
    }
}

// EXTERNAL MODULE: ./src/utilities/jQueryHelper/jQueryHelper.ts
var jQueryHelper = __webpack_require__(82781);
;// ./src/components/searchFilter/srpWasabi_General.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




let SrpWasabiGeneral = class SrpWasabiGeneral {
    constructor(toggleService) {
        this.SrpWasabiFilterMobileElem = null;
        this.SrpWasabiTotalFilterNum = null;
        this.SrpWasabiMaxWidth991 = null;
        this.rangeArray = [];
        this.toggleService = toggleService;
    }
    initialize() {
        //Only used for ILP
        if (window.location.pathname.toLowerCase().indexOf("inventorylineup.aspx") > -1) {
            this.addCheckboxClickEvents();
            //instantiate the filter numbers
            this.initializeCheckFilterNum();
        }
        this._srpWasabiPageNav = new SrpWasabiPageNav();
        window.addEventListener("resize", () => {
            this.Update();
        }, { passive: true });
        window.addEventListener("scroll", () => {
            this.Update();
        }, { passive: true });
        this.refreshVariables();
        this._srpWasabiPageNav.srpFiltersMore();
        this.refineSilderMobile();
        this.disableFilterPanels();
        this.initializeFilterScrollIntoViewUponExpansion();
    }
    Update() {
        this.refreshVariables();
    }
    CalculateFunction() {
        var _a, _b;
        var checkboxNum = (_b = (_a = this.srpFilterElem) === null || _a === void 0 ? void 0 : _a.querySelectorAll('input[type=checkbox]:checked')) === null || _b === void 0 ? void 0 : _b.length;
        const ranges = document.querySelectorAll(".range");
        ranges.forEach((elem) => {
            if (elem.value !== "") {
                this.rangeArray.push(this);
            }
        });
        this.SrpWasabiTotalFilterNum = checkboxNum + this.rangeArray.length;
    }
    initializeCheckFilterNum() {
        var _a, _b;
        this.srpFilterElem = document.getElementById("srp_filter");
        const customCheckboxes = (_a = this.srpFilterElem) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.display_child, .custom-checkbox');
        customCheckboxes === null || customCheckboxes === void 0 ? void 0 : customCheckboxes.forEach((checkbox) => {
            checkbox.addEventListener("click", () => {
                setTimeout(() => {
                    this.CalculateFunction();
                }, 100);
            });
        });
        const filterInputs = (_b = this.srpFilterElem) === null || _b === void 0 ? void 0 : _b.querySelectorAll('input');
        filterInputs === null || filterInputs === void 0 ? void 0 : filterInputs.forEach((input) => {
            input.addEventListener("blur", () => {
                this.CalculateFunction();
            });
        });
    }
    // refine slider selected
    addCheckboxClickEvents() {
        $(document).on('click', '#srp_filter .collapse-options .tile_display .tile_display_child, #srp_filter .collapse-options .list_display .list_display_child', function () {
            var targetedID = $(this).attr('data-target');
            if ($(this).find('input').is(':checked')) {
                $(this).addClass('tile_selected');
            }
            else {
                $(this).removeClass('tile_selected');
                if (targetedID) {
                    $(this).parents('.list_display').find('' + targetedID + ' .collapse-options-sub .display_child.list_display_child').removeClass('tile_selected');
                    $(this).parents('.list_display').find('' + targetedID + ' .collapse-options-sub .display_child.list_display_child input').removeAttr('checked');
                }
            }
        });
    }
    refreshVariables() {
        this.SrpWasabiFilterMobileElem = $('body');
        this.SrpWasabiMaxWidth991 = window.matchMedia('(max-width: 991px)');
    }
    // disable filter panels default
    disableFilterPanels() {
        jQueryHelper/* JQueryHelper */.$.SafeApplyCollapse($('#srp_filter .collapse'), {
            'toggle': false
        });
    }
    /**
     * Initialize event listeners to scroll an expanded filter into view. Due to
     * how the bootstrap collapse component works, we must use jQuery to hook
     * into the events fired by that component.
     * @see {@link https://getbootstrap.com/docs/4.0/components/collapse/ }
     */
    initializeFilterScrollIntoViewUponExpansion() {
        $("#srp_filter .panel .collapse-options")
            .on("shown.bs.collapse", function () {
            var parent = this.closest(".panel");
            try {
                parent.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest"
                });
            }
            catch (_a) {
                // Fallback for browsers without support for scrollIntoViewOptions
                parent.scrollIntoView(false);
            }
        });
    }
    // refine silder mobile
    refineSilderMobile() {
        $('button.filter-modal-toggle').on('click', (e) => {
            e.stopImmediatePropagation();
            this.addFilterMobileBodyClasses();
            this.addFilterMobileBodySpecClasses();
        });
        $('.shade, .close_sticky, .close_sticky_mod, .search_btn.search_sticky').on('click', () => {
            this.removeBodyClasses();
            this.removeBodySpecClasses();
        });
    }
    //refine slider on mobile
    addFilterMobileBodyClasses() {
        this.SrpWasabiFilterMobileElem.addClass('filterMobile');
        const filterPanel = document.getElementById("filterPanel");
        if (filterPanel) {
            filterPanel.classList.remove("hidden");
        }
        // If Mobile filterPanel ever gets opened, the Desktop filterPanel will remain open if transitioning to it.
        // Remove the 'wasabi_srp--no-grid' (which should be present when Desktop filterPanel is closed) class
        // when the following transition occurs:
        // Deskptop filterPanel closed -> Mobile filterPanel opened -> Desktop filterPanel opened
        const wasabiSrp = document.querySelector(".wasabi_srp");
        if (filterPanel && wasabiSrp) {
            wasabiSrp.classList.remove("wasabi_srp--no-grid");
        }
    }
    addFilterMobileBodySpecClasses() {
        this.SrpWasabiFilterMobileElem.addClass('filterMobileBodySpec');
    }
    removeBodyClasses() {
        this.SrpWasabiFilterMobileElem.removeClass('filterMobile');
    }
    removeBodySpecClasses() {
        window.setTimeout(() => {
            this.SrpWasabiFilterMobileElem.removeClass('filterMobileBodySpec');
        }, 350);
    }
};
SrpWasabiGeneral = __decorate([
    (0,inversify/* injectable */._G)(),
    __param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IToggleService)),
    __metadata("design:paramtypes", [Object])
], SrpWasabiGeneral);



/***/ }),

/***/ 31560:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ SrpScrollType)
/* harmony export */ });
var SrpScrollType;
(function (SrpScrollType) {
    SrpScrollType[SrpScrollType["Pagination"] = 0] = "Pagination";
    SrpScrollType[SrpScrollType["InfiniteScroll"] = 1] = "InfiniteScroll";
})(SrpScrollType || (SrpScrollType = {}));


/***/ }),

/***/ 33341:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BindingWhenOnSyntax = void 0;
var binding_on_syntax_1 = __webpack_require__(15078);
var binding_when_syntax_1 = __webpack_require__(74533);
var BindingWhenOnSyntax = function () {
  function BindingWhenOnSyntax(binding) {
    this._binding = binding;
    this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
    this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
  }
  BindingWhenOnSyntax.prototype.when = function (constraint) {
    return this._bindingWhenSyntax.when(constraint);
  };
  BindingWhenOnSyntax.prototype.whenTargetNamed = function (name) {
    return this._bindingWhenSyntax.whenTargetNamed(name);
  };
  BindingWhenOnSyntax.prototype.whenTargetIsDefault = function () {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  };
  BindingWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenTargetTagged(tag, value);
  };
  BindingWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
    return this._bindingWhenSyntax.whenInjectedInto(parent);
  };
  BindingWhenOnSyntax.prototype.whenParentNamed = function (name) {
    return this._bindingWhenSyntax.whenParentNamed(name);
  };
  BindingWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenParentTagged(tag, value);
  };
  BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
  };
  BindingWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
    return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
  };
  BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
  };
  BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
  };
  BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(name);
  };
  BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
  };
  BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
  };
  BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
  };
  BindingWhenOnSyntax.prototype.onActivation = function (handler) {
    return this._bindingOnSyntax.onActivation(handler);
  };
  return BindingWhenOnSyntax;
}();
exports.BindingWhenOnSyntax = BindingWhenOnSyntax;

/***/ }),

/***/ 34131:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.QueryableString = void 0;
var QueryableString = function () {
  function QueryableString(str) {
    this.str = str;
  }
  QueryableString.prototype.startsWith = function (searchString) {
    return this.str.indexOf(searchString) === 0;
  };
  QueryableString.prototype.endsWith = function (searchString) {
    var reverseString = "";
    var reverseSearchString = searchString.split("").reverse().join("");
    reverseString = this.str.split("").reverse().join("");
    return this.startsWith.call({
      str: reverseString
    }, reverseSearchString);
  };
  QueryableString.prototype.contains = function (searchString) {
    return this.str.indexOf(searchString) !== -1;
  };
  QueryableString.prototype.equals = function (compareString) {
    return this.str === compareString;
  };
  QueryableString.prototype.value = function () {
    return this.str;
  };
  return QueryableString;
}();
exports.QueryableString = QueryableString;

/***/ }),

/***/ 34567:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ VehicleImageCarousel),
/* harmony export */   O: () => (/* binding */ Direction)
/* harmony export */ });
/* harmony import */ var _utilities_performanceHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69185);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

var Direction;
(function (Direction) {
    Direction[Direction["LeftRight"] = 0] = "LeftRight";
    Direction[Direction["UpDown"] = 1] = "UpDown";
})(Direction || (Direction = {}));
var CarouselItemType;
(function (CarouselItemType) {
    CarouselItemType["image"] = "image";
    CarouselItemType["video"] = "video";
    CarouselItemType["interior360"] = "interior360";
    CarouselItemType["spincar"] = "spincar";
})(CarouselItemType || (CarouselItemType = {}));
/*
 * Description: VehicleImageCarousel is a carousel component that consists of
 * both mobile and desktop views.
 *
 * carouselParent: wrapper element that contains the entire carousel
 * rootClassName: the classname for the hero-images. Default: hero-carousel
 */
class VehicleImageCarousel {
    constructor(carouselParent, rootClassName, thumbnailDesktopScrollContainer, thumbnailDesktopScrollDirection, thumbnailMobileScrollableContainer, thumbnailMobileScrollDirection, carouselItemsContainerWidth) {
        var _a, _b;
        this._buttonClassName = "";
        this._carouselItemContainer = "hero-carousel__items";
        this._currentIndex = 0;
        this._carouselScroll = {
            isMouseDown: false,
            isScrolling: false,
            x1: 0,
            x2: 0
        };
        this._selectedThumbnailClasses = ["border-cta", "thumbnail--selected"];
        this._hiddenClass = "hidden";
        this._touchSwipe = false;
        this.scrollSlides = (elem) => {
            var _a, _b;
            const slideIndex = parseInt((_b = (_a = elem.dataset) === null || _a === void 0 ? void 0 : _a.carouselIndex) !== null && _b !== void 0 ? _b : "0");
            if (this._currentIndex !== slideIndex) {
                this.goToSlide(slideIndex, this._touchSwipe);
            }
        };
        this.selectThumbnail = (selected) => __awaiter(this, void 0, void 0, function* () {
            this.observeHeroImageScrolling(false);
            const slideIndex = Array.from(selected.parentElement.querySelectorAll(".thumbnail")).indexOf(selected);
            yield this.goToSlide(slideIndex, false);
            //give some time for the smooth scrolling to finish so we don"t
            //prematurely fire observer upates when the thumbnails trigger a
            //scroll of the hero images
            window.setTimeout(() => {
                this.observeHeroImageScrolling(true);
            }, 1000);
        });
        /* TEMPORARY - only initialize if carousel is not in SPA (SPA component has its own TS) */
        const isCosmosSpa = (_b = (_a = document.querySelector('.hero-carousel')) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.contains('hero-carousel--component');
        if (!isCosmosSpa) {
            this.initialize(carouselParent, rootClassName, thumbnailDesktopScrollContainer, thumbnailDesktopScrollDirection, thumbnailMobileScrollableContainer, thumbnailMobileScrollDirection, carouselItemsContainerWidth);
        }
    }
    initialize(carouselParent, rootClassName, thumbnailDesktopScrollContainer, thumbnailDesktopScrollDirection, thumbnailMobileScrollableContainer, thumbnailMobileScrollDirection, carouselItemsContainerWidth) {
        return __awaiter(this, void 0, void 0, function* () {
            //setup scrolling for related thumbnails
            this._desktopThumbsScrollable = thumbnailDesktopScrollContainer ? true : false;
            this._mobileThumbsScrollable = thumbnailMobileScrollableContainer ? true : false;
            this._thumbnailDesktopScrollContainer = thumbnailDesktopScrollContainer;
            this._thumbnailDesktopScrollDirection = thumbnailDesktopScrollDirection;
            this._thumbnailMobileScrollableContainer = thumbnailMobileScrollableContainer;
            this._thumbnailMobileScrollDirection = thumbnailMobileScrollDirection;
            this.carouselParent = carouselParent !== null && carouselParent !== void 0 ? carouselParent : document.querySelector("body");
            this.rootClassName = rootClassName !== null && rootClassName !== void 0 ? rootClassName : "hero-carousel";
            yield this.getElements(carouselItemsContainerWidth);
            this._scrollX = 0;
            if (this._carouselImageCount === 0 && this._controls) {
                this._controls.classList.add(this._hiddenClass);
            }
            this.toggleControls();
            this.addListeners(this, "mouse");
            if (this._desktopThumbsScrollable) {
                this.addSelectedClasses(this._desktopThumbnails[this._currentIndex]);
            }
            if (this._mobileThumbsScrollable) {
                this.addSelectedClasses(this._mobileThumbnails[this._currentIndex]);
            }
        });
    }
    getElements(containerWidth) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        return __awaiter(this, void 0, void 0, function* () {
            this._carouselElement = (_a = this.carouselParent.querySelector(`.${this.rootClassName}`)) !== null && _a !== void 0 ? _a : null;
            this._counterBadgeElement = (_b = this.carouselParent.querySelector(".hero-carousel__image-counter")) !== null && _b !== void 0 ? _b : null;
            this._counter = (_c = this.carouselParent.querySelector(".image-counter__current")) !== null && _c !== void 0 ? _c : null;
            this._buttonClassName = `${this.rootClassName}__controls`;
            //carousel controls
            this._controls = (_d = this._carouselElement.querySelector(`.${this._buttonClassName}`)) !== null && _d !== void 0 ? _d : null;
            this._previousButton = this.getButton(this._controls, "previous");
            this._nextButton = this.getButton(this._controls, "next");
            this._items = this.carouselParent.querySelectorAll(`.${this.rootClassName} .${this.rootClassName}__item`);
            this._carouselImageCount = this._items.length;
            this._dots = this.carouselParent.querySelectorAll(".dot");
            //mobile thumbnail controls
            this._thumbnailMobileScrollableContainerElem = (_e = this.carouselParent.querySelector(`.${this._thumbnailMobileScrollableContainer}`)) !== null && _e !== void 0 ? _e : this.carouselParent.querySelector(".thumbnails--mobile");
            if (this._thumbnailMobileScrollableContainerElem) {
                this._mobileThumbnails = this._thumbnailMobileScrollableContainerElem.querySelectorAll(".thumbnail");
                this._controlsThumbsMobile = (_f = this._thumbnailMobileScrollableContainerElem.querySelector(`.${this._buttonClassName}`)) !== null && _f !== void 0 ? _f : null;
                this._previousButtonThumbsMobile = this.getButton(this._controlsThumbsMobile, "previous");
                this._nextButtonThumbsMobile = this.getButton(this._controlsThumbsMobile, "next");
            }
            //desktop thumbnail controls
            this._thumbnailDesktopScrollContainerElem = (_g = this.carouselParent.querySelector(`.${this._thumbnailDesktopScrollContainer}`)) !== null && _g !== void 0 ? _g : this.carouselParent.querySelector(".thumbnails--desktop");
            if (this._thumbnailDesktopScrollContainerElem) {
                this._desktopThumbnails = this._thumbnailDesktopScrollContainerElem.querySelectorAll(".thumbnail");
                this._controlsThumbsDesktop = (_h = this._thumbnailDesktopScrollContainerElem.querySelector(`.${this._buttonClassName}`)) !== null && _h !== void 0 ? _h : null;
                this._previousButtonThumbsDesktop = this.getButton(this._controlsThumbsDesktop, "previous");
                this._nextButtonThumbsDesktop = this.getButton(this._controlsThumbsDesktop, "next");
            }
            //SITESAA-3503: if we don't pass in a container width, then calculate it.
            if (containerWidth) {
                this._containerWidth = containerWidth;
            }
            else {
                let containerElem = (_k = (_j = this.carouselParent) === null || _j === void 0 ? void 0 : _j.querySelector(`.${this._carouselItemContainer}`)) !== null && _k !== void 0 ? _k : null;
                yield (0,_utilities_performanceHelpers__WEBPACK_IMPORTED_MODULE_0__/* .doBeforeNextRepaint */ .L)(() => {
                    this._containerWidth = containerElem === null || containerElem === void 0 ? void 0 : containerElem.getBoundingClientRect().width;
                });
            }
        });
    }
    getButton(controls, buttonName) {
        var _a, _b;
        if (!controls) {
            return null;
        }
        let btn = (_a = controls.querySelector(`.${this._buttonClassName}--${buttonName}`)) !== null && _a !== void 0 ? _a : null;
        if (!btn) {
            return null;
        }
        // CONPLAT-1944
        // get the big outer button if EnableBiggerHover = true
        if (btn && btn.classList.contains("cursorPointer")) {
            return btn;
        }
        // otherwise, return the inner button
        return (_b = btn.querySelector("button")) !== null && _b !== void 0 ? _b : null;
    }
    addListeners(carousel, eventType) {
        var _a, _b, _c;
        const clickEvent = eventType === "mouse" ? "click" : "touchend";
        const page = document.querySelector('.vdp');
        page === null || page === void 0 ? void 0 : page.setAttribute("data-dotagging-affiliation", window.DlronGlobal_DealerName);
        if (carousel._previousButton) {
            carousel._previousButton.setAttribute("data-dotagging-affiliation", window.DlronGlobal_DealerName);
            carousel._previousButton.addEventListener(clickEvent, (e) => {
                e.preventDefault();
                if (!carousel._carouselScroll.isScrolling) {
                    carousel.goToPreviousSlide();
                }
            });
        }
        if (carousel._nextButton) {
            carousel._nextButton.setAttribute("data-dotagging-affiliation", window.DlronGlobal_DealerName);
            carousel._nextButton.addEventListener(clickEvent, (e) => {
                e.preventDefault();
                if (!carousel._carouselScroll.isScrolling) {
                    carousel.goToNextSlide();
                }
            });
        }
        if (carousel._previousButtonThumbsMobile) {
            carousel._previousButtonThumbsMobile.addEventListener(clickEvent, (e) => {
                e.preventDefault();
                if (!carousel._carouselScroll.isScrolling) {
                    carousel.goToPreviousSlide();
                }
            });
        }
        if (carousel._nextButtonThumbsMobile) {
            carousel._nextButtonThumbsMobile.setAttribute("data-dotagging-affiliation", window.DlronGlobal_DealerName);
            carousel._nextButtonThumbsMobile.addEventListener(clickEvent, (e) => {
                e.preventDefault();
                if (!carousel._carouselScroll.isScrolling) {
                    carousel.goToNextSlide();
                }
            });
        }
        if (carousel._previousButtonThumbsDesktop) {
            carousel._previousButtonThumbsDesktop.setAttribute("data-dotagging-affiliation", window.DlronGlobal_DealerName);
            carousel._previousButtonThumbsDesktop.addEventListener(clickEvent, (e) => {
                e.preventDefault();
                if (!carousel._carouselScroll.isScrolling) {
                    carousel.goToPreviousSlide();
                }
            });
        }
        if (carousel._nextButtonThumbsDesktop) {
            carousel._nextButtonThumbsDesktop.setAttribute("data-dotagging-affiliation", window.DlronGlobal_DealerName);
            carousel._nextButtonThumbsDesktop.addEventListener(clickEvent, (e) => {
                e.preventDefault();
                if (!carousel._carouselScroll.isScrolling) {
                    carousel.goToNextSlide();
                }
            });
        }
        const containerElem = (_a = this.carouselParent.querySelector(`.${this._carouselItemContainer}`)) !== null && _a !== void 0 ? _a : null;
        if (containerElem) {
            const swipeObserver = new ResizeObserver((entries) => {
                for (let entry of entries) {
                    this._containerWidth = entry.contentRect.width;
                    this._scrollX = this._currentIndex * this._containerWidth;
                    entry.target.scrollTo({ left: this._scrollX, behavior: "smooth" });
                }
            });
            swipeObserver.observe(containerElem);
        }
        // We only want to throw events from IntersectionObserver if it is a result of 
        // a touch swipe
        this.carouselParent.querySelector(`.hero-carousel__items`).addEventListener("touchstart", (ev) => {
            this._touchSwipe = true;
        });
        //intersection observer to capture hero image scroll events to track
        //image counts and thumbnail hilighting on mobile
        let firstAfterPageLoad = true;
        this._heroIntersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                //We check the window's width to make sure this is only used when in mobile view
                if (entry.isIntersecting && window.innerWidth < 992) {
                    // we don't want to send the event when the page loads on each first photo
                    if (firstAfterPageLoad) {
                        firstAfterPageLoad = false;
                    }
                    else {
                        this.scrollSlides(entry.target);
                    }
                    this._touchSwipe = false;
                }
            });
        }, {
            root: this.carouselParent.querySelector(`.${this.rootClassName} .hero-carousel__items`),
            threshold: 0.51,
        });
        this.observeHeroImageScrolling(true);
        // When clicking on a thumbnail, it scrolls the carousel to the image that
        // matches the thumbnail
        (_b = this._desktopThumbnails) === null || _b === void 0 ? void 0 : _b.forEach((element) => {
            if (this._desktopThumbsScrollable) {
                element.addEventListener(clickEvent, (e) => __awaiter(this, void 0, void 0, function* () {
                    e.preventDefault();
                    const selected = e.target.closest(".thumbnail");
                    this.selectThumbnail(selected);
                }));
            }
        });
        (_c = this._mobileThumbnails) === null || _c === void 0 ? void 0 : _c.forEach((element) => {
            if (this._mobileThumbsScrollable) {
                element.addEventListener(clickEvent, (e) => __awaiter(this, void 0, void 0, function* () {
                    e.preventDefault();
                    const selected = e.target.closest(".thumbnail");
                    this.selectThumbnail(selected);
                }));
            }
        });
    }
    observeHeroImageScrolling(observe) {
        this.carouselParent.querySelectorAll(`.${this.rootClassName} .hero-carousel__items .hero-carousel__item`).forEach((elem) => {
            if (observe) {
                this._heroIntersectionObserver.observe(elem);
            }
            else {
                this._heroIntersectionObserver.unobserve(elem);
            }
        });
    }
    removeSelectedClasses(thumbnail) {
        if (thumbnail) {
            thumbnail.classList.remove(...this._selectedThumbnailClasses);
        }
    }
    addSelectedClasses(thumbnail) {
        if (thumbnail) {
            thumbnail.classList.add(...this._selectedThumbnailClasses);
        }
    }
    goToPreviousSlide() {
        let slideIndex = this._currentIndex - 1;
        if (slideIndex === -1) {
            slideIndex = this._carouselImageCount - 1;
        }
        this.goToSlide(slideIndex, false);
    }
    goToNextSlide() {
        let slideIndex = this._currentIndex + 1;
        if (slideIndex === this._carouselImageCount) {
            slideIndex = 0;
        }
        this.goToSlide(slideIndex, false);
    }
    goToSlide(slideIndex, scrollEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._mobileThumbsScrollable) {
                this.removeSelectedClasses(this._mobileThumbnails[this._currentIndex]);
            }
            if (this._desktopThumbsScrollable) {
                this.removeSelectedClasses(this._desktopThumbnails[this._currentIndex]);
            }
            if (this._dots.length > 0) {
                this.updateDots(this._currentIndex, slideIndex);
            }
            if (scrollEvent) {
                this.dispatchSwipeImageTagging(slideIndex);
            }
            this._currentIndex = slideIndex;
            //scroll the carousel hero image
            if (!scrollEvent) {
                yield this.scrollIntoView(this._items[this._currentIndex], this._carouselItemContainer, Direction.LeftRight);
            }
            //scroll thumbnails into view
            if (this._mobileThumbsScrollable) {
                const thumbnail = this._mobileThumbnails[this._currentIndex];
                this.addSelectedClasses(thumbnail);
                yield this.scrollIntoView(thumbnail, this._thumbnailMobileScrollableContainer, this._thumbnailMobileScrollDirection);
            }
            if (this._desktopThumbsScrollable) {
                const thumbnail = this._desktopThumbnails[this._currentIndex];
                this.addSelectedClasses(thumbnail);
                yield this.scrollIntoView(thumbnail, this._thumbnailDesktopScrollContainer, this._thumbnailDesktopScrollDirection);
            }
            this.toggleControls();
            if (this._dots.length === 0) {
                this.updateCounter();
            }
            //show/hide special items type, TPIs like spincar, videos, etc.
            this.renderCarouselContent();
        });
    }
    getCurrentItemElement() {
        return this._items[this._currentIndex];
    }
    getSelectedItemType() {
        const currentItem = this.getCurrentItemElement();
        if (!currentItem) {
            return CarouselItemType.image;
        }
        switch (currentItem.dataset.carouselContentType) {
            case "video":
                return CarouselItemType.video;
            case "360interior":
                return CarouselItemType.interior360;
            case "spincar":
                return CarouselItemType.spincar;
            default:
                return CarouselItemType.image;
        }
    }
    renderCarouselContent() {
        const selectedItemType = this.getSelectedItemType();
    }
    toggleControls() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const isFirstSlide = this._currentIndex === 0;
        const isLastSlide = this._currentIndex === this._carouselImageCount - 1;
        (_a = this._previousButton) === null || _a === void 0 ? void 0 : _a.classList.remove(this._hiddenClass);
        (_b = this._nextButton) === null || _b === void 0 ? void 0 : _b.classList.remove(this._hiddenClass);
        if (this._previousButton) {
            this._previousButton.disabled = false;
        }
        if (this._nextButton) {
            this._nextButton.disabled = false;
        }
        (_c = this._previousButtonThumbsMobile) === null || _c === void 0 ? void 0 : _c.classList.remove(this._hiddenClass);
        (_d = this._nextButtonThumbsMobile) === null || _d === void 0 ? void 0 : _d.classList.remove(this._hiddenClass);
        (_e = this._nextButtonThumbsDesktop) === null || _e === void 0 ? void 0 : _e.classList.remove(this._hiddenClass);
        (_f = this._previousButtonThumbsDesktop) === null || _f === void 0 ? void 0 : _f.classList.remove(this._hiddenClass);
        if (isFirstSlide) {
            (_g = this._previousButton) === null || _g === void 0 ? void 0 : _g.classList.add(this._hiddenClass);
            if (this._previousButton) {
                this._previousButton.disabled = true;
            }
            (_h = this._previousButtonThumbsDesktop) === null || _h === void 0 ? void 0 : _h.classList.add(this._hiddenClass);
            (_j = this._previousButtonThumbsMobile) === null || _j === void 0 ? void 0 : _j.classList.add(this._hiddenClass);
        }
        if (isLastSlide) {
            (_k = this._nextButton) === null || _k === void 0 ? void 0 : _k.classList.add(this._hiddenClass);
            if (this._nextButton) {
                this._nextButton.disabled = true;
            }
            (_l = this._nextButtonThumbsMobile) === null || _l === void 0 ? void 0 : _l.classList.add(this._hiddenClass);
            (_m = this._nextButtonThumbsDesktop) === null || _m === void 0 ? void 0 : _m.classList.add(this._hiddenClass);
        }
    }
    updateDots(currentIndex, nextIndex) {
        const dot = this._dots[currentIndex];
        dot === null || dot === void 0 ? void 0 : dot.classList.remove("active");
        const nextDot = this._dots[nextIndex];
        nextDot === null || nextDot === void 0 ? void 0 : nextDot.classList.add("active");
    }
    updateCounter() {
        var _a, _b;
        const totalImageCountRaw = (_b = (_a = this._counterBadgeElement) === null || _a === void 0 ? void 0 : _a.dataset) === null || _b === void 0 ? void 0 : _b.imageCount;
        let totalImageCount = 0;
        let newIndex = this._currentIndex;
        if (totalImageCountRaw != null) {
            totalImageCount = parseInt(totalImageCountRaw);
        }
        /* +1 to account for 0-based index */
        if (!isNaN(totalImageCount)
            && totalImageCount > 0
            && this._currentIndex + 1 > totalImageCount) {
            newIndex = this._currentIndex - 1;
        }
        /* +1 to account for 0-based index */
        this._counter.innerHTML = (newIndex + 1).toString();
    }
    scrollIntoView(elem, containerSelector, scrollDirection) {
        return __awaiter(this, void 0, void 0, function* () {
            //NOTE: scrollIntoView() does not play well when scrolling multiple elements simultaneously
            //      so we have opted to leverage scrollTo which does allow this
            //      Additionally, scrollable items that are hidden will have a getBoundingClientRect() of 0.
            //      So, after scrolling the carousel in desktop view switching to mobile view will not show
            //      the highlighted thumbnail because we could not scroll it into view since it was hidden
            if (!elem) {
                return;
            }
            let containerElem = this.carouselParent.querySelector(`.${containerSelector}`);
            if (!containerElem) {
                return;
            }
            let position;
            if (scrollDirection === Direction.LeftRight) {
                yield (0,_utilities_performanceHelpers__WEBPACK_IMPORTED_MODULE_0__/* .doBeforeNextRepaint */ .L)(() => {
                    position = elem.offsetLeft - (containerElem.getBoundingClientRect().width - elem.getBoundingClientRect().width) / 2;
                });
                containerElem.scrollTo({ left: position, behavior: "smooth" });
            }
            else {
                yield (0,_utilities_performanceHelpers__WEBPACK_IMPORTED_MODULE_0__/* .doBeforeNextRepaint */ .L)(() => {
                    position = elem.offsetTop - (containerElem.getBoundingClientRect().height - elem.getBoundingClientRect().height) / 2;
                });
                containerElem.scrollTo({ top: position, behavior: "smooth" });
            }
        });
    }
    scrollToItem(item) {
        var _a, _b;
        const elem = item;
        const index = (_b = parseInt((_a = elem === null || elem === void 0 ? void 0 : elem.dataset) === null || _a === void 0 ? void 0 : _a.imageNum)) !== null && _b !== void 0 ? _b : 0;
        this.goToSlide(index - 1, false);
    }
    dispatchSwipeImageTagging(slideIndex) {
        let eventAction;
        let eventActionResult;
        if (this._currentIndex < slideIndex) {
            eventAction = "swipe_left";
            eventActionResult = "increase";
        }
        else if (this._currentIndex > slideIndex) {
            eventAction = "swipe_right";
            eventActionResult = "decrease";
        }
        else {
            return;
        }
        const taggingVehicleDetailsElement = this._carouselElement.closest("[data-vehicle-information]");
        const imageLinkElement = taggingVehicleDetailsElement.querySelector(`[tabindex] a`);
        if (taggingVehicleDetailsElement && imageLinkElement) {
            const elementDataset = taggingVehicleDetailsElement.dataset;
            const SwipeEventData = {
                affiliation: `${elementDataset.dotaggingAffiliation || ""}`,
                card_name: `${elementDataset.dotaggingCardName || ""}`,
                context: `${elementDataset.dotaggingContext || ""}`,
                department: `${elementDataset.dotaggingDepartment || ""}`,
                element_color: `${elementDataset.dotaggingElementColor || ""}`,
                element_order: `${slideIndex + 1}`,
                element_position: `${elementDataset.dotaggingElementPosition || ""}`,
                element_subtype: "image",
                element_text: `${elementDataset.dotaggingElementText || ""}`,
                element_title: `${elementDataset.dotaggingElementTitle || ""}`,
                element_type: `${elementDataset.dotaggingElementType || ""}`,
                event: "media_interaction",
                event_action: `${eventAction}`,
                event_action_result: `${eventActionResult}`,
                event_location: `${elementDataset.dotaggingEventLocation || ""}`,
                event_owner: `${imageLinkElement.dataset.dotaggingEventOwner || ""}`,
                flow_name: `${elementDataset.dotaggingFlowName || ""}`,
                flow_outcome: `${elementDataset.dotaggingFlowOutcome || ""}`,
                flow_stage: `${elementDataset.dotaggingFlowStage || ""}`,
                item_category: `${elementDataset.dotaggingItemCategory || ""}`,
                item_color: `${elementDataset.dotaggingItemColor || ""}`,
                item_condition: `${elementDataset.dotaggingItemCondition || ""}`,
                item_fuel_type: `${elementDataset.dotaggingItemFuelType || ""}`,
                item_id: `${elementDataset.dotaggingItemId || ""}`,
                item_make: `${elementDataset.dotaggingItemMake || ""}`,
                item_model: `${elementDataset.dotaggingItemModel || ""}`,
                item_number: `${elementDataset.dotaggingItemNumber || ""}`,
                item_order: `${elementDataset.dotaggingItemOrder || ""}`,
                item_price: `${elementDataset.dotaggingPrice || ""}`,
                item_type: `${elementDataset.dotaggingItemType || ""}`,
                item_variant: `${elementDataset.dotaggingItemVariant || ""}`,
                item_year: `${elementDataset.dotaggingItemYear || ""}`,
                link_url: `${imageLinkElement.getAttribute("href") || ""}`,
                media_type: "gallery",
                product_name: "SRP 2.0|Vehicle Item Details",
            };
            this._carouselElement.dispatchEvent(new CustomEvent("dotagging.event", {
                bubbles: true,
                detail: {
                    data: SwipeEventData
                }
            }));
        }
    }
}


/***/ }),

/***/ 34575:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  L: () => (/* binding */ TranslationService)
});

// EXTERNAL MODULE: ./node_modules/inversify/lib/inversify.js
var inversify = __webpack_require__(90260);
;// ./src/services/translations/translations.ts
class Translations {
    constructor() {
        this.Labels = new Array();
        this.Comments = new Array();
        this.Buttons = new Array();
        this.Titles = new Array();
    }
}

;// ./src/services/translations/translationType.ts
var TranslationType;
(function (TranslationType) {
    TranslationType["Labels"] = "labels";
    TranslationType["Comments"] = "comments";
    TranslationType["Buttons"] = "buttons";
    TranslationType["Titles"] = "titles";
})(TranslationType || (TranslationType = {}));

;// ./src/services/translations/translationStorage.ts
var TranslationStorage;
(function (TranslationStorage) {
    TranslationStorage["Labels"] = "do.translations.labels";
    TranslationStorage["Comments"] = "do.translations.comments";
    TranslationStorage["Buttons"] = "do.translations.buttons";
    TranslationStorage["Titles"] = "do.translations.titles";
})(TranslationStorage || (TranslationStorage = {}));

// EXTERNAL MODULE: ./src/types/types.ts
var types = __webpack_require__(45644);
;// ./src/services/translations/translationService.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





let TranslationService = class TranslationService {
    constructor(dataFetcher) {
        this._dealerId = window.DlronGlobal_DealerId;
        this.dataFetcher = dataFetcher;
    }
    initialize(useLabels = true, useComments = false, useButtons = false, useTitles = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.translations = new Translations();
            const translationPromises = [];
            if (useLabels) {
                translationPromises.push(this.loadTranslations(TranslationType.Labels));
            }
            if (useComments) {
                translationPromises.push(this.loadTranslations(TranslationType.Comments));
            }
            if (useButtons) {
                translationPromises.push(this.loadTranslations(TranslationType.Buttons));
            }
            if (useTitles) {
                translationPromises.push(this.loadTranslations(TranslationType.Titles));
            }
            try {
                yield Promise.all(translationPromises);
            }
            catch (error) {
                console.error("Error loading translations:", error);
            }
        });
    }
    loadTranslations(translationType) {
        return __awaiter(this, void 0, void 0, function* () {
            let storageLocation;
            switch (translationType) {
                case TranslationType.Labels:
                    storageLocation = TranslationStorage.Labels;
                    break;
                case TranslationType.Comments:
                    storageLocation = TranslationStorage.Comments;
                    break;
                case TranslationType.Buttons:
                    storageLocation = TranslationStorage.Buttons;
                    break;
                case TranslationType.Titles:
                    storageLocation = TranslationStorage.Titles;
                    break;
            }
            const translationsFromStorage = sessionStorage.getItem(storageLocation);
            if (translationsFromStorage) {
                const translations = JSON.parse(translationsFromStorage);
                switch (translationType) {
                    case TranslationType.Labels:
                        this.translations.Labels = translations;
                        break;
                    case TranslationType.Comments:
                        this.translations.Comments = translations;
                        break;
                    case TranslationType.Buttons:
                        this.translations.Buttons = translations;
                        break;
                    case TranslationType.Titles:
                        this.translations.Titles = translations;
                        break;
                }
            }
            else {
                const translations = yield this.dataFetcher.fetch(translationType);
                if (!translations) {
                    sessionStorage.setItem(storageLocation, null);
                }
                else {
                    this.processTranslations(translations, translationType, storageLocation);
                }
            }
        });
    }
    processTranslations(translations, translationType, storageLocation) {
        try {
            if (translations) {
                try {
                    switch (translationType) {
                        case TranslationType.Labels:
                            this.translations.Labels = translations["Items"];
                            break;
                        case TranslationType.Comments:
                            this.translations.Comments = translations["Items"];
                            break;
                        case TranslationType.Buttons:
                            this.translations.Buttons = translations["Items"];
                            break;
                        case TranslationType.Titles:
                            this.translations.Titles = translations["Items"];
                            break;
                    }
                    //Store the translations
                    const translationsForStorage = JSON.stringify(translations["Items"]);
                    this.setSessionStorage(storageLocation, translationsForStorage);
                }
                catch (ex) {
                    console.error(`Translations for dealer ID ${this._dealerId} could not be parsed.`);
                }
            }
            else {
                console.error(`Translations for dealer ID ${this._dealerId} not found.`);
            }
        }
        catch (ex) {
            this.setSessionStorage(storageLocation, null);
            console.error(`Error parsing translations for dealer ID ${this._dealerId}`);
        }
    }
    setSessionStorage(storageName, value) {
        if (value) {
            sessionStorage.setItem(storageName, value);
        }
        else {
            sessionStorage.removeItem(storageName);
        }
    }
    getLabel(key) {
        var _a, _b;
        return (_b = (_a = this.translations) === null || _a === void 0 ? void 0 : _a.Labels[key]) !== null && _b !== void 0 ? _b : key;
    }
    getComment(key) {
        var _a, _b;
        return (_b = (_a = this.translations) === null || _a === void 0 ? void 0 : _a.Comments[key]) !== null && _b !== void 0 ? _b : key;
    }
    getButton(key) {
        var _a, _b;
        return (_b = (_a = this.translations) === null || _a === void 0 ? void 0 : _a.Buttons[key]) !== null && _b !== void 0 ? _b : key;
    }
    getTitle(key) {
        var _a, _b;
        return (_b = (_a = this.translations) === null || _a === void 0 ? void 0 : _a.Titles[key]) !== null && _b !== void 0 ? _b : key;
    }
};
TranslationService = __decorate([
    (0,inversify/* injectable */._G)(),
    __param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.ITranslationFetcher)),
    __metadata("design:paramtypes", [Object])
], TranslationService);



/***/ }),

/***/ 35517:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AsyncContainerModule = exports.ContainerModule = void 0;
var id_1 = __webpack_require__(78418);
var ContainerModule = function () {
  function ContainerModule(registry) {
    this.id = id_1.id();
    this.registry = registry;
  }
  return ContainerModule;
}();
exports.ContainerModule = ContainerModule;
var AsyncContainerModule = function () {
  function AsyncContainerModule(registry) {
    this.id = id_1.id();
    this.registry = registry;
  }
  return AsyncContainerModule;
}();
exports.AsyncContainerModule = AsyncContainerModule;

/***/ }),

/***/ 36983:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Lookup = void 0;
var ERROR_MSGS = __webpack_require__(27718);
var Lookup = function () {
  function Lookup() {
    this._map = new Map();
  }
  Lookup.prototype.getMap = function () {
    return this._map;
  };
  Lookup.prototype.add = function (serviceIdentifier, value) {
    if (serviceIdentifier === null || serviceIdentifier === undefined) {
      throw new Error(ERROR_MSGS.NULL_ARGUMENT);
    }
    if (value === null || value === undefined) {
      throw new Error(ERROR_MSGS.NULL_ARGUMENT);
    }
    var entry = this._map.get(serviceIdentifier);
    if (entry !== undefined) {
      entry.push(value);
      this._map.set(serviceIdentifier, entry);
    } else {
      this._map.set(serviceIdentifier, [value]);
    }
  };
  Lookup.prototype.get = function (serviceIdentifier) {
    if (serviceIdentifier === null || serviceIdentifier === undefined) {
      throw new Error(ERROR_MSGS.NULL_ARGUMENT);
    }
    var entry = this._map.get(serviceIdentifier);
    if (entry !== undefined) {
      return entry;
    } else {
      throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
    }
  };
  Lookup.prototype.remove = function (serviceIdentifier) {
    if (serviceIdentifier === null || serviceIdentifier === undefined) {
      throw new Error(ERROR_MSGS.NULL_ARGUMENT);
    }
    if (!this._map.delete(serviceIdentifier)) {
      throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
    }
  };
  Lookup.prototype.removeByCondition = function (condition) {
    var _this = this;
    this._map.forEach(function (entries, key) {
      var updatedEntries = entries.filter(function (entry) {
        return !condition(entry);
      });
      if (updatedEntries.length > 0) {
        _this._map.set(key, updatedEntries);
      } else {
        _this._map.delete(key);
      }
    });
  };
  Lookup.prototype.hasKey = function (serviceIdentifier) {
    if (serviceIdentifier === null || serviceIdentifier === undefined) {
      throw new Error(ERROR_MSGS.NULL_ARGUMENT);
    }
    return this._map.has(serviceIdentifier);
  };
  Lookup.prototype.clone = function () {
    var copy = new Lookup();
    this._map.forEach(function (value, key) {
      value.forEach(function (b) {
        return copy.add(key, b.clone());
      });
    });
    return copy;
  };
  Lookup.prototype.traverse = function (func) {
    this._map.forEach(function (value, key) {
      func(key, value);
    });
  };
  return Lookup;
}();
exports.Lookup = Lookup;

/***/ }),

/***/ 37549:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ContainerSnapshot = void 0;
var ContainerSnapshot = function () {
  function ContainerSnapshot() {}
  ContainerSnapshot.of = function (bindings, middleware) {
    var snapshot = new ContainerSnapshot();
    snapshot.bindings = bindings;
    snapshot.middleware = middleware;
    return snapshot;
  };
  return ContainerSnapshot;
}();
exports.ContainerSnapshot = ContainerSnapshot;

/***/ }),

/***/ 38602:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ AppLocation)
/* harmony export */ });
var AppLocation;
(function (AppLocation) {
    AppLocation[AppLocation["CosmosSrp"] = 0] = "CosmosSrp";
    AppLocation[AppLocation["VehicleCardDeck"] = 1] = "VehicleCardDeck";
})(AppLocation || (AppLocation = {}));


/***/ }),

/***/ 39034:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Request = void 0;
var id_1 = __webpack_require__(78418);
var Request = function () {
  function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {
    this.id = id_1.id();
    this.serviceIdentifier = serviceIdentifier;
    this.parentContext = parentContext;
    this.parentRequest = parentRequest;
    this.target = target;
    this.childRequests = [];
    this.bindings = Array.isArray(bindings) ? bindings : [bindings];
    this.requestScope = parentRequest === null ? new Map() : null;
  }
  Request.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {
    var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);
    this.childRequests.push(child);
    return child;
  };
  return Request;
}();
exports.Request = Request;

/***/ }),

/***/ 41373:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ PricingTypeCookie)
/* harmony export */ });
var PricingType;
(function (PricingType) {
    PricingType["buy"] = "buy";
    PricingType["finance"] = "finance";
    PricingType["lease"] = "lease";
})(PricingType || (PricingType = {}));
class PricingTypeCookie {
    static get currentCookieValue() {
        return window.DealeronCookie.getItem(this.PricingCookieName);
    }
    static setPricingTypeCookieBySort(selectedOption) {
        if (selectedOption) {
            const selectedSortType = selectedOption.dataset.sortType || '';
            const pricingType = PricingType[selectedSortType.toLowerCase()];
            if (pricingType) {
                window.DealeronCookie.setItem(this.PricingCookieName, pricingType);
            }
        }
        else {
            console.error('The selected option was null or undefined when attempting to set the pricing type cookie; expected a document node');
        }
    }
    static setPricingTypeCookie(tabName) {
        const pricingType = PricingType[tabName.toLowerCase()];
        if (pricingType) {
            window.DealeronCookie.setItem(this.PricingCookieName, pricingType);
        }
    }
}
PricingTypeCookie.PricingCookieName = "DLRON_SELECTED_PRICING_TYPE";


/***/ }),

/***/ 42283:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ VehicleService)
/* harmony export */ });
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90260);
/* harmony import */ var _serviceHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17090);
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45644);
/* harmony import */ var _toggles_toggleService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74529);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




let VehicleService = class VehicleService {
    constructor(toggleService, personalizationService) {
        this.rootApiUrl = "/api/vhcliaa";
        this.vehicleCache = {};
        this.getVehicles = (dealerId, pageId, pagination, baseFilter, dynamicCountsSearch) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let url = this.getVehicleApiUrl(dealerId, pageId, pagination, baseFilter, dynamicCountsSearch);
            //Personalization (aka Signals)
            //NOTE: We add this here so we don't have to see it visually show up on the URL every time
            url = (_b = (_a = this.personalizationService) === null || _a === void 0 ? void 0 : _a.addPersonalizationParameters(url)) !== null && _b !== void 0 ? _b : url;
            if (this.toggleService.getToggleStatus(_toggles_toggleService__WEBPACK_IMPORTED_MODULE_3__/* .Toggle */ .lM.DO45165_InitQuickPass2) === true) {
                if (this.vehicleCache[url]) {
                    return this.vehicleCache[url];
                }
                const promise = _serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.sendApiRequest(url);
                this.vehicleCache[url] = promise;
                return promise;
            }
            else {
                return _serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.sendApiRequest(url);
            }
        });
        this.getCompareVehicle = (dealerId, vin) => __awaiter(this, void 0, void 0, function* () {
            const url = this.getCompareVehicleApiUrl(dealerId, vin);
            return _serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.sendApiRequest(url);
        });
        this.getVehicleCardDeck = (dealerId, vins) => __awaiter(this, void 0, void 0, function* () {
            const url = this.getVehicleCardDeckApiUrl(dealerId, vins);
            return _serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.sendApiRequest(url);
        });
        // HELPER METHODS
        this.getVehicleApiUrl = (dealerId, pageId, paginationData = null, baseFilter = null, dynamicCountsSearch = null) => {
            const searchParams = _serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.getBaseApiQueryString(paginationData, dynamicCountsSearch);
            if (baseFilter) {
                //NOTE: Fastly attempts to prevent malicious querystring parameters which can be triggered
                //      by baseFilter parameters. We need to base64 encode the baseFilter to prevent this.
                //      the backend will unencode it before using it.
                _serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.setSearchParam("baseFilter", btoa(baseFilter).replace(/\+/g, "%2B"), searchParams);
            }
            _serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.setSearchParam("displayCardsShown", this.getDisplayCardsShown(paginationData.PageNumber, paginationData.PageSize), searchParams);
            //HACK: don't encode spaces as +, it won't return the results correctly
            const url = `${this.rootApiUrl}/vehicle-pages/cosmos/srp/vehicles/${dealerId}/${pageId}?${_serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.mapArrayToQueryString(searchParams)}`;
            return url;
        };
        this.getCompareVehicleApiUrl = (dealerId, vin) => {
            const url = `${this.rootApiUrl}/inventory/${dealerId}/vehicle-compare?vin=${vin}`;
            return url;
        };
        this.getVehicleCardDeckApiUrl = (dealerId, vins) => {
            const searchParams = _serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.getBaseApiQueryString(null, null);
            const url = `${this.rootApiUrl}/vehicle-card-deck/${dealerId}?vins=${vins}&${_serviceHelpers__WEBPACK_IMPORTED_MODULE_1__/* .ServiceHelpers */ .d.mapArrayToQueryString(searchParams)}&host=${window.location.origin}`;
            return url;
        };
        this.getDisplayCardsShown = (pageNumber, pageSize) => {
            if (pageNumber < 1)
                return 0;
            return (pageNumber - 1) * pageSize;
        };
        this.personalizationService = personalizationService;
        this.vehicleCache = {};
        this.toggleService = toggleService;
    }
};
VehicleService = __decorate([
    (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .injectable */ ._G)(),
    __param(0, (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(_types_types__WEBPACK_IMPORTED_MODULE_2__/* .TYPES */ .Q.IToggleService)),
    __param(1, (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(_types_types__WEBPACK_IMPORTED_MODULE_2__/* .TYPES */ .Q.IPersonalizationService)),
    __metadata("design:paramtypes", [Object, Object])
], VehicleService);



/***/ }),

/***/ 43553:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.resolveInstance = void 0;
var error_msgs_1 = __webpack_require__(27718);
var literal_types_1 = __webpack_require__(27802);
var METADATA_KEY = __webpack_require__(94725);
function _injectProperties(instance, childRequests, resolveRequest) {
  var propertyInjectionsRequests = childRequests.filter(function (childRequest) {
    return childRequest.target !== null && childRequest.target.type === literal_types_1.TargetTypeEnum.ClassProperty;
  });
  var propertyInjections = propertyInjectionsRequests.map(resolveRequest);
  propertyInjectionsRequests.forEach(function (r, index) {
    var propertyName = "";
    propertyName = r.target.name.value();
    var injection = propertyInjections[index];
    instance[propertyName] = injection;
  });
  return instance;
}
function _createInstance(Func, injections) {
  return new (Func.bind.apply(Func, __spreadArrays([void 0], injections)))();
}
function _postConstruct(constr, result) {
  if (Reflect.hasMetadata(METADATA_KEY.POST_CONSTRUCT, constr)) {
    var data = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, constr);
    try {
      result[data.value]();
    } catch (e) {
      throw new Error(error_msgs_1.POST_CONSTRUCT_ERROR(constr.name, e.message));
    }
  }
}
function resolveInstance(constr, childRequests, resolveRequest) {
  var result = null;
  if (childRequests.length > 0) {
    var constructorInjectionsRequests = childRequests.filter(function (childRequest) {
      return childRequest.target !== null && childRequest.target.type === literal_types_1.TargetTypeEnum.ConstructorArgument;
    });
    var constructorInjections = constructorInjectionsRequests.map(resolveRequest);
    result = _createInstance(constr, constructorInjections);
    result = _injectProperties(result, childRequests, resolveRequest);
  } else {
    result = new constr();
  }
  _postConstruct(constr, result);
  return result;
}
exports.resolveInstance = resolveInstance;

/***/ }),

/***/ 45644:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ TYPES),
/* harmony export */   x: () => (/* binding */ PROVIDERS)
/* harmony export */ });
//Types used in our non-vue architecture for DI support
const TYPES = {
    IToggleService: Symbol.for("IToggleService"),
    ITranslationService: Symbol.for("ITranslationService"),
    IOemVehicleStatusService: Symbol.for("IOemVehicleStatusService"),
    IFilterPanel: Symbol.for("IFilterPanel"),
    IInventoryWasabi: Symbol.for("IInventoryWasabi"),
    IWasabiFilterState: Symbol.for("IWasabiFilterState"),
    IFilterState: Symbol.for("IFilterState"),
    SearchResultsPageWasabi: Symbol.for("SearchResultsPageWasabi"),
    InventoryLineupPageWasabi: Symbol.for("LineupPage"),
    IToggleFetcher: Symbol.for("IToggleFetcher"),
    ITranslationFetcher: Symbol.for("ITranslationFetcher"),
    SrpWasabiGeneral: Symbol.for("SrpWasabiGeneral"),
    VehicleCardWasabi: Symbol.for("VehicleCardWasabi"),
    RangeFilterCosmos: Symbol.for("RangeFilterCosmos"),
    VehicleDetailsPageHoisin: Symbol.for("VehicleDetailsPageHoisin"),
    IVehicleService: Symbol.for("IVehicleService"),
    IFilterService: Symbol.for("IFilterService"),
    IPriceStakSynchronizer: Symbol.for("PriceStakSynchronizer"),
    ShareVehicleModel: Symbol.for("ShareVehicleModel"),
    EvnVideoPlayer: Symbol.for("EvnVideoPlayer"),
    IPersonalizationService: Symbol.for("IPersonalizationService"),
    IStoreProvider: Symbol.for("IStoreProvider"),
    VehiclePricestakDisclaimerModal: Symbol.for("VehiclePricestakDisclaimerModal"),
    TdgConfirmAndContactButtons: Symbol.for("TdgConfirmAndContactButtons"),
    ILocationSortModalService: Symbol.for("ILocationSortModalService"),
    INavbarSearchService: Symbol.for("INavbarSearchService"),
};
const PROVIDERS = {
    ToggleService: Symbol.for("ToggleService"),
    TranslationService: Symbol.for("TranslationService"),
    OemVehicleStatusService: Symbol.for("OemVehicleStatusService"),
    FilterPanel: Symbol.for("FilterPanel"),
    VehicleCardWasabi: Symbol.for("VehicleCardWasabi"),
    RangeFilterCosmos: Symbol.for("RangeFilterCosmos"),
    VehicleService: Symbol.for("VehicleService"),
    PriceStakSynchronizer: Symbol.for("PriceStakSynchronizer"),
    ShareVehicleModel: Symbol.for("ShareVehicleModel"),
    PersonalizationService: Symbol.for("PersonalizationService"),
    StoreProvider: Symbol.for("StoreProvider"),
    VehiclePricestakDisclaimerModal: Symbol.for("VehiclePricestakDisclaimerModal"),
    TdgConfirmAndContactButtons: Symbol.for("TdgConfirmAndContactButtons"),
    LocationSortModalService: Symbol.for("ILocationSortModalService"),
    NavbarSearchService: Symbol.for("NavbarSearchService"),
};



/***/ }),

/***/ 46055:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  P: () => (/* binding */ useFilterStore)
});

// EXTERNAL MODULE: ./node_modules/pinia/dist/pinia.mjs
var pinia = __webpack_require__(10810);
// EXTERNAL MODULE: ./src/inversify.config.ts + 22 modules
var inversify_config = __webpack_require__(16588);
// EXTERNAL MODULE: ./src/types/types.ts
var types = __webpack_require__(45644);
// EXTERNAL MODULE: ./node_modules/vue/dist/vue.runtime.esm-browser.prod.js
var vue_runtime_esm_browser_prod = __webpack_require__(23568);
// EXTERNAL MODULE: ./src/components/spaCosmos/searchFilters/filterPanel/refinementType.ts
var refinementType = __webpack_require__(93677);
// EXTERNAL MODULE: ./src/infrastructure/vue/cosmosSrp/globalStore.ts + 11 modules
var cosmosSrp_globalStore = __webpack_require__(53551);
// EXTERNAL MODULE: ./src/infrastructure/vue/cosmosSrp/customEvents.ts
var customEvents = __webpack_require__(29600);
// EXTERNAL MODULE: ./node_modules/lodash.debounce/index.js
var lodash_debounce = __webpack_require__(50730);
var lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);
// EXTERNAL MODULE: ./src/utilities/urlHelpers.ts
var urlHelpers = __webpack_require__(7324);
;// ./src/utilities/filterHelpers.ts
class FilterHelpers {
}
//NOTE: Because our filters are a combination of queryString and ES values, we can 
//      have a mix of encoded and decoded values. These helpers will do comparisons
//      on the decoded values to help account for these issues.
//      Example: The Location filter can have the following values:
//          Somewhere, MI
//          Nowhere, MD
//      When we put these together as a multi-select filter, we get the following queryString
//          ?location=Somewhere%2C%20MI,Nowhere%2C%20MD
//      Note that in this instance, we have to keep the commas in the values encoded, but we
//      split on the comma between each value. 
//
//      Because of complicated scenarios like this, we have hand coded methods to handle the
//      querystring filters instead of being able to rely on the built in methods like URLSearchParams.
FilterHelpers.arrayIncludes = (array, value) => {
    if (!array) {
        return false;
    }
    const decodedArray = array.map(item => decodeURIComponent(item)) || [];
    const decodedValue = decodeURIComponent(value);
    const containsDecodedValue = decodedArray.includes(decodedValue);
    return containsDecodedValue;
};
FilterHelpers.arrayIndexOf = (array, value) => {
    if (!array) {
        return -1;
    }
    const decodedArray = array.map(item => decodeURIComponent(item)) || [];
    const decodedValue = decodeURIComponent(value);
    const indexOfDecodedValue = decodedArray.indexOf(decodedValue);
    return indexOfDecodedValue;
};
// NOTE: the startwiths is used explicitly for handling ModelAndTrim filters.
FilterHelpers.arraySomeModelAndTrim = (array, value) => {
    if (!array) {
        return false;
    }
    const decodedArray = array.map(item => decodeURIComponent(item)) || [];
    const decodedValue = decodeURIComponent(value);
    const indexOfDecodedValue = decodedArray.some((item) => item.startsWith(`${decodedValue}: `));
    return indexOfDecodedValue;
};

;// ./src/infrastructure/vue/cosmosSrp/filterStore.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};










const useFilterStore = (0,pinia/* defineStore */.nY)('filter', () => {
    const globalStore = (0,cosmosSrp_globalStore/* useGlobalStore */.o)();
    const filterService = inversify_config.doIocContainer.get(types/* TYPES */.Q.IFilterService);
    const loadingFilters = (0,vue_runtime_esm_browser_prod/* ref */.KR)(true);
    //this stores the most recent filter (aka refinementtype) that the user interacted with
    const currentFilter = (0,vue_runtime_esm_browser_prod/* ref */.KR)(null);
    const isWaitingToFilterVehicles = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    const currentSelectFiltersLabel = (0,vue_runtime_esm_browser_prod/* ref */.KR)("");
    /* IMPORTANT NOTES ABOUT FILTER STATE */
    //This holds the entirey of the selected filters and other non refinement url parameters
    //because we fetch stuff and we need to know the state of toggles and such we want to keep track of everything
    //so if you need to know something that involves ONLY vehicle refinement filters, you'll need to run it
    //through a isRefinement() check.
    // DO NOT MUTATE this directly. Use the queuedFilters to push things in and out of here.
    const selectedFilters = (0,vue_runtime_esm_browser_prod/* reactive */.Kh)({});
    //We work with a queue so we can support both dynamic filtering and non-dynamic filtering
    //Always put stuff in the queue, then process the queue to move it to the actual selected filters.
    const queuedFilters = (0,vue_runtime_esm_browser_prod/* reactive */.Kh)({});
    //GETTERS
    const isMobileOrTablet = (0,vue_runtime_esm_browser_prod/* ref */.KR)(window.innerWidth < 992);
    const getSelectedFilters = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => selectedFilters);
    const getQueuedFilters = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => queuedFilters);
    const isDynamicFilteringEnabled = () => filterService.isDynamicFilteringEnabled(globalStore.getSrpModel.SrpPageSettingsModel.SrpFilterType, globalStore.getSrpModel.UiLocation);
    const isDynamicFilteringAndNotMobile = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => isDynamicFilteringEnabled() && !isMobileOrTablet.value);
    const getCurrentFilter = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => currentFilter.value);
    const isLoadingFilters = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => loadingFilters.value);
    const hideZeroCountFiltersToggle = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => filterService.hideZeroCountFilters());
    const hideZeroCountFilters = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => hideZeroCountFiltersToggle.value || globalStore.getSrpModel.FilterPanelModel.HideZeroMatchFilters);
    const getShowPrimaryMakeFirst = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => globalStore.getSrpModel.FilterPanelModel.ShowPrimaryMakeRefinementFirst);
    const getCurrentSelectFiltersLabel = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => currentSelectFiltersLabel.value);
    //our filter state tracks ALL querystring params
    //so we need to know if any vehicle refinements are selected
    const hasAppliedFilters = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => {
        for (let key in selectedFilters) {
            if (isRefinementType(key)) {
                return true;
            }
        }
        return false;
    });
    //get the count of all of the vehicle refinement filters
    const getTotalRefinementFilterCount = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => {
        let count = 0;
        for (const key in selectedFilters) {
            if (selectedFilters.hasOwnProperty(key) && isRefinementType(key)) {
                count += selectedFilters[key].length;
            }
        }
        return count;
    });
    const getTotalQueuedRefinementFilterCount = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => {
        let count = 0;
        for (const key in queuedFilters) {
            if (queuedFilters.hasOwnProperty(key) && isRefinementType(key)) {
                count += queuedFilters[key].length;
            }
        }
        return count;
    });
    const getWaitingToFilterVehicles = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => {
        if (isDynamicFilteringAndNotMobile.value) {
            return false;
        }
        return isWaitingToFilterVehicles.value;
    });
    //METHODS
    function setup() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = window === null || window === void 0 ? void 0 : window.DealeronCookie) === null || _a === void 0 ? void 0 : _a.getItem("DLRON_LOCATION_MODAL_USED")) {
                checkForLocationSort();
            }
            parseQueryString(true);
        });
    }
    const displayFilterItemCheckbox = (vehicleCount, checkboxFilter = null, shouldShow = true) => {
        var _a;
        if (hideZeroCountFilters.value && vehicleCount === 0) {
            return false;
        }
        return (_a = checkboxFilter === null || checkboxFilter === void 0 ? void 0 : checkboxFilter.ShowCheckboxFilter) !== null && _a !== void 0 ? _a : shouldShow;
    };
    //determine if a key is a vehicle refinement filter
    function isRefinementType(key) {
        const inputLowerCase = key.toLowerCase();
        // Use the enum instead of an array
        return Object.values(refinementType/* RefinementType */.S).some(item => item.toLowerCase() === inputLowerCase);
    }
    function getCosmosSrpFilters(updateUrlNow = true, removingSearchQuery = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                loadingFilters.value = true;
                document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.FilterLoadStart));
                // See DO-36952. On mobile, we need to check if the search valet has been updated and bypass the check for dynamic filtering
                const hasSearchValetUpdate = getQueuedFilters.value.hasOwnProperty("q") || getQueryStringKeyValuePairs().some(f => f.key === "q");
                // If we are using dynamic filtering and not on mobile and not removing a filter pill, we want to call getFilteredVehicle
                const shouldCallGetFilteredVehicles = isDynamicFilteringAndNotMobile.value || (hasSearchValetUpdate && !removingSearchQuery);
                //scroll vehicles to the top of the vehicles list as soon as possible.
                if (shouldCallGetFilteredVehicles) {
                    globalStore.vehicleStore.srpScrollTop();
                    yield (0,vue_runtime_esm_browser_prod/* nextTick */.dY)();
                }
                //process any queued filters
                processFilterQueue(updateUrlNow);
                //then parse the querystring to get the current state of the filters
                parseQueryString();
                //go fetch everything about filters from the server
                const response = yield getFiltersFromFilterService();
                setFilterModel(response);
                loadingFilters.value = false;
                document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.FilterLoadEnd, { detail: getSelectedFilters.value }));
                if (shouldCallGetFilteredVehicles) {
                    globalStore.vehicleStore.getFilteredVehicles();
                }
            }
            catch (error) {
                loadingFilters.value = false;
                console.error(`Error fetching data: ${error}`);
            }
        });
    }
    function getFiltersFromFilterService() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield filterService.getFilters(globalStore.getSrpModel.DealerModel.DealerId, globalStore.getSrpModel.PageId, globalStore.getDynamicCountsSearch);
            return response;
        });
    }
    function setFilterModel(data) {
        Object.assign(globalStore.getSrpModel.FilterPanelModel, data);
    }
    //manually extract the querystring params because we allow dealers to use unsafe characters
    function getQueryStringKeyValuePairs() {
        const queryString = window.location.href.split('?');
        if (!queryString || queryString.length < 2) {
            return [];
        }
        // Split the query string into key-value pairs
        const pairs = queryString[1].split('&');
        // Map each pair into an object
        const params = pairs.map((pair) => {
            // Split the key and value (with potential trailing =)
            const [key, ...valueParts] = pair.split('=');
            // Join the value parts (keeping trailing =)
            const value = valueParts.join('=');
            //we can't use decodeURIComponent because we allow dealers to use unsafe characters
            return {
                key: key,
                value: value
            };
        });
        return params;
    }
    function parseQueryString(init = false) {
        //HACK: because we allow dealers to use unsafe querystring characters we can't use
        // the URLSearchParams object because it will overwrite our manual encoding rules
        const params = getQueryStringKeyValuePairs();
        const updateParms = new Object();
        for (const parm in params) {
            const [key, value] = [params[parm].key, params[parm].value];
            let values = [];
            switch (key.toLowerCase()) {
                case 'modelandtrim':
                case 'rvbrand':
                    // Split by exclamation mark (!) to separate different Model:Trim sets
                    const modelTrimSets = value.split('!');
                    for (const modelTrimSet of modelTrimSets) {
                        // Split by colon (:) to separate Model and Trims
                        const [model, trims] = modelTrimSet.split(':');
                        // Split Trims by comma (,) to get individual Trims
                        if (trims && trims.length > 0) {
                            const trimArray = trims.split(',');
                            for (const trim of trimArray) {
                                values.push(`${model}: ${trim}`); // Create an object for each Model:Trim
                            }
                        }
                        else {
                            values.push(`${model}`);
                        }
                    }
                    break;
                default:
                    if (value) {
                        values = value.split(','); // Split values by comma (default delimiter)
                    }
                    else {
                        //handle queryString params that don't have a value
                        values = [null];
                    }
                    break;
            }
            updateParms[key] = values;
        }
        //on setup we want to update the queued filters to be updated. After this we
        //we only want to update the selected filters when we process the queue
        if (init) {
            syncObjects(queuedFilters, updateParms);
        }
        syncObjects(selectedFilters, updateParms);
    }
    //do all our filter work on the queues so we can delay applying filters
    //in the case that dynamic filtering is disabled.
    function removeFilter(filterKey, filterValue, isAllTrimsClick, isClearFilterPillClick) {
        //We don't care about the value of For You, just that we have the key
        if (filterKey === refinementType/* RefinementType */.S.SignalsForYou) {
            delete queuedFilters[filterKey];
            return true;
        }
        filterValue = EncodeFilterValue(filterKey, filterValue);
        if (filterValue === undefined && queuedFilters.hasOwnProperty(filterKey)) {
            delete queuedFilters[filterKey];
            return true;
        }
        else if (queuedFilters.hasOwnProperty(filterKey) && Array.isArray(queuedFilters[filterKey])) {
            const index = FilterHelpers.arrayIndexOf(queuedFilters[filterKey], filterValue);
            if (index !== -1) {
                //remove the item
                queuedFilters[filterKey].splice(index, 1);
                //If the filter has no values then delete it from queued filters
                if (queuedFilters[filterKey].length === 0) {
                    delete queuedFilters[filterKey];
                }
                //If we are removing a search valet pill/query we need to clear the search input as well.
                if (isClearFilterPillClick && filterKey === 'q') {
                    document.dispatchEvent(new Event(customEvents/* CosmosSrpCustomEvents */.A.SearchValetCleared));
                }
                if (isDynamicFilteringAndNotMobile.value || isClearFilterPillClick) {
                    processFilterQueue();
                }
            }
            //ModelAndTrim entries are in the format of "ModelName: TrimName". We know if we're removing a trim
            // by checking `startsWith("Model :"). Model/Trim are special in that we either have just
            // the model name, or we have only a list of "ModelName: TrimName" items. Not both.
            if ((filterKey === refinementType/* RefinementType */.S.ModelAndTrim || filterKey === refinementType/* RefinementType */.S.RvBrand) && !isClearFilterPillClick) {
                //handle trim removal - if we remove the final trim for a model add the model back in
                if (filterValue.indexOf(": ") > -1) {
                    const model = filterValue.split(": ")[0];
                    if (!FilterHelpers.arraySomeModelAndTrim(queuedFilters[filterKey], model)) {
                        addFilter(filterKey, model);
                    }
                }
                else {
                    //handle model removal - we need to remove all trims for this model because we're removing the model
                    if (queuedFilters[filterKey]) {
                        queuedFilters[filterKey] = queuedFilters[filterKey].filter(function (item) {
                            //when working with filters we always need to compare decoded values
                            return !decodeURIComponent(item).startsWith(`${decodeURIComponent(filterValue)}: `);
                        });
                    }
                    //The all trims button is never "uncheckable", per se, it clears all the trims
                    //and set us back to just the model. Because of this it will remove the model
                    //from the filter state so we need to add it back
                    if (isAllTrimsClick) {
                        queuedFilters[filterKey].push(filterValue);
                    }
                }
            }
            if (queuedFilters[filterKey] && queuedFilters[filterKey].length === 0) {
                delete queuedFilters[filterKey];
            }
            if (queuedFilters[filterKey] && queuedFilters[filterKey].length === 0) {
                delete queuedFilters[filterKey];
            }
            return true;
        }
        return false;
    }
    //Common place to encode filter values before adding the qs value to the filter object.
    //***IF YOU ADD AN ENTRY TO THE ENCODE PLEASE MAKE SURE TO MAKE A DECODE ENTRY BELOW */
    function EncodeFilterValue(filterKey, filterValue) {
        //Check to make sure the filterValue is a string before encoding.
        //If it is not a string it is most likly a filter object, so we don't want to encode it.
        if (typeof filterValue === 'string') {
            let newFilterValue = filterValue;
            // Replace registered html
            newFilterValue = newFilterValue.replace(/<sup>&reg;<\/sup>/g, "*REGISTERED");
            // Replace trademark html
            newFilterValue = newFilterValue.replace(/<sup>&trade;<\/sup>/g, "*TRADEMARK");
            // Replace registered inline 
            newFilterValue = newFilterValue.replace(/\u00AE/g, "*REGINLINE");
            // Replace trademark inline 
            newFilterValue = newFilterValue.replace(/\u2122/g, "*TMINLINE");
            // Replace ampersand with encoded ampersand
            newFilterValue = newFilterValue.replace(/&/g, "%26");
            // Replace comma with encoded comma
            newFilterValue = newFilterValue.replace(/,/g, "%2C");
            // Replace comma with encoded semicolon
            newFilterValue = newFilterValue.replace(/;/g, "%3B");
            return newFilterValue;
        }
        return filterValue;
    }
    function DecodeFilterValue(filterKey, filterValue) {
        //Check to make sure the filterValue is a string before encoding.
        //If it is not a string it is most likly a filter object, so we don't want to encode it.
        if (typeof filterValue === 'string') {
            let newFilterValue = filterValue;
            // Decode encoded registered html
            newFilterValue = newFilterValue.replace(/\*REGISTERED/g, "<sup>&reg;</sup>");
            // Decode encoded trademark html
            newFilterValue = newFilterValue.replace(/\*TRADEMARK/g, "<sup>&trade;</sup>");
            // Decode encoded inline registered
            newFilterValue = newFilterValue.replace(/\*REGINLINE/g, "\u00AE");
            // Decode encoded inline trademark
            newFilterValue = newFilterValue.replace(/\*TMINLINE/g, "\u2122");
            // Decode encoded ampersand
            newFilterValue = newFilterValue.replace(/%26/g, "&");
            // Decode encoded comma
            newFilterValue = newFilterValue.replace(/%2C/g, ",");
            // Decode encoded semicolon
            newFilterValue = newFilterValue.replace(/%3B/g, ";");
            return newFilterValue;
        }
        return filterValue;
    }
    function addFilter(filterKey, filterValue) {
        filterValue = EncodeFilterValue(filterKey, filterValue);
        if (queuedFilters.hasOwnProperty(filterKey)) {
            if (filterKey.indexOf("range") > -1) {
                delete queuedFilters[filterKey];
            }
            //don't add the value if it already exists
            if (Array.isArray(queuedFilters[filterKey])) {
                const index = FilterHelpers.arrayIndexOf(queuedFilters[filterKey], filterValue);
                if (index > -1) {
                    return false;
                }
            }
        }
        if (filterKey === refinementType/* RefinementType */.S.ModelAndTrim || filterKey === refinementType/* RefinementType */.S.RvBrand) {
            //if we're adding a trim and there were no other trims selected for this model
            // then we need to remove the model entry. Model/Trim are special in that we either have just
            // the model name, or we have only a list of "ModelName: TrimName" items. Not both.
            if (filterValue.indexOf(": ") > -1) {
                const model = filterValue.split(": ")[0];
                if (isFilterSelected(filterKey, model)) {
                    const index = FilterHelpers.arrayIndexOf(queuedFilters[filterKey], model);
                    if (index !== -1) {
                        queuedFilters[filterKey].splice(index, 1);
                    }
                }
            }
        }
        if (queuedFilters[filterKey]) {
            queuedFilters[filterKey].push(filterValue);
        }
        else {
            queuedFilters[filterKey] = [filterValue];
        }
        return true;
    }
    //assign the queued filters to the actual filters. This applies the
    //filters to the UI officially
    function processFilterQueue(updateUrlNow = true) {
        syncObjects(selectedFilters, queuedFilters);
        updateQueryString(updateUrlNow);
    }
    //When we update the filter state we update the queued filters.
    //If we are using dynamic filtering, we apply the filters immediately.
    //  We go get all the filters again because this updates the vehicle counts
    //If we are not using dynamic filtering, we wait until the user clicks the apply filters button
    function updateFilterState(refinementName, filterItem, isAllTrimsClick) {
        let isSelected = isFilterSelected(refinementName, filterItem);
        //keep track of the filter refinement the user is currently interacting with
        setCurrentFilter(refinementName);
        if (filterItem === undefined // handle special case for handling range filters
            || ((refinementName == refinementType/* RefinementType */.S.ModelAndTrim || refinementName == refinementType/* RefinementType */.S.RvBrand) && isFilterModelSelected(filterItem, refinementName)) // handle modelAndTrim special case
            || isFilterSelected(refinementName, filterItem) // handle all other cases
        ) {
            if (!removeFilter(refinementName, filterItem, isAllTrimsClick)) {
                document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.UpdateFilterState));
                return;
            }
        }
        else {
            if (refinementName === 'st') {
                // we want to remove the sort parameter if we're trying a new sort
                removeFilter(refinementName);
            }
            handleAvailabilityFilters(refinementName);
            if (!addFilter(refinementName, filterItem)) {
                document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.UpdateFilterState));
                return;
            }
        }
        // DO NOT REMOVE refinementName === 'st' until we universally support dynamic filtering. This will break sorting on mobile. See DO-31720
        if (isDynamicFilteringAndNotMobile.value || refinementName === 'st') {
            getFilters();
        }
        else {
            let hasFiltersToApply = false;
            const anyFilters = Object.assign(Object.assign({}, selectedFilters), queuedFilters);
            for (const key in anyFilters) {
                if (anyFilters.hasOwnProperty(key) && isRefinementType(key)) {
                    hasFiltersToApply = true;
                    break;
                }
            }
            setWaitingToFilterVehicles(hasFiltersToApply);
            let removingSearchQuery = refinementName == 'q' && isSelected;
            getFilters(false, removingSearchQuery);
        }
        document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.UpdateFilterState));
    }
    function handleAvailabilityFilters(refinementName) {
        const refinementKeys = [refinementType/* RefinementType */.S.InTransit, refinementType/* RefinementType */.S.InProduction, refinementType/* RefinementType */.S.InStock];
        if (refinementKeys.includes(refinementName)) {
            const toggleOffRefinments = refinementKeys.filter(refinement => refinement !== refinementName);
            toggleOffRefinments.forEach(refinement => {
                removeFilter(refinement);
            });
        }
    }
    function updateSearchValetFilter(searchKey, searchValue, distanceKey, distanceValue) {
        //remove the existing search valet filters
        delete queuedFilters[searchKey];
        delete queuedFilters[distanceKey];
        //add the new search valet filters
        if (searchValue) {
            addFilter(searchKey, searchValue);
        }
        if (distanceValue) {
            addFilter(distanceKey, distanceValue);
        }
        getFilters();
    }
    function removeAllFilters() {
        for (const key in queuedFilters) {
            if (queuedFilters.hasOwnProperty(key) && isRefinementType(key)) {
                delete queuedFilters[key];
            }
        }
        syncObjects(selectedFilters, queuedFilters);
        getFilters();
        if (!isDynamicFilteringEnabled()) {
            globalStore.vehicleStore.getFilteredVehicles();
        }
    }
    // Update the query string to reflect updated filters
    function updateQueryString(updateUrlNow = true) {
        //HACK: because we let dealers use unfriendly querystring characters we need to do some
        //manual encoding and decoding so we cannot use the URLSearchParams object as it
        //will overwrite our encoding
        const params = [];
        for (const key in selectedFilters) {
            if (selectedFilters.hasOwnProperty(key)) {
                switch (key) {
                    case refinementType/* RefinementType */.S.ModelAndTrim:
                    case refinementType/* RefinementType */.S.RvBrand:
                        // Handle the "ModelAndTrim" key separately
                        const modelTrimSets = selectedFilters[key];
                        const modelTrimMap = {};
                        for (const item of modelTrimSets) {
                            const [model, trim] = item.replace(/\+/g, '%2B').split(': ');
                            if (!modelTrimMap[model]) {
                                modelTrimMap[model] = [trim];
                            }
                            else {
                                modelTrimMap[model].push(trim);
                            }
                        }
                        // Format the models and trims
                        const formattedArray = Object.keys(modelTrimMap).map((model) => {
                            const trims = modelTrimMap[model].join(',');
                            if (trims.length > 0) {
                                return `${model}:${trims}`;
                            }
                            else {
                                return `${model}`;
                            }
                        });
                        params.push({ "key": key, "value": `${formattedArray.join('!')}` });
                        break;
                    case refinementType/* RefinementType */.S.Location:
                        //locations have commas in the data, so we want to manually encode them so
                        //that when we split on "," for multi-select we don't split on the location state
                        const encodedLocations = [];
                        selectedFilters[key].forEach((item) => {
                            //our search can't handle the + symbol, which is what an encoded space would look like
                            //so instead, we manually encode to %20
                            encodedLocations.push(item.replace(", ", "%2C%20"));
                        });
                        params.push({ "key": key, "value": encodedLocations.join(',') });
                        break;
                    //This is base 64 encoded and has a trailing = we need to make sure it comes through
                    case refinementType/* RefinementType */.S.SignalsForYou:
                        params.push({ "key": key, "value": selectedFilters[key] });
                        break;
                    default:
                        const encodedDefaults = [];
                        selectedFilters[key].forEach((item) => {
                            encodedDefaults.push(EncodeFilterValue(key, item));
                        });
                        params.push({ "key": key, "value": encodedDefaults.join(',') });
                        break;
                }
            }
        }
        const url = new URL(location.href);
        //HACK: because we let dealers use unfriendly querystring characters we can't encode here
        var search = urlHelpers/* UrlHelpers */.b.mapArrayToQueryString(params);
        globalStore.setDynamicCountsSearch(search);
        if (updateUrlNow) {
            url.search = search;
        }
        //update the url without redirecting
        const formattedUrl = url.toString();
        globalStore.updateUrlState(formattedUrl);
    }
    function isFilterSelected(key, value) {
        //support filters that can have multiple values (i.e. the value in the key exists)
        //and filters that can only have one value (i.e. the key exists)
        var _a, _b;
        //HACK: we let dealers use unfriendly querystring characters so when we compare selected
        // we can't use the URLSearchParams objects. However, we want to display friendly names
        // for checkboxes and filter pills. So, we need to compare encoded and decoded values.
        value = EncodeFilterValue(key, value);
        if (getWaitingToFilterVehicles.value) {
            if (queuedFilters.hasOwnProperty(key)) {
                if (key === refinementType/* RefinementType */.S.SignalsForYou) {
                    return true;
                }
                if (value !== undefined) {
                    return (_a = FilterHelpers.arrayIncludes(queuedFilters[key], value)) !== null && _a !== void 0 ? _a : false;
                }
                else {
                    return true;
                }
            }
        }
        else {
            if (selectedFilters.hasOwnProperty(key)) {
                if (key === refinementType/* RefinementType */.S.SignalsForYou) {
                    return true;
                }
                if (value !== undefined) {
                    return (_b = FilterHelpers.arrayIncludes(selectedFilters[key], value)) !== null && _b !== void 0 ? _b : false;
                }
                else {
                    return true;
                }
            }
        }
        return false;
    }
    const getFilters = lodash_debounce_default()((updateUrlNow = true, removingSearchQuery = false) => {
        getCosmosSrpFilters(updateUrlNow, removingSearchQuery);
    }, 300);
    // Immediate version for initial page load - bypasses debounce
    const getFiltersImmediate = (updateUrlNow = true, removingSearchQuery = false) => {
        getCosmosSrpFilters(updateUrlNow, removingSearchQuery);
    };
    //ModelAndTrim helpers
    function isFilterModelSelected(modelName, refinementType) {
        var _a, _b;
        if (getWaitingToFilterVehicles.value) {
            return (_a = (FilterHelpers.arrayIncludes(queuedFilters[refinementType], modelName)
                || FilterHelpers.arraySomeModelAndTrim(queuedFilters[refinementType], modelName))) !== null && _a !== void 0 ? _a : false;
        }
        return (_b = (FilterHelpers.arrayIncludes(selectedFilters[refinementType], modelName)
            || FilterHelpers.arraySomeModelAndTrim(selectedFilters[refinementType], modelName))) !== null && _b !== void 0 ? _b : false;
    }
    function doesModelHaveSelectedTrims(modelName, refinementType) {
        var _a, _b;
        if (getWaitingToFilterVehicles.value) {
            return (_a = FilterHelpers.arraySomeModelAndTrim(queuedFilters[refinementType], modelName)) !== null && _a !== void 0 ? _a : false;
        }
        return (_b = FilterHelpers.arraySomeModelAndTrim(selectedFilters[refinementType], modelName)) !== null && _b !== void 0 ? _b : false;
    }
    //get the count for a specific vehicle refinement filter
    function getRefinementFilterCount(key) {
        var _a, _b, _c, _d;
        //The mileage filter is a special case where we need to use the Mileagerange key
        if (key === refinementType/* RefinementType */.S.Mileage) {
            key = refinementType/* RefinementType */.S.Mileagerange.toString();
        }
        if (getWaitingToFilterVehicles.value) {
            return (_b = (_a = queuedFilters[findKeyIgnoreCase(queuedFilters, key)]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        }
        return (_d = (_c = selectedFilters[findKeyIgnoreCase(selectedFilters, key)]) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
    }
    function setWaitingToFilterVehicles(value) {
        isWaitingToFilterVehicles.value = value;
    }
    ;
    function isFilterEnabled(filterName) {
        var _a, _b, _c;
        return (_c = (_b = (_a = globalStore.getSrpModel.FilterPanelModel) === null || _a === void 0 ? void 0 : _a.FilterList) === null || _b === void 0 ? void 0 : _b.Refinements.some(refinement => refinement.RefinementType == filterName)) !== null && _c !== void 0 ? _c : false;
    }
    function undoFilters(undoFilterState) {
        //revert the filter state to the state before the last filter was applied
        syncObjects(queuedFilters, undoFilterState);
        // Update selected filters so that Apply Filters CTA label updates
        processFilterQueue();
        //now get the filters using what we reverted to
        getFilters();
    }
    //sync target and source objects
    function syncObjects(target, source) {
        // Remove properties from target that no longer exist in source
        for (const key in target) {
            if (!(key in source)) {
                delete target[key];
            }
        }
        Object.assign(target, source);
    }
    ;
    function findKeyIgnoreCase(obj, searchKey) {
        // Convert the searchKey to lowercase for case-insensitive comparison
        const lowercaseSearchKey = searchKey.toLowerCase();
        // Iterate through the object's keys
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                // Convert the current key to lowercase for comparison
                const lowercaseKey = key.toLowerCase();
                // If the lowercase keys match, return the original key
                if (lowercaseKey === lowercaseSearchKey) {
                    return key;
                }
            }
        }
        // If no match is found, return undefined
        return undefined;
    }
    function setCurrentFilter(filterId) {
        currentFilter.value = filterId;
    }
    function setCurrentSelectFiltersLabel(label) {
        currentSelectFiltersLabel.value = label;
    }
    //If we have location data from the user we sort by that location type
    function checkForLocationSort() {
        if ((window.location.search.indexOf("st=") < 0)) {
            let sortQuery = "";
            switch (window.DealeronCookie.getItem("DLRON_LOCATION_MODAL_USED")) {
                case "zip":
                    const zip = window.DealeronCookie.getItem("DLRON_ZIP");
                    sortQuery = `st=Distance+asc&ZipCode=${zip}`;
                    break;
                case "coordinate":
                    if (globalThis.location.search.includes("currentlocation=")) {
                        return;
                    }
                    const coordinate = decodeURIComponent(window.DealeronCookie.getItem("DLRON_coordinate"));
                    const latLong = coordinate.split("|");
                    const trimmedLatLong = parseFloat(latLong[0]).toFixed(3) + "|" + parseFloat(latLong[1]).toFixed(3);
                    sortQuery = `currentlocation=${trimmedLatLong}`;
                    break;
                case "closed":
                    return;
                default:
                    return;
            }
            const url = new URL(window.location.href);
            if (url.search && url.search !== "?") {
                url.search += `&${sortQuery}`;
            }
            else {
                url.search = `?${sortQuery}`;
            }
            window.history.replaceState({}, "", url.toString());
        }
    }
    new ResizeObserver(() => {
        // if resizing from mobile view -> desktop view && dynamicFilteringEnabled,
        // remove all queuedFilters
        if (isDynamicFilteringEnabled() && isMobileOrTablet.value && window.innerWidth >= 992) {
            syncObjects(queuedFilters, selectedFilters);
            setWaitingToFilterVehicles(false);
        }
        if (!isDynamicFilteringEnabled() && isMobileOrTablet.value && window.innerWidth >= 992) {
            syncObjects(queuedFilters, selectedFilters);
        }
        isMobileOrTablet.value = window.innerWidth < 992;
    }).observe(document.documentElement);
    return {
        getCosmosSrpFilters,
        isLoadingFilters,
        getCurrentFilter,
        getFilters,
        getFiltersImmediate,
        getSelectedFilters,
        getQueuedFilters,
        removeFilter,
        isRefinementType,
        isFilterSelected,
        getRefinementFilterCount,
        getTotalRefinementFilterCount,
        getTotalQueuedRefinementFilterCount,
        updateFilterState,
        isDynamicFiltering: isDynamicFilteringAndNotMobile,
        getWaitingToFilterVehicles,
        isFilterEnabled,
        isFilterModelSelected,
        doesModelHaveSelectedTrims,
        removeAllFilters,
        undoFilters,
        hasAppliedFilters,
        updateSearchValetFilter,
        hideZeroCountFilters,
        displayFilterItemCheckbox,
        syncObjects,
        setCurrentFilter,
        setup,
        getShowPrimaryMakeFirst,
        setWaitingToFilterVehicles,
        getCurrentSelectFiltersLabel,
        setCurrentSelectFiltersLabel,
        DecodeFilterValue,
        EncodeFilterValue,
        getFiltersFromFilterService
    };
});


/***/ }),

/***/ 47067:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ TdgConfirmAndContactButtons)
/* harmony export */ });
/* unused harmony export TdgButtonType */
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90260);
/* harmony import */ var _core_enums_uiLocationVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23277);
/* harmony import */ var _infrastructure_vue_cosmosSrp_customEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29600);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



var TdgButtonType;
(function (TdgButtonType) {
    TdgButtonType[TdgButtonType["ConfirmAvailability"] = 0] = "ConfirmAvailability";
    TdgButtonType[TdgButtonType["ContactDealer"] = 1] = "ContactDealer";
})(TdgButtonType || (TdgButtonType = {}));
let TdgConfirmAndContactButtons = class TdgConfirmAndContactButtons {
    constructor() {
        this._confirmReplacementCode = "#DG_CONFIRM_AVAILABILITY#";
        this._contactDealerReplacementCode = "#DG_CONTACT_DEALER#";
    }
    initialize(uiLocationVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            this._uiLocationVersion = uiLocationVersion;
            yield this.addLoadListener();
        });
    }
    addLoadListener() {
        return __awaiter(this, void 0, void 0, function* () {
            switch (this._uiLocationVersion) {
                case _core_enums_uiLocationVersion__WEBPACK_IMPORTED_MODULE_1__/* .UiLocationVersion */ .I.SrpWasabi:
                    document.addEventListener(_infrastructure_vue_cosmosSrp_customEvents__WEBPACK_IMPORTED_MODULE_2__/* .CosmosSrpCustomEvents */ .A.VehicleLoadEnd, () => __awaiter(this, void 0, void 0, function* () { return yield this.initializeButtons(); }));
                    document.addEventListener(_infrastructure_vue_cosmosSrp_customEvents__WEBPACK_IMPORTED_MODULE_2__/* .CosmosSrpCustomEvents */ .A.PricingVisibilityAdjusted, () => __awaiter(this, void 0, void 0, function* () { return yield this.initializeButtons(); }));
                    break;
                case _core_enums_uiLocationVersion__WEBPACK_IMPORTED_MODULE_1__/* .UiLocationVersion */ .I.VdpHoisin:
                    if (document.readyState === 'loading') {
                        document.addEventListener("DOMContentLoaded", () => __awaiter(this, void 0, void 0, function* () { return yield this.initializeButtons(); }));
                        return;
                    }
                    yield this.initializeButtons();
                    break;
                default:
                    break;
            }
        });
    }
    initializeButtons() {
        return __awaiter(this, void 0, void 0, function* () {
            this._confirmAvailabilityElements = this.getButtons(this._confirmReplacementCode);
            this._contactDealerElements = this.getButtons(this._contactDealerReplacementCode);
            this._confirmAvailabilityElements.forEach((element) => {
                element.setAttribute("disabled", "");
            });
            this._contactDealerElements.forEach((element) => {
                element.setAttribute("disabled", "");
            });
            if (yield this.checkIsTdgLoadedAsync()) {
                this.onTdgLoaded();
            }
        });
    }
    getButtons(selector) {
        const elements = document.querySelectorAll(`[data-elementtype="LinkButton"][href="${selector}"]`);
        return Array.from(elements);
    }
    checkIsTdgLoadedAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            if (window.DGDataHub) {
                return true;
            }
            for (let i = 0; i < 10; i++) {
                const loaded = yield new Promise(resolve => {
                    setTimeout(() => {
                        resolve(!!window.DGDataHub);
                    }, 100);
                });
                if (loaded) {
                    return true;
                }
            }
            console.error("TDG library failed to load in time.");
            return false;
        });
    }
    addButtonListener(element, buttonType) {
        element.removeAttribute("disabled");
        element.setAttribute("href", "javascript:void(0);");
        element.addEventListener("click", (event) => {
            if (event.target === element) {
                this.onCtaClick(element, buttonType);
            }
        });
    }
    onTdgLoaded() {
        this._confirmAvailabilityElements.forEach((element) => {
            this.addButtonListener(element, TdgButtonType.ConfirmAvailability);
        });
        this._contactDealerElements.forEach((element) => {
            this.addButtonListener(element, TdgButtonType.ContactDealer);
        });
    }
    onCtaClick(element, buttonType) {
        var _a, _b, _c;
        const vehicleInfo = element.closest("[data-vehicle-information]");
        const vin = (_a = vehicleInfo === null || vehicleInfo === void 0 ? void 0 : vehicleInfo.getAttribute("data-vin")) !== null && _a !== void 0 ? _a : "";
        const isNew = (vehicleInfo === null || vehicleInfo === void 0 ? void 0 : vehicleInfo.getAttribute("data-vehicletype")) === "new";
        const isCpo = (vehicleInfo === null || vehicleInfo === void 0 ? void 0 : vehicleInfo.getAttribute("data-cpo")) === "true";
        let vehicleType;
        if (isNew) {
            vehicleType = "new";
        }
        else {
            vehicleType = isCpo ? "cpo" : "used";
        }
        switch (buttonType) {
            case TdgButtonType.ConfirmAvailability:
                (_b = window.DGDataHub) === null || _b === void 0 ? void 0 : _b.showConfirmAvailability(vin, vehicleType);
                break;
            case TdgButtonType.ContactDealer:
                (_c = window.DGDataHub) === null || _c === void 0 ? void 0 : _c.showContactDealer(vin, vehicleType);
                break;
            default:
                break;
        }
    }
};
TdgConfirmAndContactButtons = __decorate([
    (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .injectable */ ._G)()
], TdgConfirmAndContactButtons);



/***/ }),

/***/ 47442:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.inject = exports.LazyServiceIdentifer = void 0;
var error_msgs_1 = __webpack_require__(27718);
var METADATA_KEY = __webpack_require__(94725);
var metadata_1 = __webpack_require__(88390);
var decorator_utils_1 = __webpack_require__(50040);
var LazyServiceIdentifer = function () {
  function LazyServiceIdentifer(cb) {
    this._cb = cb;
  }
  LazyServiceIdentifer.prototype.unwrap = function () {
    return this._cb();
  };
  return LazyServiceIdentifer;
}();
exports.LazyServiceIdentifer = LazyServiceIdentifer;
function inject(serviceIdentifier) {
  return function (target, targetKey, index) {
    if (serviceIdentifier === undefined) {
      throw new Error(error_msgs_1.UNDEFINED_INJECT_ANNOTATION(target.name));
    }
    var metadata = new metadata_1.Metadata(METADATA_KEY.INJECT_TAG, serviceIdentifier);
    if (typeof index === "number") {
      decorator_utils_1.tagParameter(target, targetKey, index, metadata);
    } else {
      decorator_utils_1.tagProperty(target, targetKey, metadata);
    }
  };
}
exports.inject = inject;

/***/ }),

/***/ 48677:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Binding = void 0;
var literal_types_1 = __webpack_require__(27802);
var id_1 = __webpack_require__(78418);
var Binding = function () {
  function Binding(serviceIdentifier, scope) {
    this.id = id_1.id();
    this.activated = false;
    this.serviceIdentifier = serviceIdentifier;
    this.scope = scope;
    this.type = literal_types_1.BindingTypeEnum.Invalid;
    this.constraint = function (request) {
      return true;
    };
    this.implementationType = null;
    this.cache = null;
    this.factory = null;
    this.provider = null;
    this.onActivation = null;
    this.dynamicValue = null;
  }
  Binding.prototype.clone = function () {
    var clone = new Binding(this.serviceIdentifier, this.scope);
    clone.activated = false;
    clone.implementationType = this.implementationType;
    clone.dynamicValue = this.dynamicValue;
    clone.scope = this.scope;
    clone.type = this.type;
    clone.factory = this.factory;
    clone.provider = this.provider;
    clone.constraint = this.constraint;
    clone.onActivation = this.onActivation;
    clone.cache = this.cache;
    return clone;
  };
  return Binding;
}();
exports.Binding = Binding;

/***/ }),

/***/ 50040:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.tagProperty = exports.tagParameter = exports.decorate = void 0;
var ERROR_MSGS = __webpack_require__(27718);
var METADATA_KEY = __webpack_require__(94725);
function tagParameter(annotationTarget, propertyName, parameterIndex, metadata) {
  var metadataKey = METADATA_KEY.TAGGED;
  _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex);
}
exports.tagParameter = tagParameter;
function tagProperty(annotationTarget, propertyName, metadata) {
  var metadataKey = METADATA_KEY.TAGGED_PROP;
  _tagParameterOrProperty(metadataKey, annotationTarget.constructor, propertyName, metadata);
}
exports.tagProperty = tagProperty;
function _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex) {
  var paramsOrPropertiesMetadata = {};
  var isParameterDecorator = typeof parameterIndex === "number";
  var key = parameterIndex !== undefined && isParameterDecorator ? parameterIndex.toString() : propertyName;
  if (isParameterDecorator && propertyName !== undefined) {
    throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
  }
  if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
    paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
  }
  var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
  if (!Array.isArray(paramOrPropertyMetadata)) {
    paramOrPropertyMetadata = [];
  } else {
    for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
      var m = paramOrPropertyMetadata_1[_i];
      if (m.key === metadata.key) {
        throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + m.key.toString());
      }
    }
  }
  paramOrPropertyMetadata.push(metadata);
  paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
  Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function _decorate(decorators, target) {
  Reflect.decorate(decorators, target);
}
function _param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function decorate(decorator, target, parameterIndex) {
  if (typeof parameterIndex === "number") {
    _decorate([_param(parameterIndex, decorator)], target);
  } else if (typeof parameterIndex === "string") {
    Reflect.decorate([decorator], target, parameterIndex);
  } else {
    _decorate([decorator], target);
  }
}
exports.decorate = decorate;

/***/ }),

/***/ 50730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
  nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function () {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime,
    lastInvokeTime = 0,
    leading = false,
    maxing = false,
    trailing = true;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs,
      thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime,
      result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }
  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }
  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(),
      isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = debounce;

/***/ }),

/***/ 52719:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.postConstruct = void 0;
var ERRORS_MSGS = __webpack_require__(27718);
var METADATA_KEY = __webpack_require__(94725);
var metadata_1 = __webpack_require__(88390);
function postConstruct() {
  return function (target, propertyKey, descriptor) {
    var metadata = new metadata_1.Metadata(METADATA_KEY.POST_CONSTRUCT, propertyKey);
    if (Reflect.hasOwnMetadata(METADATA_KEY.POST_CONSTRUCT, target.constructor)) {
      throw new Error(ERRORS_MSGS.MULTIPLE_POST_CONSTRUCT_METHODS);
    }
    Reflect.defineMetadata(METADATA_KEY.POST_CONSTRUCT, metadata, target.constructor);
  };
}
exports.postConstruct = postConstruct;

/***/ }),

/***/ 53551:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  o: () => (/* binding */ useGlobalStore)
});

// EXTERNAL MODULE: ./node_modules/pinia/dist/pinia.mjs
var pinia = __webpack_require__(10810);
// EXTERNAL MODULE: ./node_modules/vue/dist/vue.runtime.esm-browser.prod.js
var vue_runtime_esm_browser_prod = __webpack_require__(23568);
// EXTERNAL MODULE: ./src/core/enums/srpLayoutType.ts
var srpLayoutType = __webpack_require__(82491);
;// ./src/components/spaCosmos/head/searchResultsList/searchResultsListModel.ts
class SearchResultsListModel {
    constructor() {
        this.IsRefineSearchHidden = false;
    }
}

;// ./src/components/spaCosmos/head/searchValet/searchValetModel.ts
class SearchValetModel {
}

;// ./src/components/spaCosmos/pagination/searchPaginationModel.ts
class SearchPaginationModel {
}

;// ./src/components/spaCosmos/searchFilters/filterPanel/filterListModel.ts
class FilterListModel {
    constructor() {
        this.Refinements = new Array();
    }
}

;// ./src/components/spaCosmos/searchFilters/filterPanel/filterStateModel.ts

class FilterStateModel {
    constructor() {
        this.FilterList = new FilterListModel();
    }
}

;// ./src/components/spaCosmos/searchFilters/filterPanel/filterPanelModel.ts


class FilterPanelModel {
    constructor() {
        this.FilterList = new FilterListModel();
        this.FilterStateModel = new FilterStateModel();
        this.HideZeroMatchFilters = false;
    }
}

;// ./src/components/spaCosmos/commonModels/dealerModel.ts
class DealerModel {
}

// EXTERNAL MODULE: ./src/components/spaCosmos/commonModels/srpPageSettingsModel.ts
var srpPageSettingsModel = __webpack_require__(16611);
;// ./src/components/spaCosmos/commonModels/srpModel.ts







class SrpModel {
    constructor() {
        this.FilterPanelModel = new FilterPanelModel();
        this.SearchResultsListModel = new SearchResultsListModel();
        this.SearchValetModel = new SearchValetModel();
        this.SrpPageSettingsModel = new srpPageSettingsModel/* SrpPageSettingsModel */.J();
        this.DealerModel = new DealerModel();
        this.SearchPaginationModel = new SearchPaginationModel();
        this.TpiSpace = 0;
        this.DefaultLayoutType = srpLayoutType/* SrpLayoutType */._.Grid;
    }
}

// EXTERNAL MODULE: ./src/components/spaCosmos/customDropdown/customDropdownModel.ts
var customDropdownModel = __webpack_require__(73743);
// EXTERNAL MODULE: ./src/components/spaCosmos/utilities/spaBreakpoints.ts
var spaBreakpoints = __webpack_require__(13402);
// EXTERNAL MODULE: ./src/inversify.config.ts + 22 modules
var inversify_config = __webpack_require__(16588);
// EXTERNAL MODULE: ./src/services/toggles/toggleService.ts
var toggles_toggleService = __webpack_require__(74529);
// EXTERNAL MODULE: ./src/types/types.ts
var types = __webpack_require__(45644);
// EXTERNAL MODULE: ./src/utilities/urlHelpers.ts
var urlHelpers = __webpack_require__(7324);
// EXTERNAL MODULE: ./src/infrastructure/vue/cosmosSrp/customEvents.ts
var customEvents = __webpack_require__(29600);
// EXTERNAL MODULE: ./src/infrastructure/vue/cosmosSrp/filterStore.ts + 1 modules
var cosmosSrp_filterStore = __webpack_require__(46055);
;// ./src/services/tracker/oemTrackerService.ts
function callOemTracker(filters, count) {
    if (!window.TrackFilteredSearch) {
        return;
    }
    window.TrackFilteredSearch({ filters, count });
}

// EXTERNAL MODULE: ./node_modules/lodash.debounce/index.js
var lodash_debounce = __webpack_require__(50730);
var lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);
// EXTERNAL MODULE: ./src/components/spaCosmos/pagination/pagingModel.ts
var pagingModel = __webpack_require__(81719);
;// ./src/components/spaCosmos/pagination/paginationDataModel.ts
class PaginationDataModel {
    constructor() {
        this.PageEnd = 1;
        this.PageNumber = 1;
        this.PageStart = 1;
        this.TotalPages = 1;
        this.TotalCount = 0;
    }
}

// EXTERNAL MODULE: ./src/components/spaCosmos/pagination/srpScrollType.ts
var srpScrollType = __webpack_require__(31560);
// EXTERNAL MODULE: ./src/components/spaCosmos/utilities/SpaHelpers.ts
var SpaHelpers = __webpack_require__(14423);
// EXTERNAL MODULE: ./src/infrastructure/vue/cosmosSrp/vehicleLoadCause.ts
var vehicleLoadCause = __webpack_require__(23249);
;// ./src/infrastructure/vue/cosmosSrp/vehicleStore.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};













const useVehicleStore = (0,pinia/* defineStore */.nY)('vehicle', () => {
    const globalStore = useGlobalStore();
    const vehicleService = inversify_config.doIocContainer.get(types/* TYPES */.Q.IVehicleService);
    const loadingVehicles = (0,vue_runtime_esm_browser_prod/* ref */.KR)(true);
    const isInfiniteScrollLoading = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    const loadedScripts = (0,vue_runtime_esm_browser_prod/* ref */.KR)(new Set());
    const isConsumerReportsScriptLoaded = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    const isLoadingVehicles = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => loadingVehicles.value);
    const causeOfLastVehicleLoad = (0,vue_runtime_esm_browser_prod/* ref */.KR)(vehicleLoadCause/* VehicleLoadCause */.q.Unknown);
    // Note: Paging data only loads after the first call to vehicleStore.getCosmosSrpVehicles(). It is
    //        not initialized before that call so we need to account for this anywhere we try to access
    //        paging data before the first call to get vehicles
    const getTpiScripts = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => loadedScripts.value);
    const isPagingInitialized = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => { var _a, _b; return ((_b = (_a = globalStore.getSrpModel) === null || _a === void 0 ? void 0 : _a.SearchPaginationModel) === null || _b === void 0 ? void 0 : _b.Paging) !== undefined; });
    const getPaginationDataModel = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => { var _a, _b; return (_b = (_a = globalStore.getSrpModel.SearchPaginationModel) === null || _a === void 0 ? void 0 : _a.Paging) === null || _b === void 0 ? void 0 : _b.PaginationDataModel; });
    const infiniteScrollMaxReached = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return ((_d = (_c = (_b = (_a = globalStore.getSrpModel.SearchPaginationModel) === null || _a === void 0 ? void 0 : _a.Paging) === null || _b === void 0 ? void 0 : _b.PaginationDataModel) === null || _c === void 0 ? void 0 : _c.PageNumber) !== null && _d !== void 0 ? _d : 1) >=
            ((_h = (_g = (_f = (_e = globalStore.getSrpModel.SearchPaginationModel) === null || _e === void 0 ? void 0 : _e.Paging) === null || _f === void 0 ? void 0 : _f.PaginationDataModel) === null || _g === void 0 ? void 0 : _g.TotalPages) !== null && _h !== void 0 ? _h : 1);
    });
    const getVehicleCount = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => { var _a, _b, _c; return (_c = (_b = (_a = globalStore.getSrpModel.SearchPaginationModel) === null || _a === void 0 ? void 0 : _a.Paging) === null || _b === void 0 ? void 0 : _b.PaginationDataModel.TotalCount) !== null && _c !== void 0 ? _c : 0; });
    const getVehicleScrollType = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => { var _a, _b; return (_b = (_a = globalStore.getSrpModel.SearchPaginationModel) === null || _a === void 0 ? void 0 : _a.SrpScrollType) !== null && _b !== void 0 ? _b : srpScrollType/* SrpScrollType */.v.InfiniteScroll; });
    const getTdgHeartVehicles = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => { var _a, _b; return (_b = (_a = globalStore.getSrpModel.SearchPaginationModel) === null || _a === void 0 ? void 0 : _a.TdgSaveHeartVehicles) !== null && _b !== void 0 ? _b : {}; });
    const getCauseOfLastVehicleLoad = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => causeOfLastVehicleLoad.value);
    function getVehiclesFromVehicleService() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield vehicleService.getVehicles(globalStore.getSrpModel.DealerModel.DealerId, globalStore.getSrpModel.PageId, (_a = getPaginationDataModel.value) !== null && _a !== void 0 ? _a : new PaginationDataModel(), globalStore.getSrpModel.BaseFilter, globalStore.getDynamicCountsSearch);
            return response;
        });
    }
    //Vehicles
    function getCosmosSrpVehicles() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                loadingVehicles.value = true;
                document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.VehicleLoadStart));
                const response = yield getVehiclesFromVehicleService();
                updateVehiclePagingModel(response);
                if (!globalStore.isInitialLoad) {
                    //fire OEM specific tagging events
                    callOemTracker(location.search, response.Paging.PaginationDataModel.TotalCount);
                }
                globalStore.setInitialLoad(false);
                loadingVehicles.value = false;
                document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.VehicleSearchEnd));
                //NOTE: CosmosSrpCustomEvents.VehicleLoadEnd is dispatched in other locations to account for
                //      infinte scrolling and dynamicVehicleCards. VehicleSearchEnd only fires once so the 
                //      label containing the vehicle count updates 
            }
            catch (error) {
                loadingVehicles.value = false;
                document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.VehicleSearchEnd));
                console.error(`Error fetching data: ${error}`);
            }
        });
    }
    function updateVehiclePagingModel(response) {
        globalStore.setConditionalBlock(response.ConditionalBlockHtml);
        //update the search pagination information
        Object.assign(globalStore.getSrpModel.SearchPaginationModel, response);
        //update the search results list information
        if (globalStore.getSrpModel.SearchResultsListModel != null && (response === null || response === void 0 ? void 0 : response.SuggestionRedirectModel) != null) {
            globalStore.getSrpModel.SearchResultsListModel.HasRedirect = response.SuggestionRedirectModel.HasRedirect;
            globalStore.getSrpModel.SearchResultsListModel.HasSuggestion = response.SuggestionRedirectModel.HasSuggestion;
            globalStore.getSrpModel.SearchResultsListModel.SearchInsteadUrl = response.SuggestionRedirectModel.SearchInsteadUrl;
            globalStore.getSrpModel.SearchResultsListModel.SearchInsteadText = response.SuggestionRedirectModel.SearchInsteadText;
            globalStore.getSrpModel.SearchResultsListModel.ShowingResultsForUrl = response.SuggestionRedirectModel.ShowingResultsForUrl;
            globalStore.getSrpModel.SearchResultsListModel.ShowingResultsForText = response.SuggestionRedirectModel.ShowingResultsForText;
        }
    }
    function addMoreVehicleCardsOnScroll() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                isInfiniteScrollLoading.value = true;
                causeOfLastVehicleLoad.value = vehicleLoadCause/* VehicleLoadCause */.q.InfiniteScroll;
                globalStore.getSrpModel.SearchPaginationModel.Paging.PaginationDataModel.PageNumber++;
                document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.VehicleLoadStart));
                let baseFilter = globalStore.getSrpModel.BaseFilter;
                const response = yield vehicleService.getVehicles(globalStore.getSrpModel.DealerModel.DealerId, globalStore.getSrpModel.PageId, getPaginationDataModel.value, baseFilter, globalStore.getDynamicCountsSearch);
                //append the new vehicles to the existing list
                globalStore.getSrpModel.SearchPaginationModel.DisplayCards.push(...response.DisplayCards);
                //BEGIN OEM WORK
                //fire OEM specific tagging events
                callOemTracker(location.search, response.Paging.PaginationDataModel.TotalCount);
                //update tdg heart vehicles
                setTdgSaveHeartVehicles(response.TdgSaveHeartVehicles);
                //END OEM WORK
                isInfiniteScrollLoading.value = false;
                (0,vue_runtime_esm_browser_prod/* nextTick */.dY)(() => {
                    document.dispatchEvent(new CustomEvent(customEvents/* CosmosSrpCustomEvents */.A.VehicleLoadEnd));
                });
            }
            catch (error) {
                isInfiniteScrollLoading.value = false;
                console.error(`Error fetching data: ${error}`);
            }
        });
    }
    const getVehiclesWithDebounce = lodash_debounce_default()(() => __awaiter(void 0, void 0, void 0, function* () {
        yield getCosmosSrpVehicles();
    }), 500);
    // Immediate version for initial page load - bypasses 500ms debounce
    const getVehiclesImmediate = () => __awaiter(void 0, void 0, void 0, function* () {
        yield getCosmosSrpVehicles();
    });
    //NOTE: Call this after applying filters and reset the initial page to 1
    function getFilteredVehicles() {
        globalStore.filterStore.setWaitingToFilterVehicles(false);
        this.setPageNumber(1);
    }
    // Immediate version for initial page load
    function getFilteredVehiclesImmediate() {
        globalStore.filterStore.setWaitingToFilterVehicles(false);
        this.setPageNumber(1, true);
    }
    //Pagination
    function setPageNumber(pageNumber, useImmediate = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (isPagingInitialized.value) {
                // Scroll as early as possible to help UX shift
                srpScrollTop();
                yield (0,vue_runtime_esm_browser_prod/* nextTick */.dY)();
                globalStore.getSrpModel.SearchPaginationModel.Paging.PaginationDataModel.PageNumber = pageNumber;
                const removeParm = pageNumber === 1 ? true : false;
                globalStore.updateQueryParameter(pagingModel/* PaginationQueryParams */.p.PageNumber, pageNumber, removeParm);
                // Update pt=# in dynamicSearchCounts
                const dynamicCountsSearch = ((_a = globalStore.getDynamicCountsSearch) !== null && _a !== void 0 ? _a : "").replace(/pt=\d+/, `pt=${pageNumber}`);
                globalStore.setDynamicCountsSearch(dynamicCountsSearch);
            }
            causeOfLastVehicleLoad.value = vehicleLoadCause/* VehicleLoadCause */.q.SetPageNumber;
            if (useImmediate) {
                yield getVehiclesImmediate();
            }
            else {
                yield getVehiclesWithDebounce();
            }
        });
    }
    function setPageSize(pageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            globalStore.getSrpModel.SearchPaginationModel.Paging.PaginationDataModel.PageSize = pageSize;
            globalStore.updateQueryParameter(pagingModel/* PaginationQueryParams */.p.PageSize, pageSize, false);
            setPageNumber(1);
            causeOfLastVehicleLoad.value = vehicleLoadCause/* VehicleLoadCause */.q.SetPageSize;
            yield getVehiclesWithDebounce();
        });
    }
    function srpScrollTop() {
        // very hacky, if not impossible to calculate scroll using only DOM elements VHCLIAA controls
        const cBlock2Elem = document.querySelector("#cBlock2");
        const desktopHeaderElem = document.querySelector(".headerWrapper.full");
        const scrollTop = (cBlock2Elem === null || cBlock2Elem === void 0 ? void 0 : cBlock2Elem.offsetTop) - (desktopHeaderElem === null || desktopHeaderElem === void 0 ? void 0 : desktopHeaderElem.offsetHeight);
        if (window.scrollY > scrollTop) {
            window.scroll({
                top: scrollTop,
                behavior: 'smooth'
            });
        }
    }
    function isScriptLoaded(scriptSrc) {
        if (loadedScripts.value.has(scriptSrc)) {
            return true;
        }
        return false;
    }
    function addLoadedScript(scriptSrc) {
        loadedScripts.value.add(scriptSrc);
    }
    // Event handler function for TDG heart event
    function processTdgVehicleHearts() {
        var _a;
        if (window.DGDataHub && getTdgHeartVehicles.value && Object.keys(getTdgHeartVehicles.value).length > 0) {
            window.DGDataHub.srpSaveItems = getTdgHeartVehicles.value;
        }
        // dependency components/digitalGarage/main.js
        (_a = window.toyotaDigitalGarageScript) === null || _a === void 0 ? void 0 : _a.srpSaveItemsRender();
    }
    function addConsumerReportsScript() {
        if (!isConsumerReportsScriptLoaded.value) {
            const url = "/resources/vhcliaa/components/consumerReports/consumerReports.js";
            SpaHelpers/* SpaHelpers */.A.loadScript(`${url}?v=${window.DlronGlobal_PlatformVersion}`);
            isConsumerReportsScriptLoaded.value = true;
        }
    }
    function setTdgSaveHeartVehicles(tdgVehicles) {
        if (tdgVehicles) {
            Object.assign(globalStore.getSrpModel.SearchPaginationModel.TdgSaveHeartVehicles, tdgVehicles);
        }
    }
    return {
        getCosmosSrpVehicles,
        isLoadingVehicles,
        addMoreVehicleCardsOnScroll,
        isInfiniteScrollLoading,
        infiniteScrollMaxReached,
        setPageNumber,
        setPageSize,
        isScriptLoaded,
        addLoadedScript,
        getFilteredVehicles,
        getFilteredVehiclesImmediate,
        getVehicleCount,
        getVehicleScrollType,
        isPagingInitialized,
        addConsumerReportsScript,
        processTdgVehicleHearts,
        getTpiScripts,
        getCauseOfLastVehicleLoad,
        srpScrollTop,
        getVehiclesFromVehicleService,
    };
});

;// ./src/infrastructure/vue/cosmosSrp/globalStore.ts
var globalStore_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};












const useGlobalStore = (0,pinia/* defineStore */.nY)('global', () => {
    const filterStore = (0,cosmosSrp_filterStore/* useFilterStore */.P)();
    const vehicleStore = useVehicleStore();
    const activeVehicleDropdown = (0,vue_runtime_esm_browser_prod/* ref */.KR)(null);
    const toggleService = inversify_config.doIocContainer.get(types/* TYPES */.Q.IToggleService);
    const currentUrl = (0,vue_runtime_esm_browser_prod/* ref */.KR)("");
    //Don't access this directly from outside the globalStore. Instead, use getSrpModel
    const srpModel = (0,vue_runtime_esm_browser_prod/* reactive */.Kh)(new SrpModel());
    const dropdownStates = (0,vue_runtime_esm_browser_prod/* reactive */.Kh)(new Array());
    const initializedDataComplete = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    const initializationError = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    const initialLoad = (0,vue_runtime_esm_browser_prod/* ref */.KR)(true);
    const isMobile = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    const currentLayout = (0,vue_runtime_esm_browser_prod/* ref */.KR)(srpModel.DefaultLayoutType);
    const dynamicCountsSearch = (0,vue_runtime_esm_browser_prod/* ref */.KR)("");
    const getDynamicCountsSearch = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => dynamicCountsSearch.value);
    const isProgrammaticScroll = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    function setDynamicCountsSearch(value) {
        dynamicCountsSearch.value = value;
    }
    ;
    const getSrpModel = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => srpModel);
    const getActiveOem = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => {
        try {
            const raw = window.DlronGlobal_ActiveOemProgram;
            if (!raw)
                return null;
            if (typeof raw === 'string')
                return raw.toLowerCase();
            return String(raw).toLowerCase();
        }
        catch (_a) {
            return null;
        }
    });
    const getSearchPageType = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => {
        var _a;
        return ((_a = srpModel.PageVehicleType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || 'new';
    });
    const getInventorySettingsSrp = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => {
        var _a, _b;
        try {
            return (_b = (_a = srpModel === null || srpModel === void 0 ? void 0 : srpModel.FilterPanelModel) === null || _a === void 0 ? void 0 : _a.InventorySettingsSrp) !== null && _b !== void 0 ? _b : null;
        }
        catch (_c) {
            return null;
        }
    });
    const isInitialized = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => initializedDataComplete.value);
    const isInitialLoad = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => initialLoad.value);
    const getPrimaryMake = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => srpModel.DealerModel.PrimaryMake);
    const getIndustry = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => srpModel.DealerModel.Industry);
    const getCurrencyCode = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => srpModel.DealerModel.CurrencyCode);
    const getActiveVehicleDropdown = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => activeVehicleDropdown.value);
    const getDropdownStates = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => dropdownStates);
    const getCurrentUrl = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => currentUrl.value);
    function setup() {
        return globalStore_awaiter(this, void 0, void 0, function* () {
            yield initializeData();
            if ((toggleService === null || toggleService === void 0 ? void 0 : toggleService.getToggleStatus(toggles_toggleService/* Toggle */.lM.DO45165_InitQuickPass2)) === true) {
                console.log("Accelerated pass 2");
                prefetchCalls();
            }
            initDropdownDictionary();
            initOems();
            initBrowserNavigation();
        });
    }
    function initializeData() {
        return globalStore_awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => {
                var _a;
                if (!initializedDataComplete.value) {
                    try {
                        const componentElem = document.querySelector("#dlron-srp-model");
                        let json = null;
                        if (componentElem) {
                            json = JSON.parse((_a = componentElem.textContent) !== null && _a !== void 0 ? _a : "");
                            componentElem.remove();
                        }
                        if (json) {
                            Object.assign(srpModel, json);
                        }
                    }
                    catch (e) {
                        initializationError.value = true;
                        reject(new Error(`Error parsing JSON data from model: ${e}`));
                    }
                }
                initializedDataComplete.value = true;
                resolve(true);
            });
        });
    }
    function initDropdownDictionary() {
        // keys in dropdownStates[] are the numeric values of each enum
        // ex. Pagination = 0
        for (const dropdownType in Object.keys(customDropdownModel/* DropdownType */.m).filter(key => !isNaN(Number(key)))) {
            dropdownStates[parseInt(dropdownType)] = 0;
        }
    }
    function initOems() {
        document.addEventListener(customEvents/* CosmosSrpCustomEvents */.A.VehicleLoadEnd, vehicleStore.processTdgVehicleHearts);
    }
    //Update the conditional blocks.
    //This is a special case where we need to remove/update the existing conditional block
    //because the conditional block is located outside of the Vue app
    function setConditionalBlock(data) {
        if ((toggleService === null || toggleService === void 0 ? void 0 : toggleService.getToggleStatus(toggles_toggleService/* Toggle */.lM.DO37371)) === true) {
            try {
                const json = JSON.parse(data);
                if ((json === null || json === void 0 ? void 0 : json.Id) && (json === null || json === void 0 ? void 0 : json.Children) && (json === null || json === void 0 ? void 0 : json.TargetAreaId)) {
                    data = `<do-banner target-area="${json.TargetAreaId}" carousel-id="${json.Id}" banner-id="${json.Children}"></do-banner>`;
                }
                else {
                    data = null;
                }
            }
            catch (error) {
                console.error("Error parsing conditional block JSON:", error);
                data = null;
            }
        }
        const mainContent = document.getElementById("content-main");
        let conditionalBlocksParent;
        let bannerBlocksParent;
        if (mainContent) {
            if ((toggleService === null || toggleService === void 0 ? void 0 : toggleService.getToggleStatus(toggles_toggleService/* Toggle */.lM.DO37371)) === true) {
                const doBanner = mainContent.querySelector("do-banner");
                if (doBanner) {
                    bannerBlocksParent = doBanner.parentElement;
                    bannerBlocksParent.removeChild(doBanner);
                }
            }
            // TODO: Remove this when we are ready to remove the old conditional blocks
            const conditionalBlocks = mainContent.querySelector(".conditionalBlocks");
            if (conditionalBlocks) {
                conditionalBlocksParent = conditionalBlocks.parentElement;
                conditionalBlocksParent.removeChild(conditionalBlocks);
            }
        }
        if ((toggleService === null || toggleService === void 0 ? void 0 : toggleService.getToggleStatus(toggles_toggleService/* Toggle */.lM.DO37371)) === true) {
            if (data && bannerBlocksParent) {
                bannerBlocksParent.insertAdjacentHTML("afterbegin", data);
            }
            else if (data) {
                mainContent.insertAdjacentHTML("afterbegin", data);
            }
        }
        else {
            //TODO: Remove this when we are ready to remove the old conditional blocks
            if (data && conditionalBlocksParent) {
                conditionalBlocksParent.insertAdjacentHTML("afterbegin", data);
            }
            else if (data) {
                mainContent.insertAdjacentHTML("afterbegin", data);
            }
        }
    }
    function updateQueryParameter(key, value, remove) {
        const currentURL = new URL(window.location.href);
        const searchParams = urlHelpers/* UrlHelpers */.b.queryStringToArray(currentURL.search);
        if (remove) {
            const index = searchParams.findIndex(param => param.key === key);
            // If the object is found, remove it from the array
            if (index > -1) {
                searchParams.splice(index, 1);
            }
        }
        else {
            // Update or add the query parameter
            urlHelpers/* UrlHelpers */.b.setQueryParam(key, value, searchParams);
        }
        currentURL.search = urlHelpers/* UrlHelpers */.b.mapArrayToQueryString(searchParams);
        updateUrlState(currentURL.toString());
    }
    function updateUrlState(url) {
        // We do not push a history state if it is the initial page load
        // This allows us to reload the page when using browser navigation
        if (!isInitialLoad.value && (url != getCurrentUrl.value)) {
            currentUrl.value = url;
            history.pushState({}, '', url);
        }
    }
    function initBrowserNavigation() {
        window.addEventListener('popstate', () => {
            location.reload();
        });
    }
    function setInitialLoad(value) {
        initialLoad.value = value;
    }
    function setActiveVehicleDropdown(value) {
        activeVehicleDropdown.value = value;
    }
    function setDropdownState(type, selectedIndex) {
        dropdownStates[type] = selectedIndex;
    }
    function updateProgramaticScroll(value) {
        isProgrammaticScroll.value = value;
    }
    function setUrlWithDynamicCountFilters() {
        // If we have a Dynamic Counts Search (can't add those to url because it will apply on refresh) then we add it to url now
        // because we have applied those filters
        if (dynamicCountsSearch.value) {
            const url = new URL(location.href);
            url.search = dynamicCountsSearch.value;
            const formattedUrl = url.toString();
            updateUrlState(formattedUrl);
        }
    }
    function prefetchCalls() {
        // Set mobile state before prefetching using the centralized breakpoint
        isMobile.value = window.innerWidth <= spaBreakpoints/* SpaBreakpoints */.h.breakpoint991;
        // Check if mobile filter optimization is enabled
        const mobileFilterOptimizationEnabled = (toggleService === null || toggleService === void 0 ? void 0 : toggleService.getToggleStatus(toggles_toggleService/* Toggle */.lM.MobileFilterOptimization_DO46753)) === true
            && !filterStore.isDynamicFiltering;
        // On mobile with optimization enabled, only prefetch vehicles to optimize initial load
        // Filters will be loaded when user opens filter panel
        if (isMobile.value && mobileFilterOptimizationEnabled) {
            vehicleStore.getVehiclesFromVehicleService();
        }
        else {
            filterStore.getFiltersFromFilterService();
            vehicleStore.getVehiclesFromVehicleService();
        }
    }
    /// NOTE: Double-check if any props added here are also needed for the VehicleCardDeck (ex. /mysavedvehicles page)
    /// Props needed for VehicleCardDeck need to be copied over to infrastructure/vue/vehicleCardDeck/globalStore.ts
    return {
        setup,
        getSrpModel,
        getActiveOem,
        getInventorySettingsSrp,
        isInitialized,
        isInitialLoad,
        setInitialLoad,
        updateUrlState,
        setConditionalBlock,
        updateQueryParameter,
        filterStore,
        vehicleStore,
        getPrimaryMake,
        setActiveVehicleDropdown,
        getActiveVehicleDropdown,
        setDropdownState,
        getDropdownStates,
        setDynamicCountsSearch,
        getDynamicCountsSearch,
        isMobile,
        currentLayout,
        setUrlWithDynamicCountFilters,
        getIndustry,
        isProgrammaticScroll,
        updateProgramaticScroll,
        getCurrencyCode,
        getSearchPageType,
    };
});


/***/ }),

/***/ 55141:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ ToggleFetcher)
/* harmony export */ });
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90260);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

let ToggleFetcher = class ToggleFetcher {
    fetch() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `/api/vhcliaa/config/get-all-toggles/${window.DlronGlobal_DealerId}`;
            if (window._toggleFetcherToggles && window._toggleFetcherToggles[url] !== undefined && window._toggleFetcherToggles[url] !== null) {
                return window._toggleFetcherToggles[url];
            }
            let togglesPromise = this.getResponse(url);
            window._toggleFetcherToggles = {};
            window._toggleFetcherToggles[url] = togglesPromise;
            return togglesPromise;
        });
    }
    getResponse(url) {
        return __awaiter(this, void 0, void 0, function* () {
            let promise;
            if (window._toggleFetcherCache && window._toggleFetcherCache[url] !== undefined && window._toggleFetcherCache[url] !== null) {
                promise = window._toggleFetcherCache[url];
                window._toggleFetcherCache[url] = undefined; //make sure to consume response only once
            }
            try {
                if (!promise) {
                    promise = fetch(url);
                }
                const response = yield promise;
                if (response.ok) {
                    const responseData = yield response.json();
                    return responseData;
                }
                else {
                    throw new Error(`Error: ${response.status} for endpoint ${url}`);
                }
            }
            catch (error) {
                console.error(new Error(`Error fetching toggles from ${url}: ${error.message}`));
                return {};
            }
        });
    }
};
ToggleFetcher = __decorate([
    (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .injectable */ ._G)()
], ToggleFetcher);



/***/ }),

/***/ 56579:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ VehiclePricestakDisclaimerModal)
/* harmony export */ });
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90260);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

let VehiclePricestakDisclaimerModal = class VehiclePricestakDisclaimerModal {
    initialize() {
        const disclaimerBtns = document.querySelectorAll('[data-target="#ModalPriceStakDisclaimer"]');
        disclaimerBtns.forEach(btn => {
            this.addDisclaimerBtnTagging(btn);
        });
        const modal = window.jQuery("#ModalPriceStakDisclaimer");
        if (modal) {
            modal.on('show.bs.modal', function (e) {
                const toggleElem = e.relatedTarget.querySelector('.hidden');
                if (toggleElem) {
                    modal.find("#priceStakDisclaimerModalText").html(toggleElem.innerHTML);
                }
            });
        }
    }
    addDisclaimerBtnTagging(btn) {
        const taggingParentElement = document.querySelector("[data-dotagging-event-owner]");
        btn.setAttribute("data-dotagging-event", "cta_interaction");
        btn.setAttribute("data-dotagging-event-action", "click");
        btn.setAttribute("data-dotagging-event-action-result", "open");
        btn.setAttribute("data-dotagging-element-order", "0");
        btn.setAttribute("data-dotagging-element-type", "item_details");
        btn.setAttribute("data-dotagging-element-subtype", "cta_button");
    }
};
VehiclePricestakDisclaimerModal = __decorate([
    (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .injectable */ ._G)()
], VehiclePricestakDisclaimerModal);



/***/ }),

/***/ 56839:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: () => (/* binding */ HideableScrollbar)
/* harmony export */ });
/* harmony import */ var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74208);

class HideableScrollbar {
    constructor(containerElem, addResizeListener = true, addIntersectionListener = false) {
        this._containerElem = containerElem;
        this._scrollbarVisibleClassName = 'scrollbar-visible';
        this._scrollbarEnabledClassName = 'enable-scrolling';
        this._elementInView = false;
        this._mouseHovering = false;
        this._scrollbarVisibleEvent = new Event("scrollbar-visible");
        this._scrollbarHiddenEvent = new Event("scrollbar-hidden");
        if (addResizeListener) {
            this.addResizeListeners();
        }
        else if (addIntersectionListener) {
            this.addIntersectionListeners();
        }
        this.addHoverListeners(addIntersectionListener);
    }
    addResizeListeners() {
        const elementResizeObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A(() => {
            // Apply the appropriate scrollbar styling when container is resized by scrolling through the page
            this.checkHeights(this._containerElem, this._mouseHovering, true);
        });
        elementResizeObserver.observe(this._containerElem);
    }
    // Enable scrolling only when the element is in full view
    addIntersectionListeners() {
        const elementIntersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                var _a, _b, _c, _d, _e, _f;
                if (entry.isIntersecting) {
                    (_a = this._containerElem.classList) === null || _a === void 0 ? void 0 : _a.add(this._scrollbarEnabledClassName);
                    this._containerElem.scrollIntoView(false);
                    this._elementInView = true;
                }
                else {
                    (_c = (_b = this._containerElem) === null || _b === void 0 ? void 0 : _b.classList) === null || _c === void 0 ? void 0 : _c.remove(this._scrollbarVisibleClassName);
                    (_d = this._containerElem) === null || _d === void 0 ? void 0 : _d.dispatchEvent(this._scrollbarHiddenEvent);
                    (_f = (_e = this._containerElem) === null || _e === void 0 ? void 0 : _e.classList) === null || _f === void 0 ? void 0 : _f.remove(this._scrollbarEnabledClassName);
                    this._elementInView = false;
                }
            });
        }, { threshold: 1 });
        elementIntersectionObserver.observe(this._containerElem);
    }
    addHoverListeners(hasIntersectionListener) {
        var _a, _b;
        (_a = this._containerElem) === null || _a === void 0 ? void 0 : _a.addEventListener('mouseover', () => {
            this._mouseHovering = true;
            // if mouse is over #srp_filter element and #srp_filter content is overflowing, add class
            this.checkHeights(this._containerElem, this._mouseHovering, hasIntersectionListener ? this._elementInView : true);
        });
        (_b = this._containerElem) === null || _b === void 0 ? void 0 : _b.addEventListener('mouseleave', () => {
            this._mouseHovering = false;
            // Only remove class if scrollbar exists
            this.checkHeights(this._containerElem, this._mouseHovering, hasIntersectionListener ? this._elementInView : true);
        });
    }
    // Function to adjust scrollbar styling in resize events
    checkHeights(containerElem, mouseHovering, elementInView) {
        var _a, _b, _c, _d, _e, _f;
        if (mouseHovering && elementInView && containerElem.scrollHeight > containerElem.clientHeight) {
            (_b = (_a = this._containerElem) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add(this._scrollbarVisibleClassName);
            (_c = this._containerElem) === null || _c === void 0 ? void 0 : _c.dispatchEvent(this._scrollbarVisibleEvent);
        }
        else {
            (_e = (_d = this._containerElem) === null || _d === void 0 ? void 0 : _d.classList) === null || _e === void 0 ? void 0 : _e.remove(this._scrollbarVisibleClassName);
            (_f = this._containerElem) === null || _f === void 0 ? void 0 : _f.dispatchEvent(this._scrollbarHiddenEvent);
        }
    }
}


/***/ }),

/***/ 57911:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.circularDependencyToException = exports.listMetadataForTarget = exports.listRegisteredBindingsForServiceIdentifier = exports.getServiceIdentifierAsString = exports.getFunctionName = void 0;
var ERROR_MSGS = __webpack_require__(27718);
function getServiceIdentifierAsString(serviceIdentifier) {
  if (typeof serviceIdentifier === "function") {
    var _serviceIdentifier = serviceIdentifier;
    return _serviceIdentifier.name;
  } else if (typeof serviceIdentifier === "symbol") {
    return serviceIdentifier.toString();
  } else {
    var _serviceIdentifier = serviceIdentifier;
    return _serviceIdentifier;
  }
}
exports.getServiceIdentifierAsString = getServiceIdentifierAsString;
function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
  var registeredBindingsList = "";
  var registeredBindings = getBindings(container, serviceIdentifier);
  if (registeredBindings.length !== 0) {
    registeredBindingsList = "\nRegistered bindings:";
    registeredBindings.forEach(function (binding) {
      var name = "Object";
      if (binding.implementationType !== null) {
        name = getFunctionName(binding.implementationType);
      }
      registeredBindingsList = registeredBindingsList + "\n " + name;
      if (binding.constraint.metaData) {
        registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
      }
    });
  }
  return registeredBindingsList;
}
exports.listRegisteredBindingsForServiceIdentifier = listRegisteredBindingsForServiceIdentifier;
function alreadyDependencyChain(request, serviceIdentifier) {
  if (request.parentRequest === null) {
    return false;
  } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
    return true;
  } else {
    return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
  }
}
function dependencyChainToString(request) {
  function _createStringArr(req, result) {
    if (result === void 0) {
      result = [];
    }
    var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
    result.push(serviceIdentifier);
    if (req.parentRequest !== null) {
      return _createStringArr(req.parentRequest, result);
    }
    return result;
  }
  var stringArr = _createStringArr(request);
  return stringArr.reverse().join(" --> ");
}
function circularDependencyToException(request) {
  request.childRequests.forEach(function (childRequest) {
    if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
      var services = dependencyChainToString(childRequest);
      throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY + " " + services);
    } else {
      circularDependencyToException(childRequest);
    }
  });
}
exports.circularDependencyToException = circularDependencyToException;
function listMetadataForTarget(serviceIdentifierString, target) {
  if (target.isTagged() || target.isNamed()) {
    var m_1 = "";
    var namedTag = target.getNamedTag();
    var otherTags = target.getCustomTags();
    if (namedTag !== null) {
      m_1 += namedTag.toString() + "\n";
    }
    if (otherTags !== null) {
      otherTags.forEach(function (tag) {
        m_1 += tag.toString() + "\n";
      });
    }
    return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
  } else {
    return " " + serviceIdentifierString;
  }
}
exports.listMetadataForTarget = listMetadataForTarget;
function getFunctionName(v) {
  if (v.name) {
    return v.name;
  } else {
    var name_1 = v.toString();
    var match = name_1.match(/^function\s*([^\s(]+)/);
    return match ? match[1] : "Anonymous function: " + name_1;
  }
}
exports.getFunctionName = getFunctionName;

/***/ }),

/***/ 59592:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFunctionName = exports.getBaseClassDependencyCount = exports.getDependencies = void 0;
var inject_1 = __webpack_require__(47442);
var ERROR_MSGS = __webpack_require__(27718);
var literal_types_1 = __webpack_require__(27802);
var METADATA_KEY = __webpack_require__(94725);
var serialization_1 = __webpack_require__(57911);
Object.defineProperty(exports, "getFunctionName", ({
  enumerable: true,
  get: function () {
    return serialization_1.getFunctionName;
  }
}));
var target_1 = __webpack_require__(70154);
function getDependencies(metadataReader, func) {
  var constructorName = serialization_1.getFunctionName(func);
  var targets = getTargets(metadataReader, constructorName, func, false);
  return targets;
}
exports.getDependencies = getDependencies;
function getTargets(metadataReader, constructorName, func, isBaseClass) {
  var metadata = metadataReader.getConstructorMetadata(func);
  var serviceIdentifiers = metadata.compilerGeneratedMetadata;
  if (serviceIdentifiers === undefined) {
    var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
    throw new Error(msg);
  }
  var constructorArgsMetadata = metadata.userGeneratedMetadata;
  var keys = Object.keys(constructorArgsMetadata);
  var hasUserDeclaredUnknownInjections = func.length === 0 && keys.length > 0;
  var iterations = hasUserDeclaredUnknownInjections ? keys.length : func.length;
  var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
  var propertyTargets = getClassPropsAsTargets(metadataReader, func);
  var targets = __spreadArrays(constructorTargets, propertyTargets);
  return targets;
}
function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
  var targetMetadata = constructorArgsMetadata[index.toString()] || [];
  var metadata = formatTargetMetadata(targetMetadata);
  var isManaged = metadata.unmanaged !== true;
  var serviceIdentifier = serviceIdentifiers[index];
  var injectIdentifier = metadata.inject || metadata.multiInject;
  serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;
  if (serviceIdentifier instanceof inject_1.LazyServiceIdentifer) {
    serviceIdentifier = serviceIdentifier.unwrap();
  }
  if (isManaged) {
    var isObject = serviceIdentifier === Object;
    var isFunction = serviceIdentifier === Function;
    var isUndefined = serviceIdentifier === undefined;
    var isUnknownType = isObject || isFunction || isUndefined;
    if (!isBaseClass && isUnknownType) {
      var msg = ERROR_MSGS.MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
      throw new Error(msg);
    }
    var target = new target_1.Target(literal_types_1.TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
    target.metadata = targetMetadata;
    return target;
  }
  return null;
}
function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
  var targets = [];
  for (var i = 0; i < iterations; i++) {
    var index = i;
    var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
    if (target !== null) {
      targets.push(target);
    }
  }
  return targets;
}
function getClassPropsAsTargets(metadataReader, constructorFunc) {
  var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
  var targets = [];
  var keys = Object.keys(classPropsMetadata);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    var targetMetadata = classPropsMetadata[key];
    var metadata = formatTargetMetadata(classPropsMetadata[key]);
    var targetName = metadata.targetName || key;
    var serviceIdentifier = metadata.inject || metadata.multiInject;
    var target = new target_1.Target(literal_types_1.TargetTypeEnum.ClassProperty, targetName, serviceIdentifier);
    target.metadata = targetMetadata;
    targets.push(target);
  }
  var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
  if (baseConstructor !== Object) {
    var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor);
    targets = __spreadArrays(targets, baseTargets);
  }
  return targets;
}
function getBaseClassDependencyCount(metadataReader, func) {
  var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
  if (baseConstructor !== Object) {
    var baseConstructorName = serialization_1.getFunctionName(baseConstructor);
    var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
    var metadata = targets.map(function (t) {
      return t.metadata.filter(function (m) {
        return m.key === METADATA_KEY.UNMANAGED_TAG;
      });
    });
    var unmanagedCount = [].concat.apply([], metadata).length;
    var dependencyCount = targets.length - unmanagedCount;
    if (dependencyCount > 0) {
      return dependencyCount;
    } else {
      return getBaseClassDependencyCount(metadataReader, baseConstructor);
    }
  } else {
    return 0;
  }
}
exports.getBaseClassDependencyCount = getBaseClassDependencyCount;
function formatTargetMetadata(targetMetadata) {
  var targetMetadataMap = {};
  targetMetadata.forEach(function (m) {
    targetMetadataMap[m.key.toString()] = m.value;
  });
  return {
    inject: targetMetadataMap[METADATA_KEY.INJECT_TAG],
    multiInject: targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG],
    targetName: targetMetadataMap[METADATA_KEY.NAME_TAG],
    unmanaged: targetMetadataMap[METADATA_KEY.UNMANAGED_TAG]
  };
}

/***/ }),

/***/ 64081:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BindingCount = void 0;
var BindingCount = {
  MultipleBindingsAvailable: 2,
  NoBindingsAvailable: 0,
  OnlyOneBindingAvailable: 1
};
exports.BindingCount = BindingCount;

/***/ }),

/***/ 65467:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  o: () => (/* binding */ useGlobalStore)
});

// EXTERNAL MODULE: ./node_modules/vue/dist/vue.runtime.esm-browser.prod.js
var vue_runtime_esm_browser_prod = __webpack_require__(23568);
// EXTERNAL MODULE: ./node_modules/pinia/dist/pinia.mjs
var pinia = __webpack_require__(10810);
// EXTERNAL MODULE: ./src/components/spaCosmos/utilities/SpaHelpers.ts
var SpaHelpers = __webpack_require__(14423);
;// ./src/infrastructure/vue/vehicleCardDeck/vehicleStore.ts



const useVehicleStore = (0,pinia/* defineStore */.nY)('vehicle', () => {
    const isConsumerReportsScriptLoaded = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    const loadingVehicles = (0,vue_runtime_esm_browser_prod/* ref */.KR)(true);
    const isLoadingVehicles = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => loadingVehicles.value);
    function setLoadingVehicles(value) {
        loadingVehicles.value = value;
    }
    function addConsumerReportsScript() {
        if (!isConsumerReportsScriptLoaded.value) {
            const url = "/resources/vhcliaa/components/consumerReports/consumerReports.js";
            SpaHelpers/* SpaHelpers */.A.loadScript(`${url}?v=${window.DlronGlobal_PlatformVersion}`);
            isConsumerReportsScriptLoaded.value = true;
        }
    }
    return {
        isLoadingVehicles,
        setLoadingVehicles,
        addConsumerReportsScript
    };
});

// EXTERNAL MODULE: ./src/core/enums/industry.ts
var industry = __webpack_require__(88586);
;// ./src/infrastructure/vue/vehicleCardDeck/globalStore.ts




const useGlobalStore = (0,pinia/* defineStore */.nY)('global', () => {
    const vehicleStore = useVehicleStore();
    const isMobile = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    const activeVehicleDropdown = (0,vue_runtime_esm_browser_prod/* ref */.KR)(null);
    const getActiveVehicleDropdown = (0,vue_runtime_esm_browser_prod/* computed */.EW)(() => activeVehicleDropdown.value);
    function setActiveVehicleDropdown(value) {
        activeVehicleDropdown.value = value;
    }
    const isProgrammaticScroll = (0,vue_runtime_esm_browser_prod/* ref */.KR)(false);
    function updateProgramaticScroll(value) {
        isProgrammaticScroll.value = value;
    }
    const getIndustry = (0,vue_runtime_esm_browser_prod/* ref */.KR)(industry/* Industry */.j.Automotive);
    function setIndustry(value) {
        getIndustry.value = value;
    }
    return {
        vehicleStore,
        getActiveVehicleDropdown,
        setActiveVehicleDropdown,
        isMobile,
        isProgrammaticScroll,
        updateProgramaticScroll,
        getIndustry,
        setIndustry
    };
});


/***/ }),

/***/ 68690:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.targetName = void 0;
var METADATA_KEY = __webpack_require__(94725);
var metadata_1 = __webpack_require__(88390);
var decorator_utils_1 = __webpack_require__(50040);
function targetName(name) {
  return function (target, targetKey, index) {
    var metadata = new metadata_1.Metadata(METADATA_KEY.NAME_TAG, name);
    decorator_utils_1.tagParameter(target, targetKey, index, metadata);
  };
}
exports.targetName = targetName;

/***/ }),

/***/ 69185:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ doBeforeNextRepaint)
/* harmony export */ });
/**
 * Do something before the browser recalculates styles. Use this for expensive operations to avoid long tasks blocking the main thread.
 * Examples of expensive operations:
 * - getBoundingClientRect()
 * - window.getComputedStyle()
 * @param callback The callback to execute before the next repaint
 * @returns A promise that resolves inside requestAnimationFrame() after the callback is executed
 */
function doBeforeNextRepaint(callback) {
    return new Promise((resolve) => {
        requestAnimationFrame(() => {
            callback();
            resolve();
        });
    });
}


/***/ }),

/***/ 69638:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Container = void 0;
var binding_1 = __webpack_require__(48677);
var ERROR_MSGS = __webpack_require__(27718);
var literal_types_1 = __webpack_require__(27802);
var METADATA_KEY = __webpack_require__(94725);
var metadata_reader_1 = __webpack_require__(15426);
var planner_1 = __webpack_require__(84387);
var resolver_1 = __webpack_require__(18156);
var binding_to_syntax_1 = __webpack_require__(6566);
var id_1 = __webpack_require__(78418);
var serialization_1 = __webpack_require__(57911);
var container_snapshot_1 = __webpack_require__(37549);
var lookup_1 = __webpack_require__(36983);
var Container = function () {
  function Container(containerOptions) {
    var options = containerOptions || {};
    if (typeof options !== "object") {
      throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
    }
    if (options.defaultScope === undefined) {
      options.defaultScope = literal_types_1.BindingScopeEnum.Transient;
    } else if (options.defaultScope !== literal_types_1.BindingScopeEnum.Singleton && options.defaultScope !== literal_types_1.BindingScopeEnum.Transient && options.defaultScope !== literal_types_1.BindingScopeEnum.Request) {
      throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
    }
    if (options.autoBindInjectable === undefined) {
      options.autoBindInjectable = false;
    } else if (typeof options.autoBindInjectable !== "boolean") {
      throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
    }
    if (options.skipBaseClassChecks === undefined) {
      options.skipBaseClassChecks = false;
    } else if (typeof options.skipBaseClassChecks !== "boolean") {
      throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
    }
    this.options = {
      autoBindInjectable: options.autoBindInjectable,
      defaultScope: options.defaultScope,
      skipBaseClassChecks: options.skipBaseClassChecks
    };
    this.id = id_1.id();
    this._bindingDictionary = new lookup_1.Lookup();
    this._snapshots = [];
    this._middleware = null;
    this.parent = null;
    this._metadataReader = new metadata_reader_1.MetadataReader();
  }
  Container.merge = function (container1, container2) {
    var container = new Container();
    var bindingDictionary = planner_1.getBindingDictionary(container);
    var bindingDictionary1 = planner_1.getBindingDictionary(container1);
    var bindingDictionary2 = planner_1.getBindingDictionary(container2);
    function copyDictionary(origin, destination) {
      origin.traverse(function (key, value) {
        value.forEach(function (binding) {
          destination.add(binding.serviceIdentifier, binding.clone());
        });
      });
    }
    copyDictionary(bindingDictionary1, bindingDictionary);
    copyDictionary(bindingDictionary2, bindingDictionary);
    return container;
  };
  Container.prototype.load = function () {
    var modules = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      modules[_i] = arguments[_i];
    }
    var getHelpers = this._getContainerModuleHelpersFactory();
    for (var _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
      var currentModule = modules_1[_a];
      var containerModuleHelpers = getHelpers(currentModule.id);
      currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
    }
  };
  Container.prototype.loadAsync = function () {
    var modules = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      modules[_i] = arguments[_i];
    }
    return __awaiter(this, void 0, void 0, function () {
      var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            getHelpers = this._getContainerModuleHelpersFactory();
            _a = 0, modules_2 = modules;
            _b.label = 1;
          case 1:
            if (!(_a < modules_2.length)) return [3, 4];
            currentModule = modules_2[_a];
            containerModuleHelpers = getHelpers(currentModule.id);
            return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction)];
          case 2:
            _b.sent();
            _b.label = 3;
          case 3:
            _a++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  };
  Container.prototype.unload = function () {
    var _this = this;
    var modules = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      modules[_i] = arguments[_i];
    }
    var conditionFactory = function (expected) {
      return function (item) {
        return item.moduleId === expected;
      };
    };
    modules.forEach(function (module) {
      var condition = conditionFactory(module.id);
      _this._bindingDictionary.removeByCondition(condition);
    });
  };
  Container.prototype.bind = function (serviceIdentifier) {
    var scope = this.options.defaultScope || literal_types_1.BindingScopeEnum.Transient;
    var binding = new binding_1.Binding(serviceIdentifier, scope);
    this._bindingDictionary.add(serviceIdentifier, binding);
    return new binding_to_syntax_1.BindingToSyntax(binding);
  };
  Container.prototype.rebind = function (serviceIdentifier) {
    this.unbind(serviceIdentifier);
    return this.bind(serviceIdentifier);
  };
  Container.prototype.unbind = function (serviceIdentifier) {
    try {
      this._bindingDictionary.remove(serviceIdentifier);
    } catch (e) {
      throw new Error(ERROR_MSGS.CANNOT_UNBIND + " " + serialization_1.getServiceIdentifierAsString(serviceIdentifier));
    }
  };
  Container.prototype.unbindAll = function () {
    this._bindingDictionary = new lookup_1.Lookup();
  };
  Container.prototype.isBound = function (serviceIdentifier) {
    var bound = this._bindingDictionary.hasKey(serviceIdentifier);
    if (!bound && this.parent) {
      bound = this.parent.isBound(serviceIdentifier);
    }
    return bound;
  };
  Container.prototype.isBoundNamed = function (serviceIdentifier, named) {
    return this.isBoundTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
  };
  Container.prototype.isBoundTagged = function (serviceIdentifier, key, value) {
    var bound = false;
    if (this._bindingDictionary.hasKey(serviceIdentifier)) {
      var bindings = this._bindingDictionary.get(serviceIdentifier);
      var request_1 = planner_1.createMockRequest(this, serviceIdentifier, key, value);
      bound = bindings.some(function (b) {
        return b.constraint(request_1);
      });
    }
    if (!bound && this.parent) {
      bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
    }
    return bound;
  };
  Container.prototype.snapshot = function () {
    this._snapshots.push(container_snapshot_1.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware));
  };
  Container.prototype.restore = function () {
    var snapshot = this._snapshots.pop();
    if (snapshot === undefined) {
      throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);
    }
    this._bindingDictionary = snapshot.bindings;
    this._middleware = snapshot.middleware;
  };
  Container.prototype.createChild = function (containerOptions) {
    var child = new Container(containerOptions || this.options);
    child.parent = this;
    return child;
  };
  Container.prototype.applyMiddleware = function () {
    var middlewares = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      middlewares[_i] = arguments[_i];
    }
    var initial = this._middleware ? this._middleware : this._planAndResolve();
    this._middleware = middlewares.reduce(function (prev, curr) {
      return curr(prev);
    }, initial);
  };
  Container.prototype.applyCustomMetadataReader = function (metadataReader) {
    this._metadataReader = metadataReader;
  };
  Container.prototype.get = function (serviceIdentifier) {
    return this._get(false, false, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier);
  };
  Container.prototype.getTagged = function (serviceIdentifier, key, value) {
    return this._get(false, false, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier, key, value);
  };
  Container.prototype.getNamed = function (serviceIdentifier, named) {
    return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
  };
  Container.prototype.getAll = function (serviceIdentifier) {
    return this._get(true, true, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier);
  };
  Container.prototype.getAllTagged = function (serviceIdentifier, key, value) {
    return this._get(false, true, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier, key, value);
  };
  Container.prototype.getAllNamed = function (serviceIdentifier, named) {
    return this.getAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
  };
  Container.prototype.resolve = function (constructorFunction) {
    var tempContainer = this.createChild();
    tempContainer.bind(constructorFunction).toSelf();
    return tempContainer.get(constructorFunction);
  };
  Container.prototype._getContainerModuleHelpersFactory = function () {
    var _this = this;
    var setModuleId = function (bindingToSyntax, moduleId) {
      bindingToSyntax._binding.moduleId = moduleId;
    };
    var getBindFunction = function (moduleId) {
      return function (serviceIdentifier) {
        var _bind = _this.bind.bind(_this);
        var bindingToSyntax = _bind(serviceIdentifier);
        setModuleId(bindingToSyntax, moduleId);
        return bindingToSyntax;
      };
    };
    var getUnbindFunction = function (moduleId) {
      return function (serviceIdentifier) {
        var _unbind = _this.unbind.bind(_this);
        _unbind(serviceIdentifier);
      };
    };
    var getIsboundFunction = function (moduleId) {
      return function (serviceIdentifier) {
        var _isBound = _this.isBound.bind(_this);
        return _isBound(serviceIdentifier);
      };
    };
    var getRebindFunction = function (moduleId) {
      return function (serviceIdentifier) {
        var _rebind = _this.rebind.bind(_this);
        var bindingToSyntax = _rebind(serviceIdentifier);
        setModuleId(bindingToSyntax, moduleId);
        return bindingToSyntax;
      };
    };
    return function (mId) {
      return {
        bindFunction: getBindFunction(mId),
        isboundFunction: getIsboundFunction(mId),
        rebindFunction: getRebindFunction(mId),
        unbindFunction: getUnbindFunction(mId)
      };
    };
  };
  Container.prototype._get = function (avoidConstraints, isMultiInject, targetType, serviceIdentifier, key, value) {
    var result = null;
    var defaultArgs = {
      avoidConstraints: avoidConstraints,
      contextInterceptor: function (context) {
        return context;
      },
      isMultiInject: isMultiInject,
      key: key,
      serviceIdentifier: serviceIdentifier,
      targetType: targetType,
      value: value
    };
    if (this._middleware) {
      result = this._middleware(defaultArgs);
      if (result === undefined || result === null) {
        throw new Error(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);
      }
    } else {
      result = this._planAndResolve()(defaultArgs);
    }
    return result;
  };
  Container.prototype._planAndResolve = function () {
    var _this = this;
    return function (args) {
      var context = planner_1.plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
      context = args.contextInterceptor(context);
      var result = resolver_1.resolve(context);
      return result;
    };
  };
  return Container;
}();
exports.Container = Container;

/***/ }),

/***/ 70154:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Target = void 0;
var METADATA_KEY = __webpack_require__(94725);
var id_1 = __webpack_require__(78418);
var metadata_1 = __webpack_require__(88390);
var queryable_string_1 = __webpack_require__(34131);
var Target = function () {
  function Target(type, name, serviceIdentifier, namedOrTagged) {
    this.id = id_1.id();
    this.type = type;
    this.serviceIdentifier = serviceIdentifier;
    this.name = new queryable_string_1.QueryableString(name || "");
    this.metadata = new Array();
    var metadataItem = null;
    if (typeof namedOrTagged === "string") {
      metadataItem = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, namedOrTagged);
    } else if (namedOrTagged instanceof metadata_1.Metadata) {
      metadataItem = namedOrTagged;
    }
    if (metadataItem !== null) {
      this.metadata.push(metadataItem);
    }
  }
  Target.prototype.hasTag = function (key) {
    for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
      var m = _a[_i];
      if (m.key === key) {
        return true;
      }
    }
    return false;
  };
  Target.prototype.isArray = function () {
    return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);
  };
  Target.prototype.matchesArray = function (name) {
    return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);
  };
  Target.prototype.isNamed = function () {
    return this.hasTag(METADATA_KEY.NAMED_TAG);
  };
  Target.prototype.isTagged = function () {
    return this.metadata.some(function (m) {
      return m.key !== METADATA_KEY.INJECT_TAG && m.key !== METADATA_KEY.MULTI_INJECT_TAG && m.key !== METADATA_KEY.NAME_TAG && m.key !== METADATA_KEY.UNMANAGED_TAG && m.key !== METADATA_KEY.NAMED_TAG;
    });
  };
  Target.prototype.isOptional = function () {
    return this.matchesTag(METADATA_KEY.OPTIONAL_TAG)(true);
  };
  Target.prototype.getNamedTag = function () {
    if (this.isNamed()) {
      return this.metadata.filter(function (m) {
        return m.key === METADATA_KEY.NAMED_TAG;
      })[0];
    }
    return null;
  };
  Target.prototype.getCustomTags = function () {
    if (this.isTagged()) {
      return this.metadata.filter(function (m) {
        return m.key !== METADATA_KEY.INJECT_TAG && m.key !== METADATA_KEY.MULTI_INJECT_TAG && m.key !== METADATA_KEY.NAME_TAG && m.key !== METADATA_KEY.UNMANAGED_TAG && m.key !== METADATA_KEY.NAMED_TAG;
      });
    }
    return null;
  };
  Target.prototype.matchesNamedTag = function (name) {
    return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);
  };
  Target.prototype.matchesTag = function (key) {
    var _this = this;
    return function (value) {
      for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
        var m = _a[_i];
        if (m.key === key && m.value === value) {
          return true;
        }
      }
      return false;
    };
  };
  return Target;
}();
exports.Target = Target;

/***/ }),

/***/ 73743:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: () => (/* binding */ DropdownType)
/* harmony export */ });
/* unused harmony export CustomDropdownModel */
class CustomDropdownModel {
}
var DropdownType;
(function (DropdownType) {
    DropdownType[DropdownType["Pagination"] = 0] = "Pagination";
    DropdownType[DropdownType["SearchValet"] = 1] = "SearchValet";
    DropdownType[DropdownType["SearchSort"] = 2] = "SearchSort";
})(DropdownType || (DropdownType = {}));


/***/ }),

/***/ 74208:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = function () {
  if (typeof Map !== 'undefined') {
    return Map;
  }
  /**
   * Returns index in provided array that matches the specified key.
   *
   * @param {Array<Array>} arr
   * @param {*} key
   * @returns {number}
   */
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function (entry, index) {
      if (entry[0] === key) {
        result = index;
        return true;
      }
      return false;
    });
    return result;
  }
  return /** @class */function () {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      /**
       * @returns {boolean}
       */
      get: function () {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    /**
     * @param {*} key
     * @returns {*}
     */
    class_1.prototype.get = function (key) {
      var index = getIndex(this.__entries__, key);
      var entry = this.__entries__[index];
      return entry && entry[1];
    };
    /**
     * @param {*} key
     * @param {*} value
     * @returns {void}
     */
    class_1.prototype.set = function (key, value) {
      var index = getIndex(this.__entries__, key);
      if (~index) {
        this.__entries__[index][1] = value;
      } else {
        this.__entries__.push([key, value]);
      }
    };
    /**
     * @param {*} key
     * @returns {void}
     */
    class_1.prototype.delete = function (key) {
      var entries = this.__entries__;
      var index = getIndex(entries, key);
      if (~index) {
        entries.splice(index, 1);
      }
    };
    /**
     * @param {*} key
     * @returns {void}
     */
    class_1.prototype.has = function (key) {
      return !!~getIndex(this.__entries__, key);
    };
    /**
     * @returns {void}
     */
    class_1.prototype.clear = function () {
      this.__entries__.splice(0);
    };
    /**
     * @param {Function} callback
     * @param {*} [ctx=null]
     * @returns {void}
     */
    class_1.prototype.forEach = function (callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = function () {
  if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
    return __webpack_require__.g;
  }
  if (typeof self !== 'undefined' && self.Math === Math) {
    return self;
  }
  if (typeof window !== 'undefined' && window.Math === Math) {
    return window;
  }
  // eslint-disable-next-line no-new-func
  return Function('return this')();
}();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = function () {
  if (typeof requestAnimationFrame === 'function') {
    // It's required to use a bounded function because IE sometimes throws
    // an "Invalid calling object" error if rAF is invoked without the global
    // object on the left hand side.
    return requestAnimationFrame.bind(global$1);
  }
  return function (callback) {
    return setTimeout(function () {
      return callback(Date.now());
    }, 1000 / 60);
  };
}();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle(callback, delay) {
  var leadingCall = false,
    trailingCall = false,
    lastCallTime = 0;
  /**
   * Invokes the original callback function and schedules new invocation if
   * the "proxy" was called during current request.
   *
   * @returns {void}
   */
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  /**
   * Callback invoked after the specified delay. It will further postpone
   * invocation of the original function delegating it to the
   * requestAnimationFrame.
   *
   * @returns {void}
   */
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  /**
   * Schedules invocation of the original function.
   *
   * @returns {void}
   */
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      // Reject immediately following calls.
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      // Schedule new call to be in invoked when the pending one is resolved.
      // This is important for "transitions" which never actually start
      // immediately so there is a chance that we might miss one if change
      // happens amids the pending invocation.
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */function () {
  /**
   * Creates a new instance of ResizeObserverController.
   *
   * @private
   */
  function ResizeObserverController() {
    /**
     * Indicates whether DOM listeners have been added.
     *
     * @private {boolean}
     */
    this.connected_ = false;
    /**
     * Tells that controller has subscribed for Mutation Events.
     *
     * @private {boolean}
     */
    this.mutationEventsAdded_ = false;
    /**
     * Keeps reference to the instance of MutationObserver.
     *
     * @private {MutationObserver}
     */
    this.mutationsObserver_ = null;
    /**
     * A list of connected observers.
     *
     * @private {Array<ResizeObserverSPI>}
     */
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  /**
   * Adds observer to observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be added.
   * @returns {void}
   */
  ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    // Add listeners if they haven't been added yet.
    if (!this.connected_) {
      this.connect_();
    }
  };
  /**
   * Removes observer from observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be removed.
   * @returns {void}
   */
  ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer);
    // Remove observer if it's present in registry.
    if (~index) {
      observers.splice(index, 1);
    }
    // Remove listeners if controller has no connected observers.
    if (!observers.length && this.connected_) {
      this.disconnect_();
    }
  };
  /**
   * Invokes the update of observers. It will continue running updates insofar
   * it detects changes.
   *
   * @returns {void}
   */
  ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_();
    // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.
    if (changesDetected) {
      this.refresh();
    }
  };
  /**
   * Updates every observer from observers list and notifies them of queued
   * entries.
   *
   * @private
   * @returns {boolean} Returns "true" if any observer has detected changes in
   *      dimensions of it's elements.
   */
  ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.
    activeObservers.forEach(function (observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  /**
   * Initializes DOM listeners.
   *
   * @private
   * @returns {void}
   */
  ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
      return;
    }
    // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.
    document.addEventListener('transitionend', this.onTransitionEnd_);
    window.addEventListener('resize', this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener('DOMSubtreeModified', this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  /**
   * Removes DOM listeners.
   *
   * @private
   * @returns {void}
   */
  ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener('DOMSubtreeModified', this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  /**
   * "Transitionend" event handler.
   *
   * @private
   * @param {TransitionEvent} event
   * @returns {void}
   */
  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
    var _b = _a.propertyName,
      propertyName = _b === void 0 ? '' : _b;
    // Detect whether transition may affect dimensions of an element.
    var isReflowProperty = transitionKeys.some(function (key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  /**
   * Returns instance of the ResizeObserverController.
   *
   * @returns {ResizeObserverController}
   */
  ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController();
    }
    return this.instance_;
  };
  /**
   * Holds reference to the controller's instance.
   *
   * @private {ResizeObserverController}
   */
  ResizeObserverController.instance_ = null;
  return ResizeObserverController;
}();

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = function (target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = function (target) {
  // Assume that the element is an instance of Node, which means that it
  // has the "ownerDocument" property from which we can retrieve a
  // corresponding global object.
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  // Return the local global object if it's not possible extract one from
  // provided element.
  return ownerGlobal || global$1;
};

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
  return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function (size, position) {
    var value = styles['border-' + position + '-width'];
    return size + toFloat(value);
  }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
  var positions = ['top', 'right', 'bottom', 'left'];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles['padding-' + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
  // Client width & height properties can't be
  // used exclusively as they provide rounded values.
  var clientWidth = target.clientWidth,
    clientHeight = target.clientHeight;
  // By this condition we can catch all non-replaced inline, hidden and
  // detached elements. Though elements with width & height properties less
  // than 0.5 will be discarded as well.
  //
  // Without it we would need to implement separate methods for each of
  // those cases and it's not possible to perform a precise and performance
  // effective test for hidden elements. E.g. even jQuery's ':visible' filter
  // gives wrong results for elements with width & height less than 0.5.
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  // Computed styles of width & height are being used because they are the
  // only dimensions available to JS that contain non-rounded values. It could
  // be possible to utilize the getBoundingClientRect if only it's data wasn't
  // affected by CSS transformations let alone paddings, borders and scroll bars.
  var width = toFloat(styles.width),
    height = toFloat(styles.height);
  // Width & height include paddings and borders when the 'border-box' box
  // model is applied (except for IE).
  if (styles.boxSizing === 'border-box') {
    // Following conditions are required to handle Internet Explorer which
    // doesn't include paddings and borders to computed CSS dimensions.
    //
    // We can say that if CSS dimensions + paddings are equal to the "client"
    // properties then it's either IE, and thus we don't need to subtract
    // anything, or an element merely doesn't have paddings/borders styles.
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, 'left', 'right') + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
    }
  }
  // Following steps can't be applied to the document's root element as its
  // client[Width/Height] properties represent viewport area of the window.
  // Besides, it's as well not necessary as the <html> itself neither has
  // rendered scroll bars nor it can be clipped.
  if (!isDocumentElement(target)) {
    // In some browsers (only in Firefox, actually) CSS width & height
    // include scroll bars size which can be removed at this step as scroll
    // bars are the only difference between rounded dimensions + paddings
    // and "client" properties, though that is not always true in Chrome.
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    // Chrome has a rather weird rounding of "client" properties.
    // E.g. for an element with content width of 314.2px it sometimes gives
    // the client width of 315px and for the width of 314.7px it may give
    // 314px. And it doesn't happen all the time. So just ignore this delta
    // as a non-relevant.
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = function () {
  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
  // interface.
  if (typeof SVGGraphicsElement !== 'undefined') {
    return function (target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  // If it's so, then check that element is at least an instance of the
  // SVGElement and that it has the "getBBox" method.
  // eslint-disable-next-line no-extra-parens
  return function (target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
  };
}();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
  var x = _a.x,
    y = _a.y,
    width = _a.width,
    height = _a.height;
  // If DOMRectReadOnly is available use it as a prototype for the rectangle.
  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  // Rectangle's properties are not writable and non-enumerable.
  defineConfigurable(rect, {
    x: x,
    y: y,
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */function () {
  /**
   * Creates an instance of ResizeObservation.
   *
   * @param {Element} target - Element to be observed.
   */
  function ResizeObservation(target) {
    /**
     * Broadcasted width of content rectangle.
     *
     * @type {number}
     */
    this.broadcastWidth = 0;
    /**
     * Broadcasted height of content rectangle.
     *
     * @type {number}
     */
    this.broadcastHeight = 0;
    /**
     * Reference to the last observed content rectangle.
     *
     * @private {DOMRectInit}
     */
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  /**
   * Updates content rectangle and tells whether it's width or height properties
   * have changed since the last broadcast.
   *
   * @returns {boolean}
   */
  ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  /**
   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
   * from the corresponding properties of the last observed content rectangle.
   *
   * @returns {DOMRectInit} Last observed content rectangle.
   */
  ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation;
}();
var ResizeObserverEntry = /** @class */function () {
  /**
   * Creates an instance of ResizeObserverEntry.
   *
   * @param {Element} target - Element that is being observed.
   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
   */
  function ResizeObserverEntry(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.
    defineConfigurable(this, {
      target: target,
      contentRect: contentRect
    });
  }
  return ResizeObserverEntry;
}();
var ResizeObserverSPI = /** @class */function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback function that is invoked
   *      when one of the observed elements changes it's content dimensions.
   * @param {ResizeObserverController} controller - Controller instance which
   *      is responsible for the updates of observer.
   * @param {ResizeObserver} callbackCtx - Reference to the public
   *      ResizeObserver instance which will be passed to callback function.
   */
  function ResizeObserverSPI(callback, controller, callbackCtx) {
    /**
     * Collection of resize observations that have detected changes in dimensions
     * of elements.
     *
     * @private {Array<ResizeObservation>}
     */
    this.activeObservations_ = [];
    /**
     * Registry of the ResizeObservation instances.
     *
     * @private {Map<Element, ResizeObservation>}
     */
    this.observations_ = new MapShim();
    if (typeof callback !== 'function') {
      throw new TypeError('The callback provided as parameter 1 is not a function.');
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  /**
   * Starts observing provided element.
   *
   * @param {Element} target - Element to be observed.
   * @returns {void}
   */
  ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }
    // Do nothing if current environment doesn't have the Element interface.
    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    // Do nothing if element is already being observed.
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    // Force the update of observations.
    this.controller_.refresh();
  };
  /**
   * Stops observing provided element.
   *
   * @param {Element} target - Element to stop observing.
   * @returns {void}
   */
  ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }
    // Do nothing if current environment doesn't have the Element interface.
    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    // Do nothing if element is not being observed.
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  /**
   * Stops observing all elements.
   *
   * @returns {void}
   */
  ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  /**
   * Collects observation instances the associated element of which has changed
   * it's content rectangle.
   *
   * @returns {void}
   */
  ResizeObserverSPI.prototype.gatherActive = function () {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function (observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  /**
   * Invokes initial callback function with a list of ResizeObserverEntry
   * instances collected from active resize observations.
   *
   * @returns {void}
   */
  ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    // Create ResizeObserverEntry instance for every active observation.
    var entries = this.activeObservations_.map(function (observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  /**
   * Clears the collection of active observations.
   *
   * @returns {void}
   */
  ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
  };
  /**
   * Tells whether observer has active observations.
   *
   * @returns {boolean}
   */
  ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI;
}();

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback that is invoked when
   *      dimensions of the observed elements change.
   */
  function ResizeObserver(callback) {
    if (!(this instanceof ResizeObserver)) {
      throw new TypeError('Cannot call a class as a function.');
    }
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver;
}();
// Expose public methods of ResizeObserver.
['observe', 'unobserve', 'disconnect'].forEach(function (method) {
  ResizeObserver.prototype[method] = function () {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function () {
  // Export existing implementation if available.
  if (typeof global$1.ResizeObserver !== 'undefined') {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);

/***/ }),

/***/ 74529:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gH: () => (/* binding */ ToggleService),
/* harmony export */   lM: () => (/* binding */ Toggle)
/* harmony export */ });
/* unused harmony export ExperimentToggle */
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90260);
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45644);
/* harmony import */ var _utilities_urlHelpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7324);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



let ToggleService = class ToggleService {
    constructor(dataFetcher) {
        this.toggles = null;
        this.storeToggles = (data, dealerId) => {
            const dataString = JSON.stringify(data);
            this.setSessionStorage(this.getStorageLocation(dealerId), dataString);
        };
        // This pulls all of the Toggles from the back-end.
        // Note: If a toggle is not found then it it will return false, so if you want to allow a
        //  queryString parm to override the toggles, you need to call getExperiment() instead
        //  of getToggleStatus()
        this.getToggleStatus = (toggle) => {
            if (!this.toggles) {
                return false;
            }
            //Experiment toggles are not stored in session storage but will override any other toggle
            //  so check this first before looking in session storage
            const experimentToggle = this.getExperimentToggle(toggle);
            if (typeof experimentToggle === 'boolean') {
                return experimentToggle;
            }
            if (!this.toggles) {
                return false;
            }
            let storedToggleValue = this.toggles[toggle];
            if (storedToggleValue === true) {
                return true;
            }
            return false;
        };
        this.dataFetcher = dataFetcher;
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.dataFetcher.fetch();
            this.toggles = data;
            this.storeToggles(data, window.DlronGlobal_DealerId);
        });
    }
    getStorageLocation(dealerId) {
        return `sessionToggles_${dealerId}`;
    }
    setSessionStorage(storageLocation, response) {
        if (response !== null) {
            sessionStorage.setItem(storageLocation, response);
        }
        else {
            sessionStorage.removeItem(storageLocation);
        }
    }
    getQueryStringParam(queryString, paramName) {
        const params = _utilities_urlHelpers__WEBPACK_IMPORTED_MODULE_2__/* .UrlHelpers */ .b.queryStringToArray(queryString);
        // Iterate over all the parameter keys
        for (const { key, value } of params) {
            if (key.toLowerCase() === paramName.toLowerCase()) {
                // Return the value of the matching parameter
                return value;
            }
        }
        // Parameter not found
        return null;
    }
    //NOTE: For experiments to work from queryString you need to manually add them to this function
    getExperimentToggle(toggle) {
        let experimentResult = null;
        switch (toggle) {
            case Toggle.AltDealerIdProtection_DO46595:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.AltDealerIdProtection_DO46595);
                break;
            case Toggle.BannersConfigUpdate:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.BannersConfigUpdate);
                break;
            case Toggle.DO35873:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.DO35873);
                break;
            case Toggle.DO37371:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.DO37371);
                break;
            case Toggle.DO45165_InitQuickPass2:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.DO45165_InitQuickPass2);
                break;
            case Toggle.DO47560_DoTaggingProperty:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.DO47560_DoTaggingProperty);
                break;
            case Toggle.ExposePriceLibrary_DO48604:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.ExposePriceLibrary_DO48604);
                break;
            case Toggle.EmailRefactor:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.EmailRefactor);
                break;
            case Toggle.HideZeroCountFilters:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.HideZeroCountFilters);
                break;
            case Toggle.ItemTypeTagging_ADJ446:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.ItemTypeTagging_ADJ446);
                break;
            case Toggle.LS2531:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.LS2531);
                break;
            case Toggle.MobileFilterOptimization_DO46753:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.MobileFilterOptimization_DO46753);
                break;
            case Toggle.MoveSpecialOfferPriceDrop_DO46349:
                experimentResult = this.getQueryStringParam(globalThis.location.search, ExperimentToggle.MoveSpecialOfferPriceDrop_DO46349);
                break;
            case Toggle.NextgenDomUpdate_DO47714:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.NextgenDomUpdate_DO47714);
                break;
            case Toggle.ShowMileageWhenZeroMiles_OEM12049:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.ShowMileageWhenZeroMiles_OEM12049);
                break;
            case Toggle.VehicleCardAlignment_DO48222:
                experimentResult = this.getQueryStringParam(window.location.search, ExperimentToggle.VehicleCardAlignment_DO48222);
                break;
        }
        switch (experimentResult) {
            case "on": return true;
            case "off": return false;
            default: return null;
        }
    }
};
ToggleService = __decorate([
    (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .injectable */ ._G)(),
    __param(0, (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(_types_types__WEBPACK_IMPORTED_MODULE_1__/* .TYPES */ .Q.IToggleFetcher)),
    __metadata("design:paramtypes", [Object])
], ToggleService);

//NOTE: Update these when adding new toggles that apply to client side features
//       that need to know about them conversions
var Toggle;
(function (Toggle) {
    Toggle["AltDealerIdProtection_DO46595"] = "AltDealerIdProtection_DO46595";
    Toggle["BannersConfigUpdate"] = "BannersConfigUpdate";
    Toggle["DO35873"] = "DO35873";
    Toggle["DO37371"] = "DO37371";
    Toggle["DO45165_InitQuickPass2"] = "DO45165_InitQuickPass2";
    Toggle["DO47560_DoTaggingProperty"] = "DO47560_DoTaggingProperty";
    Toggle["EmailRefactor"] = "EmailRefactor";
    Toggle["ExposePriceLibrary_DO48604"] = "ExposePriceLibrary_DO48604";
    Toggle["HideZeroCountFilters"] = "HideZeroCountFilters";
    Toggle["ItemTypeTagging_ADJ446"] = "ItemTypeTagging_ADJ446";
    Toggle["LS2531"] = "LS2531";
    Toggle["MobileFilterOptimization_DO46753"] = "MobileFilterOptimization_DO46753";
    Toggle["MoveSpecialOfferPriceDrop_DO46349"] = "MoveSpecialOfferPriceDrop_DO46349";
    Toggle["NextgenDomUpdate_DO47714"] = "NextgenDomUpdate_DO47714";
    Toggle["VehicleCardAlignment_DO48222"] = "VehicleCardAlignment_DO48222";
    Toggle["ShowMileageWhenZeroMiles_OEM12049"] = "ShowMileageWhenZeroMiles_OEM12049";
})(Toggle || (Toggle = {}));
var ExperimentToggle;
(function (ExperimentToggle) {
    ExperimentToggle["AltDealerIdProtection_DO46595"] = "AltDealerIdProtection_DO46595";
    ExperimentToggle["BannersConfigUpdate"] = "BannersConfigUpdate";
    ExperimentToggle["DO35873"] = "DO35873";
    ExperimentToggle["DO37371"] = "DO37371";
    ExperimentToggle["DO45165_InitQuickPass2"] = "DO45165_InitQuickPass2";
    ExperimentToggle["DO47560_DoTaggingProperty"] = "DO47560_DoTaggingProperty";
    ExperimentToggle["EmailRefactor"] = "EmailRefactor";
    ExperimentToggle["ExposePriceLibrary_DO48604"] = "ExposePriceLibrary_DO48604";
    ExperimentToggle["HideZeroCountFilters"] = "HideZeroCountFilters";
    ExperimentToggle["ItemTypeTagging_ADJ446"] = "ItemTypeTagging_ADJ446";
    ExperimentToggle["LS2531"] = "LS2531";
    ExperimentToggle["MobileFilterOptimization_DO46753"] = "MobileFilterOptimization_DO46753";
    ExperimentToggle["MoveSpecialOfferPriceDrop_DO46349"] = "MoveSpecialOfferPriceDrop_DO46349";
    ExperimentToggle["NextgenDomUpdate_DO47714"] = "NextgenDomUpdate_DO47714";
    ExperimentToggle["VehicleCardAlignment_DO48222"] = "VehicleCardAlignment_DO48222";
    ExperimentToggle["ShowMileageWhenZeroMiles_OEM12049"] = "ShowMileageWhenZeroMiles_OEM12049";
})(ExperimentToggle || (ExperimentToggle = {}));


/***/ }),

/***/ 74533:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BindingWhenSyntax = void 0;
var binding_on_syntax_1 = __webpack_require__(15078);
var constraint_helpers_1 = __webpack_require__(23884);
var BindingWhenSyntax = function () {
  function BindingWhenSyntax(binding) {
    this._binding = binding;
  }
  BindingWhenSyntax.prototype.when = function (constraint) {
    this._binding.constraint = constraint;
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenTargetNamed = function (name) {
    this._binding.constraint = constraint_helpers_1.namedConstraint(name);
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenTargetIsDefault = function () {
    this._binding.constraint = function (request) {
      var targetIsDefault = request.target !== null && !request.target.isNamed() && !request.target.isTagged();
      return targetIsDefault;
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenTargetTagged = function (tag, value) {
    this._binding.constraint = constraint_helpers_1.taggedConstraint(tag)(value);
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenInjectedInto = function (parent) {
    this._binding.constraint = function (request) {
      return constraint_helpers_1.typeConstraint(parent)(request.parentRequest);
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenParentNamed = function (name) {
    this._binding.constraint = function (request) {
      return constraint_helpers_1.namedConstraint(name)(request.parentRequest);
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenParentTagged = function (tag, value) {
    this._binding.constraint = function (request) {
      return constraint_helpers_1.taggedConstraint(tag)(value)(request.parentRequest);
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
    this._binding.constraint = function (request) {
      return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenNoAncestorIs = function (ancestor) {
    this._binding.constraint = function (request) {
      return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenAnyAncestorNamed = function (name) {
    this._binding.constraint = function (request) {
      return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenNoAncestorNamed = function (name) {
    this._binding.constraint = function (request) {
      return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
    this._binding.constraint = function (request) {
      return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
    this._binding.constraint = function (request) {
      return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
    this._binding.constraint = function (request) {
      return constraint_helpers_1.traverseAncerstors(request, constraint);
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax.prototype.whenNoAncestorMatches = function (constraint) {
    this._binding.constraint = function (request) {
      return !constraint_helpers_1.traverseAncerstors(request, constraint);
    };
    return new binding_on_syntax_1.BindingOnSyntax(this._binding);
  };
  return BindingWhenSyntax;
}();
exports.BindingWhenSyntax = BindingWhenSyntax;

/***/ }),

/***/ 78418:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.id = void 0;
var idCounter = 0;
function id() {
  return idCounter++;
}
exports.id = id;

/***/ }),

/***/ 78528:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Context = void 0;
var id_1 = __webpack_require__(78418);
var Context = function () {
  function Context(container) {
    this.id = id_1.id();
    this.container = container;
  }
  Context.prototype.addPlan = function (plan) {
    this.plan = plan;
  };
  Context.prototype.setCurrentRequest = function (currentRequest) {
    this.currentRequest = currentRequest;
  };
  return Context;
}();
exports.Context = Context;

/***/ }),

/***/ 81719:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ PaginationQueryParams)
/* harmony export */ });
/* unused harmony export PagingModel */

class PagingModel {
    constructor() {
        this.NumberOfVehiclesToShowModel = {};
        this.PaginationDataModel = new PaginationDataModel();
    }
}
var PaginationQueryParams;
(function (PaginationQueryParams) {
    PaginationQueryParams["PageSize"] = "pn";
    PaginationQueryParams["PageNumber"] = "pt";
})(PaginationQueryParams || (PaginationQueryParams = {}));


/***/ }),

/***/ 82491:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ SrpLayoutType)
/* harmony export */ });
var SrpLayoutType;
(function (SrpLayoutType) {
    SrpLayoutType[SrpLayoutType["List"] = 0] = "List";
    SrpLayoutType[SrpLayoutType["Grid"] = 1] = "Grid";
})(SrpLayoutType || (SrpLayoutType = {}));


/***/ }),

/***/ 82781:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ JQueryHelper)
/* harmony export */ });
/*
*Any changes to this file will need to be made to the legacy file as well.
*/
class JQueryHelper {
    static SafeApplyPopover(element, options) {
        // Ensure jQuery and popover is loaded before running popover
        if (typeof jQuery != "undefined" && typeof jQuery.fn['popover'] === "function") {
            return jQuery(element).popover(options);
        }
        else {
            console.warn("jQuery popover is not defined. This may be a third party script issue");
            return jQuery();
        }
    }
    static SafeApplyTooltip(element) {
        // Ensure jQuery and tooltip is loaded before running tooltip
        if (typeof jQuery != "undefined" && typeof jQuery.fn['tooltip'] === "function") {
            const $element = jQuery(element);
            $element.tooltip();
            return;
        }
        else {
            console.warn("jQuery tooltip is not defined. This may be a third party script issue");
            return;
        }
    }
    static SafeApplyCollapse(element, options) {
        // Ensure jQuery and collapse is loaded before running collapse
        if (typeof jQuery != "undefined" && typeof jQuery.fn['collapse'] === "function") {
            const $element = jQuery(element);
            $element.collapse(options);
            return;
        }
        else {
            console.warn("jQuery collapse is not defined. This may be a third party script issue");
            return;
        }
    }
}


/***/ }),

/***/ 83925:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ EvnVideoPlayer)
/* harmony export */ });
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90260);
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45644);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


let EvnVideoPlayer = class EvnVideoPlayer {
    constructor(toggleService) {
        this.toggleService = toggleService;
    }
    /**
     * @param eventType The event to listen for to initialize the EVN video player.
     */
    initialize(eventType) {
        const domContentLoaded = 'DOMContentLoaded';
        const loading = 'loading';
        if ((eventType === domContentLoaded && document.readyState === loading)
            || eventType !== domContentLoaded) {
            document.addEventListener(eventType, () => {
                this.initEventListenersAndObservers();
            });
            return;
        }
        this.initEventListenersAndObservers();
    }
    initEventListenersAndObservers() {
        this.addLoadEvnVideoPlayerEvent();
        this.initInlineEvnVideo();
    }
    //Ford EVN video player inline video initialization.
    addLoadEvnVideoPlayerEvent() {
        const evnVideoPlayerModal = document.getElementById("evnVideoPlayerModal");
        if (evnVideoPlayerModal) {
            $('#evnVideoPlayerModal').on('shown.bs.modal', function (event) {
                //@ts-ignore
                const element = event.relatedTarget;
                if (element.dataset.videoId) {
                    window.evnVideoPlayer.initialize({
                        selector: "#evn-video-player-container",
                        videoId: element.dataset.videoId,
                        embed: "first",
                        videoJsPlayerOptions: {
                            autoplay: 'muted',
                            loop: true
                        }
                    });
                }
            });
            const observer = new MutationObserver(() => {
                if (evnVideoPlayerModal.style.display === "none") {
                    Array.from(window.evnVideoPlayer._players).forEach(function (player) {
                        if (!player.videoPlayer.isDisposed_) {
                            player.videoPlayer.dispose();
                        }
                    });
                }
            });
            const config = { attributes: true, attributeFilter: ['style'] };
            observer.observe(evnVideoPlayerModal, config);
        }
    }
    /**
     * This is currently only used on the VDP behind the EnableCosmosVdpGalleryMod toggle
     */
    initInlineEvnVideo() {
        const videoContainerElem = document.querySelector("#do-video-container[data-video-player-type='evn']");
        if (videoContainerElem && videoContainerElem.dataset.videoFeedUrl) {
            let options = {
                root: document.querySelector(".hero-carousel__items"),
                threshold: 0.9,
            };
            const observer = new IntersectionObserver((entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        window.evnVideoPlayer.initialize({
                            selector: "#do-video-container",
                            videoId: videoContainerElem.dataset.videoFeedUrl,
                            embed: "first",
                            videoJsPlayerOptions: {
                                autoplay: 'muted',
                                loop: true
                            }
                        });
                        observer.disconnect();
                    }
                });
            }, options);
            observer.observe(videoContainerElem);
        }
    }
};
EvnVideoPlayer = __decorate([
    (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .injectable */ ._G)(),
    __param(0, (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(_types_types__WEBPACK_IMPORTED_MODULE_1__/* .TYPES */ .Q.IToggleService)),
    __metadata("design:paramtypes", [Object])
], EvnVideoPlayer);



/***/ }),

/***/ 84387:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getBindingDictionary = exports.createMockRequest = exports.plan = void 0;
var binding_count_1 = __webpack_require__(64081);
var ERROR_MSGS = __webpack_require__(27718);
var literal_types_1 = __webpack_require__(27802);
var METADATA_KEY = __webpack_require__(94725);
var exceptions_1 = __webpack_require__(98229);
var serialization_1 = __webpack_require__(57911);
var context_1 = __webpack_require__(78528);
var metadata_1 = __webpack_require__(88390);
var plan_1 = __webpack_require__(13104);
var reflection_utils_1 = __webpack_require__(59592);
var request_1 = __webpack_require__(39034);
var target_1 = __webpack_require__(70154);
function getBindingDictionary(cntnr) {
  return cntnr._bindingDictionary;
}
exports.getBindingDictionary = getBindingDictionary;
function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
  var metadataKey = isMultiInject ? METADATA_KEY.MULTI_INJECT_TAG : METADATA_KEY.INJECT_TAG;
  var injectMetadata = new metadata_1.Metadata(metadataKey, serviceIdentifier);
  var target = new target_1.Target(targetType, name, serviceIdentifier, injectMetadata);
  if (key !== undefined) {
    var tagMetadata = new metadata_1.Metadata(key, value);
    target.metadata.push(tagMetadata);
  }
  return target;
}
function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
  var bindings = getBindings(context.container, target.serviceIdentifier);
  var activeBindings = [];
  if (bindings.length === binding_count_1.BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
    context.container.bind(target.serviceIdentifier).toSelf();
    bindings = getBindings(context.container, target.serviceIdentifier);
  }
  if (!avoidConstraints) {
    activeBindings = bindings.filter(function (binding) {
      var request = new request_1.Request(binding.serviceIdentifier, context, parentRequest, binding, target);
      return binding.constraint(request);
    });
  } else {
    activeBindings = bindings;
  }
  _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
  return activeBindings;
}
function _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {
  switch (bindings.length) {
    case binding_count_1.BindingCount.NoBindingsAvailable:
      if (target.isOptional()) {
        return bindings;
      } else {
        var serviceIdentifierString = serialization_1.getServiceIdentifierAsString(serviceIdentifier);
        var msg = ERROR_MSGS.NOT_REGISTERED;
        msg += serialization_1.listMetadataForTarget(serviceIdentifierString, target);
        msg += serialization_1.listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
        throw new Error(msg);
      }
    case binding_count_1.BindingCount.OnlyOneBindingAvailable:
      if (!target.isArray()) {
        return bindings;
      }
    case binding_count_1.BindingCount.MultipleBindingsAvailable:
    default:
      if (!target.isArray()) {
        var serviceIdentifierString = serialization_1.getServiceIdentifierAsString(serviceIdentifier);
        var msg = ERROR_MSGS.AMBIGUOUS_MATCH + " " + serviceIdentifierString;
        msg += serialization_1.listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
        throw new Error(msg);
      } else {
        return bindings;
      }
  }
}
function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
  var activeBindings;
  var childRequest;
  if (parentRequest === null) {
    activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
    childRequest = new request_1.Request(serviceIdentifier, context, null, activeBindings, target);
    var thePlan = new plan_1.Plan(context, childRequest);
    context.addPlan(thePlan);
  } else {
    activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
    childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
  }
  activeBindings.forEach(function (binding) {
    var subChildRequest = null;
    if (target.isArray()) {
      subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
    } else {
      if (binding.cache) {
        return;
      }
      subChildRequest = childRequest;
    }
    if (binding.type === literal_types_1.BindingTypeEnum.Instance && binding.implementationType !== null) {
      var dependencies = reflection_utils_1.getDependencies(metadataReader, binding.implementationType);
      if (!context.container.options.skipBaseClassChecks) {
        var baseClassDependencyCount = reflection_utils_1.getBaseClassDependencyCount(metadataReader, binding.implementationType);
        if (dependencies.length < baseClassDependencyCount) {
          var error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH(reflection_utils_1.getFunctionName(binding.implementationType));
          throw new Error(error);
        }
      }
      dependencies.forEach(function (dependency) {
        _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
      });
    }
  });
}
function getBindings(container, serviceIdentifier) {
  var bindings = [];
  var bindingDictionary = getBindingDictionary(container);
  if (bindingDictionary.hasKey(serviceIdentifier)) {
    bindings = bindingDictionary.get(serviceIdentifier);
  } else if (container.parent !== null) {
    bindings = getBindings(container.parent, serviceIdentifier);
  }
  return bindings;
}
function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
  if (avoidConstraints === void 0) {
    avoidConstraints = false;
  }
  var context = new context_1.Context(container);
  var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);
  try {
    _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
    return context;
  } catch (error) {
    if (exceptions_1.isStackOverflowExeption(error)) {
      if (context.plan) {
        serialization_1.circularDependencyToException(context.plan.rootRequest);
      }
    }
    throw error;
  }
}
exports.plan = plan;
function createMockRequest(container, serviceIdentifier, key, value) {
  var target = new target_1.Target(literal_types_1.TargetTypeEnum.Variable, "", serviceIdentifier, new metadata_1.Metadata(key, value));
  var context = new context_1.Context(container);
  var request = new request_1.Request(serviceIdentifier, context, null, [], target);
  return request;
}
exports.createMockRequest = createMockRequest;

/***/ }),

/***/ 88066:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  a: () => (/* binding */ VehicleCardWasabi)
});

// EXTERNAL MODULE: ./node_modules/inversify/lib/inversify.js
var inversify = __webpack_require__(90260);
// EXTERNAL MODULE: ./src/types/types.ts
var types = __webpack_require__(45644);
// EXTERNAL MODULE: ./src/components/vehicleImageCarousel/vehicleImageCarousel.ts
var vehicleImageCarousel = __webpack_require__(34567);
;// ./src/utilities/dynamicImportsUtility.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Import and instantiate a class when element is scrolled into the frame.
 *
 * @param {Function} importFunction - the dynamic import function used to import the class file. This should look like import(\/* webpackChunkName: "className" *\/ 'path/to/class/file').
 * @param {ElementCollection} observedElements - a DOM element or list of DOM elements for the IntersectionObserver to observe.
 * @param {boolean} shouldInstantiate - whether or not the imported module should be newed up.
 * @param {IntersectionObserverInit} observerOptions - options to pass to the IntersectionObserver constructor
 * @param {...any} otherConstructorArgs - any other arguments to pass to the constructor.
 */
function importClassOnScroll(importFunction, observedElements, shouldInstantiate, observerOptions, ...otherConstructorArgs) {
    const elementList = convertToArray(observedElements);
    const observer = new IntersectionObserver((entries) => {
        entries === null || entries === void 0 ? void 0 : entries.forEach((entry) => __awaiter(this, void 0, void 0, function* () {
            if (entry === null || entry === void 0 ? void 0 : entry.isIntersecting) {
                try {
                    const importedClass = yield importFunction();
                    if (shouldInstantiate) {
                        const instantiated = new importedClass.default(entry.target, ...otherConstructorArgs);
                    }
                    observer.disconnect();
                }
                catch (error) {
                    console.error('An error occurred when trying to dynamically import a class.');
                    console.error(error);
                    return;
                }
            }
        }));
    }, observerOptions);
    elementList.forEach((element) => {
        observer.observe(element);
    });
}
/**
 * Import and instantiate a class when element is clicked, focused, etc.
 *
 * @param {Function} importFunction - the dynamic import function used to import the class file. This should look like import(\/* webpackChunkName: "className" *\/ 'path/to/class/file').
 * @param {ElementCollection} clickableElements - a DOM element or list of DOM elements that would be clicked.
 * @param {Event} eventType - the type of event to listen for
 * @param {boolean} shouldInstantiate - whether or not the imported module should be newed up.
 * @param {boolean | AddEventListenerOptions} listenerOptions - options to pass to the IntersectionObserver constructor
 * @param {...any} otherConstructorArgs - any other arguments to pass to the constructor.
 */
function importClassOnEvent(importFunction, elementsToListenOn, eventType, shouldInstantiate, listenerOptions, ...otherConstructorArgs) {
    const elementList = convertToArray(elementsToListenOn);
    const events = typeof eventType === 'string' ? [eventType] : eventType;
    elementList === null || elementList === void 0 ? void 0 : elementList.forEach((element) => {
        events.forEach((event) => {
            element.addEventListener(event, function listener(event) {
                return __awaiter(this, void 0, void 0, function* () {
                    const importedClass = yield importFunction();
                    if (shouldInstantiate) {
                        const instantiated = new importedClass.default(event.currentTarget, ...otherConstructorArgs);
                    }
                    this.removeEventListener(eventType, listener);
                });
            }, listenerOptions);
        });
    });
}
function convertToArray(elements) {
    if (!elements) {
        return [];
    }
    if ('length' in elements) {
        return Array.from(elements);
    }
    else {
        return [elements];
    }
}
/**
 * Remove loading states
 * @param loadingRegionSelector CSS Selector for parent element that has the aria-busy attribute. This is an accessibility feature that tells assistive technology that an element or region is loading.
 * @param loadingLabelElementSelector CSS Selector for screen-reader-only labels indicating that the region is loading
 */
function setLoadingToFalse(loadingRegionSelector, loadingLabelElementSelector) {
    const loadingRegion = document.querySelector(`${loadingRegionSelector}[aria-busy]`);
    const loadingLabel = document.querySelector(loadingLabelElementSelector);
    loadingRegion === null || loadingRegion === void 0 ? void 0 : loadingRegion.setAttribute('aria-busy', 'false');
    loadingLabel === null || loadingLabel === void 0 ? void 0 : loadingLabel.remove();
}

// EXTERNAL MODULE: ./src/utilities/performanceHelpers.ts
var performanceHelpers = __webpack_require__(69185);
// EXTERNAL MODULE: ./src/utilities/jQueryHelper/jQueryHelper.ts
var jQueryHelper = __webpack_require__(82781);
;// ./src/components/vehicle/vehicleCard/vehicleCardWasabi.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var vehicleCardWasabi_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






let VehicleCardWasabi = class VehicleCardWasabi {
    constructor(toggleService) {
        this.carouselList = [];
        this.toggleService = toggleService;
    }
    initialize() {
        return vehicleCardWasabi_awaiter(this, void 0, void 0, function* () {
            yield this.setupCarousel();
            this.setupCompare();
            this.initializePopovers();
        });
    }
    setupCarousel() {
        return vehicleCardWasabi_awaiter(this, void 0, void 0, function* () {
            const rootCarouselClassName = 'hero-carousel';
            //NOTE: SITESAA-3503: this is a constant width across the carousel item containers 
            //      and we don't want to calculate it everytime we instantiate a new carousel, 
            //      so we'll do it here and then pass it in.
            const carouselItemsContainer = `${rootCarouselClassName}__items`;
            const carouselItemsContainerElem = document.querySelectorAll(`.${carouselItemsContainer}`);
            let carouselItemsContainerWidth = 0;
            if (carouselItemsContainerElem.length > 0) {
                yield (0,performanceHelpers/* doBeforeNextRepaint */.L)(() => {
                    carouselItemsContainerWidth = carouselItemsContainerElem[0].getBoundingClientRect().width;
                });
            }
            const carouselContainer = document.querySelectorAll(".vehicleImg .top-container, .vehicle-card--mod .vehicle-image__image-wrapper");
            carouselContainer.forEach(carouselParent => {
                if (carouselParent.querySelector(`.vehicle-image .${rootCarouselClassName}`)) {
                    this.carouselList.push(new vehicleImageCarousel/* VehicleImageCarousel */.C(carouselParent, rootCarouselClassName, null, null, null, null, carouselItemsContainerWidth));
                }
            });
        });
    }
    setupCompare() {
        const url = new URL(window.location.href);
        const isVehicleCompare = url.searchParams.get('isVehicleCompare') == "true";
        if (isVehicleCompare) {
            Promise.all(/* import() | vehicleCompare */[__webpack_require__.e("vendors"), __webpack_require__.e("vehicleCompare")]).then(__webpack_require__.bind(__webpack_require__, 19409));
        }
        else {
            const checkboxes = document.querySelectorAll('[data-compare-checkbox-wrapper]');
            importClassOnScroll(() => Promise.all(/* import() | vehicleCompare */[__webpack_require__.e("vendors"), __webpack_require__.e("vehicleCompare")]).then(__webpack_require__.bind(__webpack_require__, 19409)), checkboxes, false);
        }
    }
    initializePopovers() {
        const popoverTriggers = document.querySelectorAll('.vehicle-card--mod [data-toggle="popover"]');
        popoverTriggers.forEach(el => {
            const element = window.jQuery(el);
            jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(element);
        });
    }
};
VehicleCardWasabi = __decorate([
    (0,inversify/* injectable */._G)(),
    __param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IToggleService)),
    __metadata("design:paramtypes", [Object])
], VehicleCardWasabi);



/***/ }),

/***/ 88102:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ TranslationFetcher)
/* harmony export */ });
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90260);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

let TranslationFetcher = class TranslationFetcher {
    constructor() {
        this._dealerId = window.DlronGlobal_DealerId;
    }
    getEndPoint(translationType) {
        return `/api/vhcliaa/translations/${this._dealerId}/${translationType}`;
    }
    fetch(translationType) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.getEndPoint(translationType);
            try {
                const response = yield fetch(url);
                if (response.ok) {
                    const responseData = yield response.json();
                    return responseData;
                }
                else {
                    throw new Error(`Error: ${response.status} for endpoint ${url}`);
                }
            }
            catch (error) {
                console.error(new Error(`Error fetching translations from ${url}: ${error.message}`));
                return "";
            }
        });
    }
};
TranslationFetcher = __decorate([
    (0,inversify__WEBPACK_IMPORTED_MODULE_0__/* .injectable */ ._G)()
], TranslationFetcher);



/***/ }),

/***/ 88390:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Metadata = void 0;
var METADATA_KEY = __webpack_require__(94725);
var Metadata = function () {
  function Metadata(key, value) {
    this.key = key;
    this.value = value;
  }
  Metadata.prototype.toString = function () {
    if (this.key === METADATA_KEY.NAMED_TAG) {
      return "named: " + this.value.toString() + " ";
    } else {
      return "tagged: { key:" + this.key.toString() + ", value: " + this.value + " }";
    }
  };
  return Metadata;
}();
exports.Metadata = Metadata;

/***/ }),

/***/ 88586:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ Industry)
/* harmony export */ });
// make sure this matches the values in VHCLIAA.Core.Common.Industry
var Industry;
(function (Industry) {
    Industry[Industry["Automotive"] = 0] = "Automotive";
    Industry[Industry["Fireplace"] = 1] = "Fireplace";
    Industry[Industry["Powersports"] = 2] = "Powersports";
    Industry[Industry["Legal"] = 3] = "Legal";
    Industry[Industry["RecreationalVehicles"] = 4] = "RecreationalVehicles";
})(Industry || (Industry = {}));


/***/ }),

/***/ 90260:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
var keys = __webpack_require__(94725);
__webpack_unused_export__ = keys;
var container_1 = __webpack_require__(69638);
Object.defineProperty(exports, "mc", ({
  enumerable: true,
  get: function () {
    return container_1.Container;
  }
}));
var literal_types_1 = __webpack_require__(27802);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return literal_types_1.BindingScopeEnum;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return literal_types_1.BindingTypeEnum;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return literal_types_1.TargetTypeEnum;
  }
});
var container_module_1 = __webpack_require__(35517);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return container_module_1.AsyncContainerModule;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return container_module_1.ContainerModule;
  }
});
var injectable_1 = __webpack_require__(18370);
Object.defineProperty(exports, "_G", ({
  enumerable: true,
  get: function () {
    return injectable_1.injectable;
  }
}));
var tagged_1 = __webpack_require__(9523);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return tagged_1.tagged;
  }
});
var named_1 = __webpack_require__(17590);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return named_1.named;
  }
});
var inject_1 = __webpack_require__(47442);
Object.defineProperty(exports, "WQ", ({
  enumerable: true,
  get: function () {
    return inject_1.inject;
  }
}));
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return inject_1.LazyServiceIdentifer;
  }
});
var optional_1 = __webpack_require__(93091);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return optional_1.optional;
  }
});
var unmanaged_1 = __webpack_require__(23415);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return unmanaged_1.unmanaged;
  }
});
var multi_inject_1 = __webpack_require__(6088);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return multi_inject_1.multiInject;
  }
});
var target_name_1 = __webpack_require__(68690);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return target_name_1.targetName;
  }
});
var post_construct_1 = __webpack_require__(52719);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return post_construct_1.postConstruct;
  }
});
var metadata_reader_1 = __webpack_require__(15426);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return metadata_reader_1.MetadataReader;
  }
});
var id_1 = __webpack_require__(78418);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return id_1.id;
  }
});
var decorator_utils_1 = __webpack_require__(50040);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return decorator_utils_1.decorate;
  }
});
var constraint_helpers_1 = __webpack_require__(23884);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return constraint_helpers_1.traverseAncerstors;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return constraint_helpers_1.taggedConstraint;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return constraint_helpers_1.namedConstraint;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return constraint_helpers_1.typeConstraint;
  }
});
var serialization_1 = __webpack_require__(57911);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return serialization_1.getServiceIdentifierAsString;
  }
});
var binding_utils_1 = __webpack_require__(24984);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return binding_utils_1.multiBindToService;
  }
});

/***/ }),

/***/ 92064:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BindingInSyntax = void 0;
var literal_types_1 = __webpack_require__(27802);
var binding_when_on_syntax_1 = __webpack_require__(33341);
var BindingInSyntax = function () {
  function BindingInSyntax(binding) {
    this._binding = binding;
  }
  BindingInSyntax.prototype.inRequestScope = function () {
    this._binding.scope = literal_types_1.BindingScopeEnum.Request;
    return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
  };
  BindingInSyntax.prototype.inSingletonScope = function () {
    this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
    return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
  };
  BindingInSyntax.prototype.inTransientScope = function () {
    this._binding.scope = literal_types_1.BindingScopeEnum.Transient;
    return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
  };
  return BindingInSyntax;
}();
exports.BindingInSyntax = BindingInSyntax;

/***/ }),

/***/ 93091:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.optional = void 0;
var METADATA_KEY = __webpack_require__(94725);
var metadata_1 = __webpack_require__(88390);
var decorator_utils_1 = __webpack_require__(50040);
function optional() {
  return function (target, targetKey, index) {
    var metadata = new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true);
    if (typeof index === "number") {
      decorator_utils_1.tagParameter(target, targetKey, index, metadata);
    } else {
      decorator_utils_1.tagProperty(target, targetKey, metadata);
    }
  };
}
exports.optional = optional;

/***/ }),

/***/ 93677:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ RefinementType)
/* harmony export */ });
var RefinementType;
(function (RefinementType) {
    RefinementType["Year"] = "Year";
    RefinementType["Make"] = "Make";
    RefinementType["Model"] = "Model";
    RefinementType["Trim"] = "Trim";
    RefinementType["PriceRange"] = "PriceRange";
    RefinementType["PriceAndPayment"] = "PriceAndPayment";
    RefinementType["Mileage"] = "Mileage";
    RefinementType["Mileagerange"] = "Mileagerange";
    RefinementType["Location"] = "Location";
    RefinementType["Dealership"] = "Dealership";
    RefinementType["Bodystyle"] = "Bodystyle";
    RefinementType["Extcolor"] = "Extcolor";
    RefinementType["Intcolor"] = "Intcolor";
    RefinementType["CityMpgRange"] = "CityMpgRange";
    RefinementType["HwyMpgRange"] = "HwyMpgRange";
    RefinementType["Cylinder"] = "Cylinder";
    RefinementType["Displacement"] = "Displacement";
    RefinementType["Transmission"] = "Transmission";
    RefinementType["Features"] = "Features";
    RefinementType["Fueltype"] = "Fueltype";
    RefinementType["DriveTrainType"] = "DriveTrainType";
    RefinementType["Tags"] = "Tags";
    RefinementType["VehicleType"] = "VehicleType";
    RefinementType["BodyType"] = "BodyType";
    RefinementType["Packages"] = "Packages";
    RefinementType["LeasePriceRange"] = "LeasePriceRange";
    RefinementType["FinancePriceRange"] = "FinancePriceRange";
    RefinementType["VehicleCondition"] = "VehicleCondition";
    RefinementType["ModelAndTrim"] = "ModelAndTrim";
    RefinementType["CpoTier"] = "CpoTier";
    RefinementType["CarBravo"] = "CarBravo";
    RefinementType["Availability"] = "Availability";
    RefinementType["BedLength"] = "BedLength";
    RefinementType["YearRange"] = "YearRange";
    RefinementType["RangeRange"] = "RangeRange";
    RefinementType["InTransit"] = "intransit";
    RefinementType["InProduction"] = "inproduction";
    RefinementType["InStock"] = "instock";
    RefinementType["Special"] = "Special";
    RefinementType["Cpo"] = "Cpo";
    RefinementType["carfax1owner"] = "carfax1owner";
    RefinementType["commercialvehicle"] = "commercialvehicle";
    RefinementType["searchValet"] = "q";
    RefinementType["VehicleStageText"] = "VehicleStageText";
    RefinementType["SignalsForYou"] = "signalsforyou";
    RefinementType["Manufacturer"] = "Manufacturer";
    RefinementType["WeightRange"] = "WeightRange";
    RefinementType["LengthRange"] = "LengthRange";
    RefinementType["Class"] = "Class";
    RefinementType["SlideRange"] = "SlideRange";
    RefinementType["RvType"] = "rvType";
    RefinementType["RvBrand"] = "RvBrand";
    RefinementType["SleepsRange"] = "SleepsRange";
    RefinementType["LocationName"] = "LocationName";
})(RefinementType || (RefinementType = {}));


/***/ }),

/***/ 94725:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.POST_CONSTRUCT = exports.DESIGN_PARAM_TYPES = exports.PARAM_TYPES = exports.TAGGED_PROP = exports.TAGGED = exports.MULTI_INJECT_TAG = exports.INJECT_TAG = exports.OPTIONAL_TAG = exports.UNMANAGED_TAG = exports.NAME_TAG = exports.NAMED_TAG = void 0;
exports.NAMED_TAG = "named";
exports.NAME_TAG = "name";
exports.UNMANAGED_TAG = "unmanaged";
exports.OPTIONAL_TAG = "optional";
exports.INJECT_TAG = "inject";
exports.MULTI_INJECT_TAG = "multi_inject";
exports.TAGGED = "inversify:tagged";
exports.TAGGED_PROP = "inversify:tagged_props";
exports.PARAM_TYPES = "inversify:paramtypes";
exports.DESIGN_PARAM_TYPES = "design:paramtypes";
exports.POST_CONSTRUCT = "post_construct";

/***/ }),

/***/ 94999:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  H: () => (/* binding */ ShareVehicleModal)
});

;// ./src/components/smsForm/smsForm.ts
var SpecialType;
(function (SpecialType) {
    SpecialType[SpecialType["new"] = 1] = "new";
    SpecialType[SpecialType["cpo"] = 2] = "cpo";
    SpecialType[SpecialType["used"] = 3] = "used";
    SpecialType[SpecialType["serviceAndParts"] = 4] = "serviceAndParts";
    SpecialType[SpecialType["general"] = 5] = "general";
    SpecialType[SpecialType["symphony"] = 7] = "symphony";
    SpecialType[SpecialType["default"] = 0] = "default";
})(SpecialType || (SpecialType = {}));
class SmsForm {
    get isVehicleBasedLead() {
        return this._isVehicleBasedLead;
    }
    set smsComponentSuccessCallback(callback) {
        this._smsComponentSuccessCallback = callback;
    }
    set smsComponentErrorCallback(callback) {
        this._smsComponentErrorCallback = callback;
    }
    constructor(data) {
        this._isMobile = false;
        this._isVehicleBasedLead = false;
        this.clearLeadData = (leadDataElements) => {
            leadDataElements.forEach(dataElement => {
                dataElement.value = "";
            });
            if (this._leadData.isVehicleBasedLead) {
                if (this._leadVinElement) {
                    this._leadVinElement.value = "";
                }
                if (this._altIdElement) {
                    this._altIdElement.value = "";
                }
            }
        };
        this.specialTypeToLeadSource = () => {
            const leadData = this._leadData;
            const isMobile = this._isMobile;
            const specialType = this.getInputElementValue(this._specialTypeElement);
            switch (parseInt(specialType)) {
                case SpecialType.new:
                    return (isMobile) ? leadData.leadSources.OfferMobileNew : leadData.leadSources.OfferDesktopNew;
                case SpecialType.symphony:
                    return (isMobile) ? leadData.leadSources.SymphonyOfferMobile : leadData.leadSources.SymphonyOfferDesktop;
                case SpecialType.cpo:
                    return (isMobile) ? leadData.leadSources.OfferMobileCertifiedPreOwned : leadData.leadSources.OfferDesktopCertifiedPreOwned;
                case SpecialType.used:
                    return (isMobile) ? leadData.leadSources.OfferMobileUsed : leadData.leadSources.OfferDesktopUsed;
                case SpecialType.serviceAndParts:
                    return (isMobile) ? leadData.leadSources.OfferMobileServiceAndParts : leadData.leadSources.OfferDesktopServiceAndParts;
                case SpecialType.general:
                    return (isMobile) ? leadData.leadSources.OfferMobileGeneral : leadData.leadSources.OfferDesktopGeneral;
                default: return SpecialType.default;
            }
        };
        this.specialTypeToLeadType = () => {
            const leadData = this._leadData;
            const specialType = this.getInputElementValue(this._specialTypeElement);
            switch (parseInt(specialType)) {
                case SpecialType.new:
                case SpecialType.symphony:
                    return leadData.leadTypes.NewCar;
                case SpecialType.cpo:
                case SpecialType.used:
                    return leadData.leadTypes.UsedCar;
                case SpecialType.serviceAndParts:
                    return leadData.leadTypes.Service;
                case SpecialType.general:
                    return leadData.leadTypes.GeneralContact;
                default: return SpecialType.default;
            }
        };
        this._smsLeadDataElementId = data.smsLeadDataElementId;
        this._smsComponentElementId = data.smsComponentElementId;
        this._smsComponentLeadDataFormId = data.smsComponentLeadDataFormId;
        this._smsLeadFormSubmitFunctionName = data.smsLeadFormSubmitFunctionName;
        this._smsComponentButtonElement = data.smsComponentButtonElement;
        this._trackingEventCategory_smsSubmitButtonClick = data.trackingEventCategory_smsSubmitButtonClick;
        this._trackingEventCategory_smsComponentButtonClick = data.trackingEventCategory_smsComponentButtonClick;
        this._trackingEventCategory_smsLeadExists = data.rackingEventCategory_smsLeadExists;
        this._leadDataElements = data.leadDataElements;
        this.getLeadElements();
        this.initialize();
    }
    initialize() {
        const failureErrorMsg = this.getLeadData();
        if (failureErrorMsg.length > 0) {
            console.error(failureErrorMsg);
        }
        this._isVehicleBasedLead = this._leadData.isVehicleBasedLead;
        this._isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this._lead = (this._isMobile) ? this._leadData.mobile : this._leadData.desktop;
        // Make local references to class variables to avoid issues with 'this' in callbacks
        const leadData = this._leadData;
        const lead = this._lead;
        this.initializeDealeronLead(lead, leadData);
        this.initializeSmsComponentButton(leadData);
    }
    getLeadElements() {
        this._leadPhoneElement = this.getElementByIdHelper("smslead_phone");
        this._leadVinElement = this.getElementByIdHelper("smslead_vin");
        this._altIdElement = this.getElementByIdHelper("smslead_altid");
        this._specialTypeElement = this.getElementByIdHelper("smslead_specialType");
        this._vehicleIdElement = this.getElementByIdHelper("smslead_vehicleid");
        this._couponElement = this.getElementByIdHelper("smslead_coupon");
        this._commentAdditionElement = this.getElementByIdHelper("smslead_commentAddition");
        this._vehicleNameElement = this.getElementByIdHelper("smslead_vehicleName");
        this._specialDetailsUriElement = this.getElementByIdHelper("smslead_specialDetailsUri");
    }
    getElementByIdHelper(elementId) {
        return document.querySelector(`#${this._smsComponentElementId} #${elementId}`);
    }
    getLeadData() {
        const leadDataScript = document.getElementById(this._smsLeadDataElementId);
        let errorMsg = "";
        if (leadDataScript) {
            try {
                const scriptText = leadDataScript.text;
                this._leadData = JSON.parse(scriptText);
            }
            catch (err) {
                errorMsg = "Error parsing lead data JSON for smsForm.js- failed to initialize smsFormComponent.";
            }
        }
        else {
            errorMsg = `#${this._smsLeadDataElementId} does not exist - failed to initialize smsFormComponent.`;
        }
        return errorMsg;
    }
    initializeDealeronLead(lead, leadData) {
        var _a;
        const submitOptions = this.getSubmitOptions(lead, leadData);
        window.DealeronLead.addSubmissionMethod(this._smsLeadFormSubmitFunctionName, submitOptions);
        window.DealeronLead.initialize(`#${this._smsComponentElementId} #${this._smsComponentLeadDataFormId}`, this._smsLeadFormSubmitFunctionName);
        (_a = this._leadPhoneElement) === null || _a === void 0 ? void 0 : _a.addEventListener("focus", function () {
            window.DealeronLead.begin();
            const leadSourceName = lead.id;
            window.trackerHook({ trackId: leadSourceName });
        });
    }
    getSubmitOptions(lead, leadData) {
        let phoneNum;
        const clearLeadData = this.clearLeadData;
        return {
            leadSource: (leadData.isDqlSpecialBasedLead) ? this.specialTypeToLeadSource : lead.id,
            leadType: (leadData.isDqlSpecialBasedLead) ? this.specialTypeToLeadType : leadData.leadType,
            additionalData: this.getAdditionalData(phoneNum),
            successCallback: this.smsSubmitSuccessCallback(phoneNum, lead, clearLeadData),
            errorCallback: this.smsSubmitErrorCallback(),
            endpoint: "/api/lead/sms/#TOKEN#"
        };
    }
    getAdditionalData(phoneNum) {
        return () => {
            var _a, _b;
            let vin = "";
            let altId = "";
            let vehicleId = "";
            if (this._leadData.isVehicleBasedLead) {
                vin = this.getInputElementValue(this._leadVinElement);
                altId = this.getInputElementValue(this._altIdElement);
                vehicleId = this.getInputElementValue(this._vehicleIdElement);
            }
            let comments = "";
            for (let id in this._leadData.additionalFields) {
                const comment = this.getInputElementValue(document.querySelector(`#${this._smsComponentElementId} #smslead_${id}`));
                comments += `${this._leadData.additionalFields[id]}: ${comment}; `;
            }
            if (this._leadData.isCouponBasedLead) {
                const coupon = this.getInputElementValue(this._couponElement);
                comments += `Coupon: ${coupon}; `;
            }
            if (this._leadData.isDqlSpecialBasedLead) {
                const commentAddition = this.getInputElementValue(this._commentAdditionElement);
                comments += `${commentAddition}, SMS: yes, URL: ${window.location.href}; `;
            }
            const optOut = document.querySelector(`#${this._smsComponentElementId} #${this._smsComponentLeadDataFormId}#optOut`);
            if (optOut) {
                comments += `Do Not Sell Personal Info: ${optOut.checked}`;
            }
            const specialDetailsUri = (_b = (_a = this._specialDetailsUriElement) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : window.location.href;
            let pathName = (this._leadData.isDqlSpecialBasedLead) ? specialDetailsUri : window.location.href;
            pathName = pathName.replace(/\#/gi, "");
            phoneNum = window.dataList["Phone"].replace(/\D/gi, "");
            return {
                Vin: vin,
                AltDealerId: altId,
                VehicleId: vehicleId,
                MessageLink: pathName,
                Comments: comments
            };
        };
    }
    smsSubmitSuccessCallback(phoneNum, lead, clearLeadData) {
        return (data) => {
            const vehicleName = this.getInputElementValue(this._vehicleNameElement);
            const vin = this.getInputElementValue(this._leadVinElement);
            const leadSourceName = lead.id;
            clearLeadData(this._leadDataElements);
            let response;
            try {
                response = JSON.parse(data);
            }
            catch (err) {
                response = { leadId: "-1", leadSource: "" };
            }
            window.ResetTracker();
            window.trackerHook({ trackId: leadSourceName, actionType: "click" });
            if (parseInt(response.leadId, 10) != -1) {
                let eventValue = "";
            }
            else {
                window.DealeronLead.token.value = null;
            }
            this._smsComponentSuccessCallback();
        };
    }
    smsSubmitErrorCallback() {
        return () => {
            this._smsComponentErrorCallback();
        };
    }
    initializeSmsComponentButton(leadData) {
        const _this = this;
        const lead = this._lead;
        const buttonElements = document.querySelectorAll(`[data-type="${this._smsComponentButtonElement}"]`);
        buttonElements.forEach(function (buttonElement) {
            buttonElement.addEventListener("click", function (e) {
                e.preventDefault();
                const vehicleName = buttonElement.dataset.vehicleName;
                _this.setValuesOnSmsComponent(buttonElement, leadData, vehicleName);
            });
        });
    }
    setValuesOnSmsComponent(buttonElement, leadData, vehicleName) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (leadData.isVehicleBasedLead) {
            const vin = (_a = buttonElement.dataset.vin) !== null && _a !== void 0 ? _a : "";
            const altId = (_b = buttonElement.dataset.altid) !== null && _b !== void 0 ? _b : "";
            const vehicleId = (_c = buttonElement.dataset.vehicleId) !== null && _c !== void 0 ? _c : "";
            // hidden elements
            if (this._leadVinElement) {
                this._leadVinElement.value = vin;
            }
            if (this._altIdElement) {
                this._altIdElement.value = altId;
            }
            if (this._vehicleIdElement) {
                this._vehicleIdElement.value = vehicleId;
            }
            if (this._vehicleNameElement) {
                this._vehicleNameElement.value = vehicleName;
            }
        }
        else if (leadData.isCouponBasedLead) {
            const coupon = (_d = buttonElement.dataset.coupon) !== null && _d !== void 0 ? _d : "";
            if (this._couponElement) {
                this._couponElement.value = coupon;
            }
        }
        else if (leadData.isDqlSpecialBasedLead) {
            const specialType = (_e = buttonElement.dataset.dataSpecialType) !== null && _e !== void 0 ? _e : "";
            const commentAddition = (_f = buttonElement.dataset.dataCommentAddition) !== null && _f !== void 0 ? _f : "";
            const specialDetailsUri = (_g = buttonElement.dataset.dataSpecialDetailsUri) !== null && _g !== void 0 ? _g : "";
            if (this._specialTypeElement) {
                this._specialTypeElement.value = specialType;
            }
            if (this._commentAdditionElement) {
                this._commentAdditionElement.value = commentAddition;
            }
            if (this._specialDetailsUriElement) {
                this._specialDetailsUriElement.value = specialDetailsUri;
            }
        }
    }
    getInputElementValue(element) {
        var _a;
        return (_a = element === null || element === void 0 ? void 0 : element.value) !== null && _a !== void 0 ? _a : "";
    }
}

// EXTERNAL MODULE: ./src/services/toggles/toggleService.ts
var toggleService = __webpack_require__(74529);
// EXTERNAL MODULE: ./node_modules/inversify/lib/inversify.js
var inversify = __webpack_require__(90260);
// EXTERNAL MODULE: ./src/types/types.ts
var types = __webpack_require__(45644);
;// ./src/components/shareVehicleModal/shareVehicleModal.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
// @ts-nocheck




let ShareVehicleModal = class ShareVehicleModal {
    constructor(toggleService) {
        this.referenceErrorMsg = "element does not exist - failed to initialize Share Vehicle modal.";
        this.COPY_BUTTON_TOGGLE_CLASS = "share-vehicle__button--copied";
        this._toggleService = toggleService;
    }
    initialize() {
        if (!this.modalExists()) {
            throw new ReferenceError(`${this._shareVehicleModalElementId} ${this.referenceErrorMsg}`);
        }
        this.emailRefactorToggleStatus = this._toggleService.getToggleStatus(toggleService/* Toggle */.lM.EmailRefactor);
        this.initializePrivateVariables();
        this.initializeModal();
    }
    initializePrivateVariables() {
        this._submitButtonId = "shareVehicleLeadSubmit";
        this._additionalLeadDataBlockId = "shareVehicleLeadExpanded";
        this._shareVehicleBtnElement = "share-vehicle-button";
        this._leadDataElements = document.querySelectorAll(`
      #${this._shareVehicleModalElementId} #smslead_phone,
      #${this._additionalLeadDataBlockId} input,
      #${this._additionalLeadDataBlockId} select`);
        this._smsForm = new SmsForm(this.getSmsFormParamObject());
        this._smsForm.smsComponentSuccessCallback = this.smsSubmitSuccessCallback(this._submitButtonId, this._shareVehicleModalElementId);
        this._smsForm.smsComponentErrorCallback = this.smsSubmitErrorCallback(this._submitButtonId);
        this._emailAFriendForm = this._modal.querySelector("form#emailFriendForm");
    }
    modalExists() {
        this._shareVehicleModalElementId = "shareVehicleModal";
        this._modal = document.getElementById(this._shareVehicleModalElementId);
        return this._modal !== null;
    }
    initializeEmailAFriend() {
        if (!this._emailAFriendForm) {
            return;
        }
        let endpoint = "";
        let additionalData = null;
        if (this._isCompareModal) {
            endpoint = `/api/vhcliaa/email-vehicle-compare/${window.DlronGlobal_DealerId}`;
            additionalData = (form) => {
                const optOutCheckbox = form.querySelector("#optOut");
                const optedOut = optOutCheckbox && optOutCheckbox.checked;
                const friendsName = form.querySelector("#emailFriend_friendName").value;
                const friendsEmail = form.querySelector("#emailFriend_friendEmail").value;
                const comments = form.querySelector("#emailFriend_Comments").value;
                const firstName = form.querySelector("#emailFriend_yourName").value;
                const email = form.querySelector("#emailFriend_yourEmail").value;
                const sendCopy = form.querySelector("#sendCopy").checked;
                const link = form.querySelector("#emailFriend_Url").value;
                return {
                    Comments: optedOut ? `${comments}, Do Not Sell Personal Info: true` : comments,
                    FriendsName: friendsName,
                    FriendsEmail: friendsEmail,
                    FirstName: firstName,
                    Email: email,
                    SendCopy: sendCopy,
                    Link: link
                };
            };
        }
        else if (this.emailRefactorToggleStatus) {
            endpoint = `/api/vhcliaa/email-a-friend/${window.DlronGlobal_DealerId}`;
            additionalData = (form) => {
                const optOutCheckbox = form.querySelector("#optOut");
                const optedOut = optOutCheckbox && optOutCheckbox.checked;
                const friendsName = form.querySelector("#emailFriend_friendName").value;
                const friendsEmail = form.querySelector("#emailFriend_friendEmail").value;
                const comments = form.querySelector("#emailFriend_Comments").value;
                const firstName = form.querySelector("#emailFriend_yourName").value;
                const email = form.querySelector("#emailFriend_yourEmail").value;
                const sendCopy = form.querySelector("#sendCopy").checked;
                return {
                    VehicleId: form.dataset.vehicleId,
                    Vin: form.dataset.vin,
                    Comments: optedOut ? `${comments}, Do Not Sell Personal Info: true` : comments,
                    FriendsName: friendsName,
                    FriendsEmail: friendsEmail,
                    FirstName: firstName,
                    Email: email,
                    SendCopy: sendCopy
                };
            };
        }
        else {
            endpoint = "/api/lead/emailFriend/#TOKEN#";
            additionalData = (form) => {
                const optOutCheckbox = form.querySelector("#optOut");
                const optedOut = optOutCheckbox && optOutCheckbox.checked;
                const comment = form.querySelector("#emailFriend_Comments").value;
                return {
                    VehicleId: form.dataset.vehicleId,
                    Vin: form.dataset.vin,
                    Comments: optedOut ? `${comment}, Do Not Sell Personal Info: true` : comment
                };
            };
        }
        const submitOptions = {
            submitCoreValues: false,
            endpoint: endpoint,
            successCallback: () => {
                window.jQuery(this._modal).modal("hide");
            },
            additionalData: additionalData
        };
        window.DealeronLead.addSubmissionMethod("emailFriendSubmitOptions", submitOptions);
        window.DealeronLead.initialize(this._emailAFriendForm, "emailFriendSubmitOptions");
        const friendEmailField = this._emailAFriendForm.querySelector("#emailFriend_friendEmail");
        if (friendEmailField) {
            friendEmailField.addEventListener("focusout", window.DealeronLead.begin);
        }
    }
    getSmsFormParamObject() {
        return {
            smsLeadDataElementId: "shareVehicleLeadData",
            smsComponentElementId: this._shareVehicleModalElementId,
            smsComponentLeadDataFormId: "shareVehicleLeadForm",
            smsLeadFormSubmitFunctionName: "smsShareVehicleModalSubmit",
            smsComponentButtonElement: this._shareVehicleBtnElement,
            trackingEventCategory_smsSubmitButtonClick: "Share-Vehicle-Modal-Submit",
            rackingEventCategory_smsLeadExists: "Share-Vehicle-Modal-Lead",
            trackingEventCategory_smsComponentButtonClick: "Share-Vehicle-Button",
            leadDataElements: this._leadDataElements
        };
    }
    initializeModal() {
        var _a;
        jQuery(`#${this._shareVehicleModalElementId}`).on("show.bs.modal", (event) => {
            var _a;
            const shareVehicleButtonElement = event.relatedTarget;
            const vin = shareVehicleButtonElement.dataset.vin;
            const vehicleId = shareVehicleButtonElement.dataset.vehicleId;
            if (this._emailAFriendForm) {
                this._emailAFriendForm.dataset.vin = vin;
                this._emailAFriendForm.dataset.vehicleId = vehicleId;
            }
            const vehicleName = (_a = shareVehicleButtonElement.dataset.vehicleName) !== null && _a !== void 0 ? _a : "";
            this.updateModalTitle(vehicleName);
            this.updateHTMLValueHelper("shareVehicleModalTitleVehicleName", vehicleName, "textContent");
            if (document.querySelector(".vehicle-compare-container")) {
                this.toggleTextOptions(false);
                this._isCompareModal = true;
            }
            this.initializeEmailAFriend();
        });
        jQuery(`#${this._shareVehicleModalElementId}`).on("hide.bs.modal", (event) => {
            if (document.querySelector(".vehicle-compare-container")) {
                this.toggleTextOptions(true);
            }
            this._isCompareModal = false;
            this.clearForms();
        });
        (_a = document.getElementById("shareVehicleLeadPortion")) === null || _a === void 0 ? void 0 : _a.addEventListener("change", (event) => {
            this.toggleLeadExpansion(event);
        });
    }
    toggleLeadExpansion(event) {
        const target = event.target;
        if (target.checked) {
            jQuery(`#${this._additionalLeadDataBlockId}`).slideDown();
        }
        else {
            jQuery(`#${this._additionalLeadDataBlockId}`).slideUp();
        }
    }
    smsSubmitSuccessCallback(submitButtonId, shareVehicleModalElementId) {
        return () => {
            var _a;
            (_a = document.getElementById(submitButtonId)) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
            jQuery(`#${shareVehicleModalElementId}`).modal("hide");
        };
    }
    smsSubmitErrorCallback(submitButtonId) {
        return () => {
            var _a;
            alert("An error occurred sending the message. Please try again.");
            (_a = document.getElementById(submitButtonId)) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
        };
    }
    updateModalTitle(vehicleName) {
        if (this._smsForm.isVehicleBasedLead) {
            const formTitleNameElement = document.querySelector(`#${this._shareVehicleModalElementId} #shareVehicleModalTitleVehicleName`);
            if (formTitleNameElement) {
                formTitleNameElement.innerHTML = vehicleName;
            }
        }
    }
    updateHTMLValueHelper(elementId, htmlContent, valueKey) {
        const updateElement = document.getElementById(elementId);
        if (updateElement) {
            updateElement[valueKey] = htmlContent;
        }
    }
    // Added as part of DO-25632
    toggleTextOptions(showTextOptions) {
        let textForm = document.querySelector(".share-panel--text-me");
        if (textForm) {
            let modal = document.querySelector(`#${this._shareVehicleModalElementId}`);
            let body = document.querySelector(".share-vehicle__body");
            let panels = document.querySelector(".share-vehicle__panels");
            let accordionToggles = document.querySelectorAll(".share-panel__toggle");
            let emailContent = document.querySelector("#emailFriendContent");
            let panelLabels = document.querySelectorAll(".panel-label");
            // show text form
            if (showTextOptions) {
                modal.classList.remove("share-vehicle--1-forms");
                modal.classList.add("share-vehicle--2-forms");
                body.classList.remove("share-vehicle__body--single-panel");
                panels.classList.remove("share-vehicle__panels--single-panel");
                textForm.classList.remove("hide-text-me-panel");
                accordionToggles.forEach((item) => {
                    item.classList.remove("hide-text-me-panel");
                });
                emailContent.classList.add("collapse");
                panelLabels.forEach((item) => {
                    item.classList.remove("hidden");
                });
            }
            // hide text form
            else {
                modal.classList.remove("share-vehicle--2-forms");
                modal.classList.add("share-vehicle--1-forms");
                body.classList.add("share-vehicle__body--single-panel");
                panels.classList.add("share-vehicle__panels--single-panel");
                textForm.classList.add("hide-text-me-panel");
                accordionToggles.forEach((item) => {
                    item.classList.add("hide-text-me-panel");
                });
                emailContent.classList.remove("collapse");
                panelLabels.forEach((item) => {
                    item.classList.add("hidden");
                });
            }
        }
    }
    clearForms() {
        let modalElem = document.querySelector(`#${this._shareVehicleModalElementId}`);
        modalElem.querySelectorAll("input:not([type='hidden'])").forEach((elem) => elem.value = "");
        modalElem.querySelectorAll("textarea").forEach((elem) => elem.value = "");
        modalElem.querySelectorAll(".has-error").forEach((elem) => {
            if (elem.nodeName.toLocaleLowerCase() === "label") {
                elem.parentElement.removeChild(elem);
            }
            else {
                elem.classList.remove('has-error');
            }
        });
        modalElem.querySelectorAll('.has-success').forEach((elem) => elem.classList.remove('has-success'));
        document.getElementById('btnSubmit').removeAttribute('disabled');
    }
};
ShareVehicleModal = __decorate([
    (0,inversify/* injectable */._G)(),
    __param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IToggleService)),
    __metadata("design:paramtypes", [Object])
], ShareVehicleModal);



/***/ }),

/***/ 98229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isStackOverflowExeption = void 0;
var ERROR_MSGS = __webpack_require__(27718);
function isStackOverflowExeption(error) {
  return error instanceof RangeError || error.message === ERROR_MSGS.STACK_OVERFLOW;
}
exports.isStackOverflowExeption = isStackOverflowExeption;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames not based on template
/******/ 			if (chunkId === "vendors") return "" + chunkId + "Chunk.161c4c50e94a2fc11a33.min.js";
/******/ 			if (chunkId === "vehicleCompare") return "" + chunkId + "Chunk.464176d3b798f62602e6.min.js";
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".min.css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "vhcliaa:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/runtimeId */
/******/ 	(() => {
/******/ 		__webpack_require__.j = "pages/vehicleDetailsPage/vehicleDetailsPageHoisin";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/resources/vhcliaa/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		if (typeof document === "undefined") return;
/******/ 		var createStylesheet = (chunkId, fullhref, oldTag, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			if (__webpack_require__.nc) {
/******/ 				linkTag.nonce = __webpack_require__.nc;
/******/ 			}
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && event.type;
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + errorType + ": " + realHref + ")");
/******/ 					err.name = "ChunkLoadError";
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					if (linkTag.parentNode) linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 		
/******/ 			if (oldTag) {
/******/ 				oldTag.parentNode.insertBefore(linkTag, oldTag.nextSibling);
/******/ 			} else {
/******/ 				document.head.appendChild(linkTag);
/******/ 			}
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, null, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// object to store loaded CSS chunks
/******/ 		var installedCssChunks = {
/******/ 			"common": 0,
/******/ 			"pages/vehicleDetailsPage/vehicleDetailsPageHoisin": 0,
/******/ 			"src_components_spaCosmos_customDropdown_customDropdownModel_ts-_d62d0": 0,
/******/ 			"src_components_spaCosmos_customDropdown_customDropdownModel_ts-_d62d1": 0,
/******/ 			"src_components_spaCosmos_customDropdown_customDropdownModel_ts-_d62d2": 0,
/******/ 			"vue-vendor": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.miniCss = (chunkId, promises) => {
/******/ 			var cssChunks = {"vehicleCompare":1};
/******/ 			if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);
/******/ 			else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {
/******/ 				promises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(() => {
/******/ 					installedCssChunks[chunkId] = 0;
/******/ 				}, (e) => {
/******/ 					delete installedCssChunks[chunkId];
/******/ 					throw e;
/******/ 				}));
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no hmr
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"common": 0,
/******/ 			"pages/vehicleDetailsPage/vehicleDetailsPageHoisin": 0,
/******/ 			"src_components_spaCosmos_customDropdown_customDropdownModel_ts-_d62d0": 0,
/******/ 			"src_components_spaCosmos_customDropdown_customDropdownModel_ts-_d62d1": 0,
/******/ 			"src_components_spaCosmos_customDropdown_customDropdownModel_ts-_d62d2": 0,
/******/ 			"vue-vendor": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkvhcliaa"] = self["webpackChunkvhcliaa"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

// UNUSED EXPORTS: VehicleDetailsPageHoisinLoader

// EXTERNAL MODULE: ./node_modules/reflect-metadata/Reflect.js
var reflect_metadata_Reflect = __webpack_require__(9708);
// EXTERNAL MODULE: ./src/components/digitalGarage/tdgConfirmAndContactButtons.ts
var tdgConfirmAndContactButtons = __webpack_require__(47067);
// EXTERNAL MODULE: ./src/core/enums/uiLocationVersion.ts
var uiLocationVersion = __webpack_require__(23277);
// EXTERNAL MODULE: ./node_modules/inversify/lib/inversify.js
var inversify = __webpack_require__(90260);
;// ./src/components/digitalGarage/digitalGarage.ts
class DigitalGarage {
    constructor() {
        this.setDigitalGarageForceShow();
    }
    setDigitalGarageForceShow() {
        window.addEventListener("load", () => {
            var _a, _b, _c, _d, _e;
            let tdgSettings;
            try {
                tdgSettings = JSON.parse((_b = (_a = document.getElementById("toyotaDigitalGarageSettings")) === null || _a === void 0 ? void 0 : _a.innerHTML) !== null && _b !== void 0 ? _b : null);
            }
            catch (_f) {
                tdgSettings = null;
            }
            if ((_c = tdgSettings === null || tdgSettings === void 0 ? void 0 : tdgSettings.digitalGarageDataHub) !== null && _c !== void 0 ? _c : false) {
                for (const tdgCartElem of Array.from((_d = document.querySelectorAll("dg-shopping-cart")) !== null && _d !== void 0 ? _d : [])) {
                    tdgCartElem.setAttribute("force-show", `${(_e = tdgSettings.digitalGarageDataHub.forceTdgShoppingCart) !== null && _e !== void 0 ? _e : false}`);
                }
            }
        });
    }
}

// EXTERNAL MODULE: ./src/components/hideableScrollbar/hideableScrollbar.ts
var hideableScrollbar = __webpack_require__(56839);
;// ./src/components/moreInfoModal/moreInfoModal.ts
/// <reference path="../../utilities/do_utility.ts" />
class MoreInfoModal {
    constructor() {
        this.getElements();
        this.addShowEventListener();
    }
    getElements() {
        this._titleElement = this.getModalElement('title');
        this._contentElement = this.getModalElement('text');
    }
    getModalElement(selectorValue) {
        const element = document.querySelector(`[data-modal-element="${selectorValue}"]`);
        return element;
    }
    addShowEventListener() {
        /* NOTE: this is calling Bootstrap events so we have to use jQuery */
        $(`[data-modal-element="wrapper"]`).on('show.bs.modal', (event) => {
            var _a, _b;
            /* Funky casting needed for Bootstrap event */
            const clickEvent = event;
            const modalTrigger = clickEvent.relatedTarget;
            const title = (_a = modalTrigger === null || modalTrigger === void 0 ? void 0 : modalTrigger.dataset) === null || _a === void 0 ? void 0 : _a.title;
            const content = (_b = modalTrigger === null || modalTrigger === void 0 ? void 0 : modalTrigger.dataset) === null || _b === void 0 ? void 0 : _b.content;
            if (!(content && this._contentElement)) {
                return event.preventDefault();
            }
            if (this._titleElement) {
                if (title) {
                    this._titleElement.innerHTML = title;
                }
                else {
                    this._titleElement.innerHTML = '';
                }
            }
            if (this._contentElement) {
                this._contentElement.innerHTML = DoUtility.DecodeHtml(content);
            }
        });
    }
}

;// ./src/components/oem/ford/autofi.ts
class AutoFi {
    constructor() {
        this.init();
    }
    init() {
        const elems = document.querySelectorAll(".autofi-ui-root");
        elems.forEach((elem) => {
            elem.dataset.tertiarySource = this.getT3WebsiteCookie;
        });
    }
    get getT3WebsiteCookie() {
        let t3WebsiteCookie = "";
        if (window.DealeronCookie) {
            t3WebsiteCookie = (window.DealeronCookie.getItem("t3website") || "");
        }
        if (t3WebsiteCookie != "") {
            const elements = t3WebsiteCookie.match(/<cookieguid>([^<]*)<\/cookieguid>/);
            if ((elements === null || elements === void 0 ? void 0 : elements.length) > 1) {
                const cookieguid = elements[1];
                if (cookieguid != null) {
                    return cookieguid;
                }
            }
        }
        return "";
    }
}

// EXTERNAL MODULE: ./src/components/oem/ford/evnVideoPlayer.ts
var evnVideoPlayer = __webpack_require__(83925);
// EXTERNAL MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__(74208);
// EXTERNAL MODULE: ./src/utilities/jQueryHelper/jQueryHelper.ts
var jQueryHelper = __webpack_require__(82781);
;// ./src/components/priceStak/priceStak.ts


var DropdownEvent;
(function (DropdownEvent) {
    DropdownEvent["SHOW"] = "show";
    DropdownEvent["HIDE"] = "hide";
})(DropdownEvent || (DropdownEvent = {}));
var DropdownButtonText;
(function (DropdownButtonText) {
    DropdownButtonText["MORE"] = "More";
    DropdownButtonText["LESS"] = "Less";
})(DropdownButtonText || (DropdownButtonText = {}));
var DoTaggingResult;
(function (DoTaggingResult) {
    DoTaggingResult["INCREASE"] = "increase";
    DoTaggingResult["DECREASE"] = "decrease";
})(DoTaggingResult || (DoTaggingResult = {}));
class PriceStak {
    constructor() {
        this.getElements();
        this.addDropdownListeners();
        this.addDropdownResizeObserver();
    }
    getElements() {
        this._elementSelectorName = 'data-pricestak-element';
        this._dropdownSelector = `[${this._elementSelectorName}="collapse"]`;
        this._dropdownButtonSelector = `[${this._elementSelectorName}="collapse-button"]`;
        this._dropdownButtonLabelSelector = `[${this._elementSelectorName}="collapse-button-label"]`;
        this._dropdowns = document.querySelectorAll(this._dropdownSelector);
        this._dropdownButtons = document.querySelectorAll(this._dropdownButtonSelector);
        this._dropdownButtonLabels = document.querySelectorAll(this._dropdownButtonLabelSelector);
    }
    toggleAllDropdowns(eventType) {
        const newButtonLabel = eventType === DropdownEvent.SHOW ? DropdownButtonText.LESS : DropdownButtonText.MORE;
        const newButtonDoTaggingResult = eventType === DropdownEvent.SHOW ? DoTaggingResult.DECREASE : DoTaggingResult.INCREASE;
        for (let i = 0; i < this._dropdownButtons.length; i++) {
            const label = this._dropdownButtonLabels[i];
            const dropdown = this._dropdowns[i];
            const doTaggedButton = this._dropdownButtons[i];
            doTaggedButton.setAttribute('data-dotagging-event-action-result', newButtonDoTaggingResult);
            label.innerText = newButtonLabel;
            jQueryHelper/* JQueryHelper */.$.SafeApplyCollapse(dropdown, eventType);
        }
    }
    addDropdownListeners() {
        if (this._dropdowns && this._dropdownButtonLabels) {
            for (let i = 0; i < this._dropdownButtons.length; i++) {
                const button = this._dropdownButtons[i];
                button.addEventListener('click', (event) => {
                    this.dropdownButtonCallback(event);
                });
            }
            window.jQuery(this._dropdowns).on('hidden.bs.collapse', (event) => {
                this.toggleDropdownResizeObservation(false);
            });
            window.jQuery(this._dropdowns).on('shown.bs.collapse', (event) => {
                this.toggleDropdownResizeObservation(false);
            });
        }
    }
    dropdownButtonCallback(event) {
        var _a;
        event.preventDefault();
        const clickedElement = event.target;
        const clickedButton = clickedElement.closest(this._dropdownButtonSelector);
        const target_DropdownSelector = (_a = clickedButton === null || clickedButton === void 0 ? void 0 : clickedButton.dataset) === null || _a === void 0 ? void 0 : _a.target;
        this._currentDropdown = document.querySelector(target_DropdownSelector);
        const scrollbarPositionBeforeToggle = document.documentElement.scrollTop;
        const scrollHeightBeforeToggle = document.documentElement.scrollHeight;
        this._currentScrollbarRatio = scrollbarPositionBeforeToggle / scrollHeightBeforeToggle;
        const ariaExpanded = clickedButton.getAttribute('aria-expanded');
        this.toggleDropdownResizeObservation(true);
        if (ariaExpanded != null) {
            const eventType = ariaExpanded === 'true' ? DropdownEvent.HIDE : DropdownEvent.SHOW;
            this.toggleAllDropdowns(eventType);
        }
    }
    addDropdownResizeObserver() {
        this._resizeObserver = new ResizeObserver_es/* default */.A(() => {
            const scrollHeightAfterToggle = document.documentElement.scrollHeight;
            const scrollbarPositionAfterToggle = scrollHeightAfterToggle * this._currentScrollbarRatio;
            document.documentElement.scrollTo({ top: scrollbarPositionAfterToggle });
        });
    }
    toggleDropdownResizeObservation(shouldObserve) {
        if (this._currentDropdown) {
            if (shouldObserve) {
                this._resizeObserver.observe(this._currentDropdown);
            }
            else {
                this._resizeObserver.unobserve(this._currentDropdown);
            }
        }
    }
}

// EXTERNAL MODULE: ./src/components/shareVehicleModal/shareVehicleModal.ts + 1 modules
var shareVehicleModal = __webpack_require__(94999);
;// ./src/components/moreLessButton/moreLessButton.ts
class MoreLessButton {
    constructor(truncateButton, truncatedElement) {
        this._truncateButton = truncateButton;
        this._truncatedElement = truncatedElement;
        this.addClickEvent();
    }
    addClickEvent() {
        var _a;
        (_a = this._truncateButton) === null || _a === void 0 ? void 0 : _a.addEventListener('click', () => {
            this.toggleTruncation();
        });
    }
    toggleTruncation() {
        var _a, _b, _c, _d, _e, _f;
        if (this._truncatedElement && this._truncateButton) {
            const moreText = (_a = this._truncateButton.dataset) === null || _a === void 0 ? void 0 : _a.moreText;
            const lessText = (_b = this._truncateButton.dataset) === null || _b === void 0 ? void 0 : _b.lessText;
            const truncateClassName = (_c = this._truncateButton.dataset) === null || _c === void 0 ? void 0 : _c.truncateClassName;
            if ((_d = this._truncatedElement.classList) === null || _d === void 0 ? void 0 : _d.contains(truncateClassName)) {
                (_e = this._truncatedElement.classList) === null || _e === void 0 ? void 0 : _e.remove(truncateClassName);
                this._truncateButton.innerText = lessText;
                this.setTaggingAttributes(lessText);
            }
            else {
                (_f = this._truncatedElement.classList) === null || _f === void 0 ? void 0 : _f.add(truncateClassName);
                this._truncateButton.innerText = moreText;
                this.setTaggingAttributes(moreText);
            }
        }
    }
    setTaggingAttributes(newText) {
        this._truncateButton.setAttribute("data-dotagging-element-title", `${newText.replace('.', '')} Button`);
    }
}

;// ./src/components/vehicle/vehicleAllFeatures/vehicleAllFeatures.ts


class VehicleAllFeatures {
    constructor() {
        this._selectorPrefix = 'data-vdp-element';
        this.getElements();
        this._truncateButton = new MoreLessButton(this._truncateButtonElement, this._truncatedElement);
        this._scrollbarVisibleClassName = 'scrollbar-visible';
        this._mouseHovering = false;
        this.addResizeListeners();
        this.addHoverListeners();
        this.addClickListeners();
    }
    getElements() {
        this._truncateButtonElement = document.querySelector(`[${this._selectorPrefix}="all-features-truncate-button"]`);
        this._truncatedElement = document.querySelector(`[${this._selectorPrefix}="feature-tab-content"]`);
        this._tabsElement = document.querySelector(`[${this._selectorPrefix}="all-features-tabs"]`);
        this._tabLinkElements = document.querySelectorAll(`[${this._selectorPrefix}="all-features-tab-link"]`);
    }
    addResizeListeners() {
        if (this._tabsElement) {
            const elementResizeObserver = new ResizeObserver_es/* default */.A(() => {
                // Apply the appropriate scrollbar styling when container is resized by scrolling through the page
                this.checkWidths(this._tabsElement, this._mouseHovering);
            });
            elementResizeObserver.observe(this._tabsElement);
        }
    }
    addHoverListeners() {
        if (this._tabsElement) {
            this._tabsElement.addEventListener('mouseover', () => {
                this._mouseHovering = true;
                // if mouse is over #srp_filter element and #srp_filter content is overflowing, add class
                this.checkWidths(this._tabsElement, this._mouseHovering);
            });
            this._tabsElement.addEventListener('mouseleave', () => {
                this._mouseHovering = false;
                // Only remove class if scrollbar exists
                this.checkWidths(this._tabsElement, this._mouseHovering);
            });
        }
    }
    addClickListeners() {
        if (this._tabLinkElements && this._tabLinkElements.length > 0) {
            this._tabLinkElements.forEach(link => {
                link.addEventListener('click', (event) => {
                    var clickTarget = event.target;
                    var clickedTab = clickTarget.closest(`[${this._selectorPrefix}="all-features-tab-link"]`);
                    this.toggleActiveTab(clickedTab);
                });
            });
        }
    }
    toggleActiveTab(clickedTab) {
        var activeLinkClassName = 'feature-tabs__link--active';
        this._tabLinkElements.forEach(link => {
            link.classList.remove(activeLinkClassName);
        });
        clickedTab.classList.add(activeLinkClassName);
    }
    // Function to adjust scrollbar styling in resize events
    checkWidths(containerElem, mouseHovering) {
        var _a, _b, _c, _d;
        if (mouseHovering && containerElem.scrollWidth > containerElem.clientWidth) {
            (_b = (_a = this._tabsElement) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add(this._scrollbarVisibleClassName);
        }
        else {
            (_d = (_c = this._tabsElement) === null || _c === void 0 ? void 0 : _c.classList) === null || _d === void 0 ? void 0 : _d.remove(this._scrollbarVisibleClassName);
        }
    }
}

;// ./src/components/vehicle/vehicleDealerComments/vehicleDealerComments.ts
class VehicleDealerComments {
    constructor() {
        this.setElements();
        this.addCommentTextButtonsListeners();
    }
    setElements() {
        this._commentsText = document.getElementById('dealer-comments');
        this._moreButton = document.getElementById('comments-more');
        this._lessButton = document.getElementById('comments-less');
    }
    addCommentTextButtonsListeners() {
        if (this._moreButton) {
            this._moreButton.addEventListener('click', (event) => {
                this.toggleMoreLess(event);
            });
        }
        if (this._lessButton) {
            this._lessButton.addEventListener('click', (event) => {
                this.toggleMoreLess(event);
            });
        }
    }
    toggleMoreLess(event) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const buttonClicked = event.currentTarget;
        const truncateClassName = 'truncate-comments';
        const hideClassName = 'hide-button';
        if ((_b = (_a = this._commentsText) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.contains(truncateClassName)) {
            this._dealerCommentsScrollTop = (_c = document === null || document === void 0 ? void 0 : document.documentElement) === null || _c === void 0 ? void 0 : _c.scrollTop;
            (_e = (_d = this._lessButton) === null || _d === void 0 ? void 0 : _d.classList) === null || _e === void 0 ? void 0 : _e.remove(hideClassName);
        }
        else {
            (_g = (_f = this._moreButton) === null || _f === void 0 ? void 0 : _f.classList) === null || _g === void 0 ? void 0 : _g.remove(hideClassName);
            (_h = document === null || document === void 0 ? void 0 : document.documentElement) === null || _h === void 0 ? void 0 : _h.scrollTo(0, this._dealerCommentsScrollTop);
        }
        (_j = buttonClicked === null || buttonClicked === void 0 ? void 0 : buttonClicked.classList) === null || _j === void 0 ? void 0 : _j.add('hide-button');
        (_l = (_k = this._commentsText) === null || _k === void 0 ? void 0 : _k.classList) === null || _l === void 0 ? void 0 : _l.toggle(truncateClassName);
    }
}

;// ./src/components/vehicle/vehicleDropdown/vehicleDropdown.ts
class VehicleDropdown {
    constructor() {
        this.COPY_BUTTON_TOGGLE_CLASS = "copied";
        this.DROPDOWN_TOGGLE_CLASS = "open";
        this.initInstanceVars();
        this.initIconMaskStyling();
        this.initEventListeners();
    }
    initInstanceVars() {
        this._dropdownBtns = document.querySelectorAll('[data-type="dropdown-button"]');
        this._copyLinkBtns = document.querySelectorAll('[data-type="copy-link-button"]');
        this._printBtns = document.querySelectorAll('[data-type="print-button"]');
        this._selectedOfferType = document.querySelector("ul[data-priceStak-tab-container] > li.active > button");
    }
    initIconMaskStyling() {
        var _a, _b;
        const head = document.getElementsByTagName('head')[0];
        const styleTag = document.createElement('style');
        styleTag.id = "do-srp-vehicle-dropdown-icons";
        const copyIconUrl = this._copyLinkBtns.length > 0
            ? this._copyLinkBtns.item(0).querySelector("img").src
            : "";
        const printIconUrl = this._printBtns.length > 0
            ? this._printBtns.item(0).querySelector("img").src
            : "";
        const shareIconUrl = (_a = document.querySelector('[data-type="share-vehicle-button"] img')) === null || _a === void 0 ? void 0 : _a.src;
        const detailsIconUrl = (_b = document.querySelector('[data-type="view-details-button"] img')) === null || _b === void 0 ? void 0 : _b.src;
        styleTag.innerHTML = `
      :root {
        --copy-icon-url: url(${copyIconUrl});
        --share-icon-url: url(${shareIconUrl});
        --print-icon-url: url(${printIconUrl});
        --details-icon-url: url(${detailsIconUrl});
      }
    `;
        head.appendChild(styleTag);
    }
    initEventListeners() {
        this._dropdownBtns.forEach(btn => {
            btn.addEventListener("click", () => {
                this.toggleSingleDropdown(btn.id);
            });
        });
        document.addEventListener("click", event => {
            if (!event.target.closest('[data-type="dropdown"], [data-type="dropdown-button"]')) {
                this.closeAllOpenDropdowns();
            }
        });
        this._copyLinkBtns.forEach(btn => {
            btn.addEventListener("click", () => {
                this.copyLink(btn);
            });
        });
        this._printBtns.forEach(btn => {
            const domain = window.location.hostname;
            const vehicle = {
                vin: btn.dataset.vin,
                dealerId: window.DlronGlobal_DealerId,
                offerType: this._selectedOfferType && this._selectedOfferType.dataset.pricestakTab !== "" ? this._selectedOfferType.dataset.pricestakTab : "buy",
            };
            const printUrl = `print-email-vehicledetailsvin.aspx?vin=${vehicle.vin}&childId=${vehicle.dealerId}&offerType=${vehicle.offerType}`;
            btn.setAttribute("data-dotagging-link-url", `${domain}/${printUrl}`);
            btn.addEventListener("click", () => {
                this.print(printUrl);
            });
        });
    }
    toggleSingleDropdown(btnId) {
        const dropdowns = document.querySelectorAll(`[aria-labelledby="${btnId}"]`);
        dropdowns.forEach(dropdown => {
            if (dropdown.classList.contains(this.DROPDOWN_TOGGLE_CLASS)) {
                dropdown.classList.remove(this.DROPDOWN_TOGGLE_CLASS);
            }
            else {
                dropdown.classList.add(this.DROPDOWN_TOGGLE_CLASS);
            }
        });
    }
    closeAllOpenDropdowns() {
        const openDropdowns = document.querySelectorAll(`[data-type="dropdown"].${this.DROPDOWN_TOGGLE_CLASS}`);
        openDropdowns.forEach(dropdown => {
            dropdown.classList.remove(this.DROPDOWN_TOGGLE_CLASS);
        });
    }
    copyLink(btn) {
        const vdpUrl = btn.dataset.vdpUrl;
        if (navigator.clipboard) {
            navigator.clipboard.writeText(vdpUrl)
                .then(() => {
                this.setButtonStateToCopied(btn);
                setTimeout(() => {
                    this.setButtonStateToDefault(btn);
                }, 3000);
            })
                .catch(() => {
                alert(`Unable to copy link to clipboard: ${vdpUrl}`);
            });
        }
    }
    print(printUrl) {
        window.open(printUrl);
    }
    setButtonStateToCopied(btn) {
        btn.classList.add(this.COPY_BUTTON_TOGGLE_CLASS);
        const btnTextSpan = btn.querySelector("span");
        btnTextSpan.innerText = btn.dataset.copiedText;
    }
    setButtonStateToDefault(btn) {
        btn.classList.remove(this.COPY_BUTTON_TOGGLE_CLASS);
        const btnTextSpan = btn.querySelector("span");
        btnTextSpan.innerText = btn.dataset.defaultText;
    }
}

;// ./src/components/vehicle/vehicleHighlights/vehicleHighlights.ts
class VehicleHighlights {
    constructor() {
        this.setElements();
        this.addHighlightsToggleButtonsListeners();
    }
    setElements() {
        this._highlightsElement = document.getElementById('vehicle-highlights-list');
        this._moreButton = document.getElementById('highlighted-features-more');
        this._lessButton = document.getElementById('highlighted-features-less');
    }
    addHighlightsToggleButtonsListeners() {
        if (this._moreButton) {
            this._moreButton.addEventListener('click', (event) => {
                this.toggleMoreLess(event);
            });
        }
        if (this._lessButton) {
            this._lessButton.addEventListener('click', (event) => {
                this.toggleMoreLess(event);
            });
        }
    }
    toggleMoreLess(event) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const buttonClicked = event.currentTarget;
        const collapsedClassName = 'collapsed';
        const hideClassName = 'hide-button';
        if ((_b = (_a = this._highlightsElement) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.contains(collapsedClassName)) {
            (_d = (_c = this._lessButton) === null || _c === void 0 ? void 0 : _c.classList) === null || _d === void 0 ? void 0 : _d.remove(hideClassName);
        }
        else {
            (_f = (_e = this._moreButton) === null || _e === void 0 ? void 0 : _e.classList) === null || _f === void 0 ? void 0 : _f.remove(hideClassName);
        }
        (_g = buttonClicked === null || buttonClicked === void 0 ? void 0 : buttonClicked.classList) === null || _g === void 0 ? void 0 : _g.add('hide-button');
        (_j = (_h = this._highlightsElement) === null || _h === void 0 ? void 0 : _h.classList) === null || _j === void 0 ? void 0 : _j.toggle(collapsedClassName);
    }
}

;// ./src/components/vehicle/vehiclePackage/vehiclePackage.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class VehiclePackage {
    constructor() {
        this._selectorPrefix = 'data-vdp-element';
        this.getElements();
        this._truncatePackageButton = new MoreLessButton(this._truncatePackageButtonElement, this._truncatedPackageElement);
        this.addEvents();
    }
    getElements() {
        this._truncatePackageButtonElement = document.querySelector(`[${this._selectorPrefix}="vehicle-package-truncate-button"]`);
        this._truncatedPackageElement = document.querySelector(`[${this._selectorPrefix}="vehicle-package-contents"]`);
    }
    addEvents() {
        var _a;
        (_a = this._truncatePackageButtonElement) === null || _a === void 0 ? void 0 : _a.addEventListener('click', () => {
            this.toggleAndReframe(this._truncatedPackageElement);
        });
    }
    toggleAndReframe(truncatedElement) {
        return __awaiter(this, void 0, void 0, function* () {
            truncatedElement.scrollIntoView();
        });
    }
}

;// ./src/components/vehicle/vehicleWarranty/vehicleWarranty.ts

class VehicleWarranty {
    constructor() {
        this.getElements();
        this._truncateButton = new MoreLessButton(this._truncateButtonElement, this._truncatedElement);
    }
    getElements() {
        const selectorPrefix = 'data-vdp-element';
        this._truncateButtonElement = document.querySelector(`[${selectorPrefix}="warranty-truncate-button"]`);
        this._truncatedElement = document.querySelector(`[${selectorPrefix}="warranty-contents"]`);
    }
}

;// ./src/components/vehicleDetailsHoisin/vehicleDetailsHoisin.ts

class VehicleDetailsData {
    constructor() {
    }
}
class VehicleDetailsHoisin {
    constructor() {
        this.initialize();
    }
    initialize() {
        const vehicleSettingsElem = document.getElementById("vehicleDetailsSettings");
        if (vehicleSettingsElem) {
            this.Settings = JSON.parse(vehicleSettingsElem.innerText);
            this.setupEvents();
        }
        else {
            throw new Error("Cannot find Vehicle Settings");
        }
    }
    GetModalContent($modal, endpoint, callback) {
        let xhr = new XMLHttpRequest();
        xhr.onload = function () {
            callback($modal, xhr.responseText);
        };
        xhr.onerror = function () {
            console.error('Error: ' + xhr.status + ' for endpoint ' + endpoint);
        };
        xhr.ontimeout = function () {
            console.error("The request for " + endpoint + " timed out.");
        };
        xhr.open("GET", endpoint, true);
        xhr.timeout = 0;
        xhr.send();
    }
    RenderModalContent($modal, response) {
        const optionsHtml = JSON.parse(response);
        var commentContent = $modal.find('#vehicleCommentContent');
        if (commentContent) {
            commentContent.html(optionsHtml);
        }
    }
    setupEvents() {
        //add accessibility for keyboard users
        const detailPanels = document.getElementById("vehicle-details-panels");
        detailPanels === null || detailPanels === void 0 ? void 0 : detailPanels.addEventListener("keyup", (e) => {
            const focusedElement = document === null || document === void 0 ? void 0 : document.activeElement;
            switch (e.key) {
                case "Enter": {
                    if (focusedElement) {
                        if (focusedElement.classList.contains("details-panel__header")) {
                            const collapseEl = focusedElement.querySelector("a[role='button']");
                            if (collapseEl) {
                                collapseEl.click();
                            }
                        }
                    }
                    break;
                }
            }
        });
        document.querySelectorAll("span[data-toggle='popover'],a[data-toggle='popover']").forEach(function (el) {
            const element = window.jQuery(el);
            if (window.matchMedia("(max-width: 767px)").matches) {
                jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(element, {
                    html: true,
                    trigger: 'click',
                    animation: false,
                    placement: element.dataset && element.dataset.placement ? element.dataset.placement : 'bottom',
                });
            }
            else {
                jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(element, {
                    html: true,
                    trigger: 'manual',
                    animation: false,
                    container: 'body',
                    placement: element.dataset && element.dataset.placement ? element.dataset.placement : 'auto left',
                }).on("mouseenter", function () {
                    jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(element, "show");
                    element.on("mouseleave", function () {
                        jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(element, 'hide');
                    });
                }).on("mouseleave", function () {
                    setTimeout(function () {
                        if (!el.parentElement.querySelectorAll(':hover').length) {
                            jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(element, "hide");
                        }
                    }, 5);
                });
            }
        });
        //bootstrap 3 modal requires jQuery
        const bodyElement = jQuery("body");
        if (bodyElement) {
            bodyElement.on("shown.bs.popover", function () {
                const modalLink = window.jQuery('.modal-link');
                modalLink.click(function (e) {
                    e.preventDefault();
                    var modal = window.jQuery('#rebateModal');
                    modal
                        .on('show.bs.modal', function () {
                        jQueryHelper/* JQueryHelper */.$.SafeApplyPopover(jQuery('[aria-describedby]'), 'hide');
                        jQuery('iframe#rebateIframe').removeAttr('src');
                        window.jQuery('iframe#rebateIframe').attr("src", e.currentTarget.href);
                    })
                        .modal();
                });
            });
        }
        //magnific popup requires jQuery
        const videoButtons = jQuery('.iframe-video-btn');
        if (videoButtons) {
            if (window.magnificPopupLoaded) {
                videoButtons.magnificPopup({
                    items: {
                        type: 'iframe',
                        midClick: true,
                        src: '/iframevideodisplay.aspx?vin=' + videoButtons.data('vehicleVin')
                    },
                    iframe: {
                        markup: '<div class="mfp-iframe-scaler vehicleVidMagnific">' +
                            '<div class="mfp-close"></div>' +
                            '<iframe class="mfp-iframe" frameborder="0" allowfullscreen scrolling="no">            </iframe>' +
                            '</div>'
                    },
                    mainClass: "vehicleVidMagnificContainer"
                });
            }
            else {
                document.addEventListener("MagnificPopupLoaded", () => {
                    videoButtons.magnificPopup({
                        items: {
                            type: 'iframe',
                            midClick: true,
                            src: '/iframevideodisplay.aspx?vin=' + videoButtons.data('vehicleVin')
                        },
                        iframe: {
                            markup: '<div class="mfp-iframe-scaler vehicleVidMagnific">' +
                                '<div class="mfp-close"></div>' +
                                '<iframe class="mfp-iframe" frameborder="0" allowfullscreen scrolling="no">            </iframe>' +
                                '</div>'
                        },
                        mainClass: "vehicleVidMagnificContainer"
                    });
                });
            }
        }
        //inline magnific popup for updated vdpHoisin Image Gallery
        const videoContainerElem = document.getElementById("#do-video-container[data-video-player-type='default']");
        if (videoContainerElem) {
            let options = {
                root: document.querySelector(".hero-carousel__items"),
                threshold: 0.9,
            };
            const observer = new IntersectionObserver((entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        window.jQuery.magnificPopup.open({
                            items: {
                                src: '#do-video-container',
                                type: 'inline',
                            }
                        });
                        observer.disconnect();
                    }
                });
            }, options);
            observer.observe(videoContainerElem);
        }
    }
}

// EXTERNAL MODULE: ./src/components/vehicleImageCarousel/vehicleImageCarousel.ts
var vehicleImageCarousel = __webpack_require__(34567);
;// ./src/components/vehicleImageGallery/vehicleImageGallery.ts

class VehicleImageGallery {
    constructor(galleryElement) {
        this._gallery = galleryElement;
        this.initializeCarousel(galleryElement);
        this.initializeThumbnails(galleryElement);
    }
    initializeCarousel(gallery) {
        this.carousel = new vehicleImageCarousel/* VehicleImageCarousel */.C(gallery, "hero-carousel", "gallery-thumbnails", vehicleImageCarousel/* Direction */.O.UpDown);
        this.setupEvents();
    }
    setupEvents() {
        //add accessibility for keyboard users
        document.addEventListener("keyup", (e) => {
            if (!this.isVisibile()) {
                return;
            }
            switch (e.key) {
                case "Escape": {
                    const closeButton = this._gallery.querySelector(".gallery-header--close");
                    if (closeButton) {
                        closeButton.click();
                    }
                    break;
                }
            }
        });
        this._gallery.addEventListener("keyup", (e) => {
            if (!this.isVisibile()) {
                return;
            }
            const focusedElement = document === null || document === void 0 ? void 0 : document.activeElement;
            switch (e.key) {
                case "Enter": {
                    if (focusedElement && focusedElement.classList.contains("gallery-header--close")) {
                        focusedElement.click();
                    }
                    break;
                }
            }
        });
        this._gallery.addEventListener("keydown", (e) => {
            if (!this.isVisibile()) {
                return;
            }
            switch (e.key) {
                case "ArrowRight": {
                    e.preventDefault();
                    const nextButton = this._gallery.querySelector(".hero-carousel__control--next-btn");
                    if (nextButton) {
                        nextButton.click();
                    }
                    break;
                }
            }
        });
        this._gallery.addEventListener("keydown", (e) => {
            if (!this.isVisibile()) {
                return;
            }
            switch (e.key) {
                case "ArrowLeft": {
                    e.preventDefault();
                    const nextButton = this._gallery.querySelector(".hero-carousel__control--previous-btn");
                    if (nextButton) {
                        nextButton.click();
                    }
                    break;
                }
            }
        });
        this._gallery.addEventListener("keydown", (e) => {
            if (!this.isVisibile()) {
                return;
            }
            switch (e.key) {
                case "Tab": {
                    //keep the focus on the gallery modal while it's open
                    const focusableElements = '.hero-carousel__control, .gallery-thumbnails .thumbnail, .gallery-header--close';
                    const firstFocusableElement = this._gallery.querySelectorAll(focusableElements)[0];
                    const focusableContent = this._gallery.querySelectorAll(focusableElements);
                    const lastFocusableElement = focusableContent[focusableContent.length - 1];
                    if (e.shiftKey) {
                        if ((document === null || document === void 0 ? void 0 : document.activeElement) === firstFocusableElement) {
                            lastFocusableElement.focus();
                            e.preventDefault();
                        }
                    }
                    else { // if tab key is pressed
                        if ((document === null || document === void 0 ? void 0 : document.activeElement) === lastFocusableElement) {
                            firstFocusableElement.focus();
                            e.preventDefault();
                        }
                    }
                }
            }
        });
    }
    isVisibile() {
        return this._gallery.offsetWidth > 0 && this._gallery.offsetHeight > 0;
    }
    initializeThumbnails(gallery) {
        // listen for clicks on the vehicle image and display the gallery
        gallery.querySelectorAll(".gallery-thumbnails .thumbnail")
            .forEach((galleryItem) => {
            galleryItem.addEventListener('click', (e) => {
                e.preventDefault();
            });
        });
        gallery.querySelector(".gallery-header--close")
            .addEventListener('click', (e) => {
            this.close();
        });
    }
    show(imgNumber) {
        this._gallery.classList.remove("hidden");
        document.querySelector("body").style.setProperty("overflow", "hidden");
        // Scroll AFTER opening the gallery because we use scrollTo. 
        // See comment in vehicleImageCarousel.ts
        const index = imgNumber;
        this.carousel.goToSlide(index, false);
        //accessibility, set the focus on the selected thumbnail
        const selectedThumb = this._gallery.querySelectorAll(".thumbnail")[index];
        if (selectedThumb) {
            selectedThumb.focus();
        }
    }
    close() {
        this._gallery.classList.add("hidden");
        document.querySelector("body").style.setProperty("overflow", "unset");
    }
}

;// ./src/components/vehicleImagesBlock/loadMorePhotosController.ts
class LoadMorePhotosContoller {
    constructor(numberOfThumbnailsToLoad) {
        this.numberOfThumbnailsToLoad = numberOfThumbnailsToLoad;
        this.hiddenThumbnails = [];
        this.hasMorePhotos = this.checkForPhotos();
    }
    loadMorePhotos() {
        const hiddenThumbnails = document.querySelectorAll("[data-dlron-type='vdpImagesBlockHoisin'] .thumbnails--desktop .thumbnails--desktop__bottom " +
            "#thumbnails--desktop__bottom-load-more .thumbnail--desktop.hide");
        const numThumbnailsLoaded = this.loadMoreThumbnails(hiddenThumbnails, this.numberOfThumbnailsToLoad);
        if (numThumbnailsLoaded === hiddenThumbnails.length) {
            this.hideLoadMoreBtn();
        }
    }
    hideLoadMoreBtn() {
        const loadMore = document.querySelector('#load-more-vehicles');
        if (loadMore) {
            loadMore.classList.add('hide');
        }
    }
    checkForPhotos() {
        this.hiddenThumbnails = document.querySelectorAll("[data-dlron-type='vdpImagesBlockHoisin'] .thumbnails--desktop .thumbnails--desktop__bottom " +
            "#thumbnails--desktop__bottom-load-more .thumbnail--desktop.hide");
        return this.hiddenThumbnails.length > 0;
    }
    loadMoreThumbnails(hiddenThumbnails, numOfThumbnailsToLoad) {
        let numThumbnailsLoaded = 0;
        for (let i = 0; i < numOfThumbnailsToLoad && i < hiddenThumbnails.length; i++) {
            const vehicleImg = hiddenThumbnails[i].querySelector('.thumbnail--desktop__image');
            if (vehicleImg) {
                hiddenThumbnails[i].classList.remove('hide');
                hiddenThumbnails[i].classList.add('show');
                numThumbnailsLoaded++;
            }
        }
        return numThumbnailsLoaded;
    }
}

;// ./src/components/vehicleImagesBlock/vehiclePhotoGalleryTabs.ts
class VehiclePhotoGalleryTabs {
    constructor() {
        this._tabElements = [];
        this.getElements();
        this.addListeners();
    }
    getElements() {
        this._tabElements = Array.from(document.querySelectorAll('[data-vdp-element="photo-gallery-tab"]'));
    }
    addListeners() {
        this._tabElements.forEach(tab => {
            tab.addEventListener('click', (event) => {
                this.toggleTabs(event);
            });
        });
    }
    toggleTabs(event) {
        this._tabElements.forEach(tab => {
            tab.classList.remove('active');
        });
        const target = event.target;
        target.classList.add('active');
    }
}

;// ./src/components/vehicleImagesBlock/vehicleImagesBlock.ts





class VehicleImagesBlockFactory {
    static getImageBlock() {
        const vehicleImagesBlockElem = document.querySelector("[data-dlron-type='vdpImagesBlockHoisin']");
        if (vehicleImagesBlockElem && vehicleImagesBlockElem.classList.contains("vehicle-images--mod")) {
            return new VehicleImagesBlockMod();
        }
        return new VehicleImagesBlock();
    }
}
class VehicleImagesBlock {
    constructor() {
        this.is360InteriorLoad = false;
        this.initialize();
    }
    initialize() {
        this._vehicleImagesBlockElem = document.querySelector("[data-dlron-type='vdpImagesBlockHoisin']");
        if (this._vehicleImagesBlockElem) {
            this._tabs = new VehiclePhotoGalleryTabs();
            this.setupCarousel();
            this.setupGallery();
            this.setupEvents();
        }
    }
    setupCarousel() {
        const carouselContainer = document.querySelector("[data-dlron-type='vehicle-image-carousel']");
        this._carousel = new vehicleImageCarousel/* VehicleImageCarousel */.C(carouselContainer, "hero-carousel", null, null, "thumbnails--mobile", vehicleImageCarousel/* Direction */.O.LeftRight);
    }
    setupGallery() {
        const galleryElem = document.querySelector("[data-dlron-type='vehicle-image-gallery']");
        this._gallery = new VehicleImageGallery(galleryElem);
    }
    load360Interior() {
        if (this.is360InteriorLoad) {
            return;
        }
        const panoramicImage = document.getElementById("interior360-container");
        if (panoramicImage != null) {
            const imgSrc = panoramicImage.dataset.imageSrc;
            if (imgSrc) {
                window.pannellum.viewer('interior360-container', {
                    "type": "equirectangular",
                    "panorama": imgSrc,
                    "autoLoad": true,
                });
                this.is360InteriorLoad = true;
            }
        }
    }
    setupEvents() {
        this._vehicleImagesBlockElem.querySelectorAll(`.thumbnails .thumbnail--desktop, .hero-carousel__item`)
            .forEach((item) => {
            item.addEventListener("click", (e) => {
                var _a, _b;
                e.preventDefault();
                let index = parseInt((_b = (_a = item === null || item === void 0 ? void 0 : item.dataset) === null || _a === void 0 ? void 0 : _a.carouselIndex) !== null && _b !== void 0 ? _b : "0");
                this._gallery.show(index);
            });
        });
        this._vehicleImagesBlockElem.querySelectorAll(".thumbnails .thumbnail--mobile")
            .forEach((item) => {
            item.addEventListener("click", (e) => {
                e.preventDefault();
            });
        });
        const carousel = document.querySelector(".hero-carousel");
        carousel.addEventListener("keyup", (e) => {
            const focusedElement = document === null || document === void 0 ? void 0 : document.activeElement;
            switch (e.key) {
                case "Enter": {
                    if (focusedElement) {
                        if (focusedElement.classList.contains("hero-carousel__items")) {
                            focusedElement.click();
                        }
                    }
                    break;
                }
            }
        });
        // If there are more vehicles to display, load more vehicles, else hide the load more button.
        const numberOfThumbnailsToLoad = 4;
        const loadMoreButton = document.querySelector("#load-more-vehicles__btn");
        const loadMorePhotosContoller = new LoadMorePhotosContoller(numberOfThumbnailsToLoad);
        if (loadMorePhotosContoller.hasMorePhotos) {
            loadMoreButton.addEventListener("click", (e) => {
                e.preventDefault();
                loadMorePhotosContoller.loadMorePhotos();
            });
        }
        else {
            loadMorePhotosContoller.hideLoadMoreBtn();
        }
        $('a[id="interior360-tab"]').on('shown.bs.tab', (e) => {
            this.load360Interior();
        });
    }
}
class VehicleImagesBlockMod {
    constructor() {
        this.is360InteriorLoad = false;
        this.initialize();
    }
    initialize() {
        this._vehicleImagesBlockElem = document.querySelector("[data-dlron-type='vdpImagesBlockHoisin']");
        if (this._vehicleImagesBlockElem) {
            this._deskTopThumbsSidebar = document.querySelector(".thumbnails--desktop__sidebar");
            this._desktopThumbs = this._deskTopThumbsSidebar.closest(".thumbnails--desktop");
            this.setupCarousel();
            this.setupGallery();
            this.setupEvents();
        }
    }
    setupDesktopThumbnailHeight() {
        const carouselItemsElem = document.querySelector(".hero-carousel__items");
        let mainImageHeight = window.getComputedStyle(carouselItemsElem).height;
        this._deskTopThumbsSidebar.style.height = mainImageHeight;
        this._desktopThumbs.style.height = `calc(${mainImageHeight} + ${this.getThumbsYOffset()})`;
        new hideableScrollbar/* HideableScrollbar */.t(this._deskTopThumbsSidebar, true, false);
        const resizeObserver = new ResizeObserver(() => {
            mainImageHeight = window.getComputedStyle(carouselItemsElem).height;
            this._deskTopThumbsSidebar.style.height = mainImageHeight;
            this._desktopThumbs.style.height = `calc(${mainImageHeight} + ${this.getThumbsYOffset()})`;
        });
        if (carouselItemsElem) {
            resizeObserver.observe(carouselItemsElem);
        }
        //fire an initial height set since the observer only fires when we resize
        mainImageHeight = window.getComputedStyle(carouselItemsElem).height;
        this._deskTopThumbsSidebar.style.height = mainImageHeight;
        this._desktopThumbs.style.height = `calc(${mainImageHeight} + ${this.getThumbsYOffset()})`;
    }
    getThumbsYOffset() {
        const vw = window.innerWidth;
        const galleryPaddingLarge = getComputedStyle(document.documentElement).getPropertyValue("--gallery-padding-large");
        const galleryPaddingMedium = getComputedStyle(document.documentElement).getPropertyValue("--gallery-padding-medium");
        if (vw > 1366) {
            return `${galleryPaddingLarge} * 2`;
        }
        if (vw > 1080) {
            return `${galleryPaddingMedium} * 2`;
        }
        return "0px";
    }
    setupCarousel() {
        const carouselContainer = document.querySelector("[data-dlron-type='vehicle-image-carousel']");
        this._carousel = new vehicleImageCarousel/* VehicleImageCarousel */.C(carouselContainer, "hero-carousel", "thumbnails--desktop__sidebar", vehicleImageCarousel/* Direction */.O.UpDown, "thumbnails--mobile", vehicleImageCarousel/* Direction */.O.LeftRight);
    }
    setupGallery() {
        const galleryElem = document.querySelector("[data-dlron-type='vehicle-image-gallery']");
        this._gallery = new VehicleImageGallery(galleryElem);
    }
    load360Interior() {
        if (this.is360InteriorLoad) {
            return;
        }
        const panoramicElementId = "interior360-container";
        const panoramicImage = document.getElementById(panoramicElementId);
        if (panoramicImage != null) {
            const imgSrc = panoramicImage.dataset.imageSrc;
            if (imgSrc) {
                window.pannellum.viewer(panoramicElementId, {
                    "type": "equirectangular",
                    "panorama": imgSrc,
                    "autoLoad": true,
                });
                this.is360InteriorLoad = true;
            }
        }
    }
    setupScrollbarStylingListeners() {
        var _a, _b;
        (_a = this._deskTopThumbsSidebar) === null || _a === void 0 ? void 0 : _a.addEventListener("scrollbar-visible", () => {
            this.setupMediaQueryStyles(false);
        });
        (_b = this._deskTopThumbsSidebar) === null || _b === void 0 ? void 0 : _b.addEventListener("scrollbar-hidden", () => {
            this.setupMediaQueryStyles(true);
        });
    }
    setupMediaQueryStyles(shouldHide) {
        const min1081 = window.matchMedia("(min-width: 1081px");
        const min992max1080 = window.matchMedia("(min-width: 992px) and (max-width: 1080px)");
        const controlsElem = document.querySelector(".hero-carousel__controls.vertical");
        let containerElem;
        let paddingValue = "0px";
        let widthOffset = "0px";
        // @ts-ignore
        const isFirefox = typeof InstallTrigger !== 'undefined';
        const firefoxOffset = isFirefox ? "3px" : "0px";
        if (min1081.matches) {
            containerElem = this._desktopThumbs;
            paddingValue = `calc(7px - ${firefoxOffset})`;
            widthOffset = `(5px + ${firefoxOffset})`;
        }
        else if (min992max1080.matches) {
            containerElem = this._deskTopThumbsSidebar.parentElement;
            paddingValue = `calc(19px - ${firefoxOffset})`;
            widthOffset = "24px";
        }
        else {
            return;
        }
        if (shouldHide) {
            containerElem.style.removeProperty("padding-right");
            controlsElem.style.removeProperty("width");
        }
        else {
            containerElem.style.paddingRight = paddingValue;
            controlsElem.style.width = `calc(100% - ${widthOffset})`;
        }
    }
    setupEvents() {
        this.setupDesktopThumbnailHeight();
        this.setupScrollbarStylingListeners();
        this._vehicleImagesBlockElem.querySelectorAll(`.hero-carousel__item`)
            .forEach((item) => {
            item.addEventListener("click", (e) => {
                var _a, _b;
                e.preventDefault();
                //tpi thumbnails don't show up in the gallery
                if ((item === null || item === void 0 ? void 0 : item.dataset.carouselContentType) !== "image") {
                    return;
                }
                const index = parseInt((_b = (_a = item === null || item === void 0 ? void 0 : item.dataset) === null || _a === void 0 ? void 0 : _a.carouselIndex) !== null && _b !== void 0 ? _b : "0");
                this._gallery.show(index);
            });
        });
        const carousel = document.querySelector(".hero-carousel");
        carousel.addEventListener("keyup", (e) => {
            const focusedElement = document === null || document === void 0 ? void 0 : document.activeElement;
            switch (e.key) {
                case "Enter": {
                    if (focusedElement) {
                        if (focusedElement.classList.contains("hero-carousel__items")) {
                            focusedElement.click();
                        }
                    }
                    break;
                }
            }
        });
        //load pannellum plugin as needed
        const panellumObserver = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    this.load360Interior();
                }
            });
        });
        const panoramicElementId = "interior360-container";
        const panoramicElement = document.getElementById(panoramicElementId);
        if (panoramicElement) {
            panellumObserver.observe(panoramicElement);
            panellumObserver.disconnect;
        }
    }
}

// EXTERNAL MODULE: ./src/components/pricing/pricingTypeCookie.ts
var pricingTypeCookie = __webpack_require__(41373);
;// ./src/components/vehiclePriceStakTabs/priceStakTabs.ts

class PriceStackTabs {
    scrollAnchorBefore(target) {
        this.previousElementScrollY = target.getBoundingClientRect().y;
    }
    scrollAnchorAfter(target) {
        let currentScrollY = target.getBoundingClientRect().y;
        let deltaY = currentScrollY - this.previousElementScrollY;
        requestAnimationFrame(() => window.scrollTo(0, window.scrollY + deltaY));
    }
    // end HACK
    constructor() {
        this.tabSelector = 'data-pricestak-tab';
        this.tabWrapperSelector = 'data-pricestak-tab-wrapper';
        this.tabPaneSelector = 'data-pricestak-tab-pane';
        this.tabContainerSelector = 'data-pricestak-main';
        this.buyTabName = "buy";
        this.financeTabName = "finance";
        this.leaseTabName = "lease";
        this.activeClassName = "active";
        this.pricingCookieName = "DLRON_SELECTED_PRICING_TYPE";
        // HACK: Safari scroll-anchor implementation - CONPLAT-2120
        this.previousElementScrollY = 0;
        this.setupData();
        this.setupButtonEvents();
        this.checkForQuerystringOverrides();
        this.switchAllTabs();
    }
    setupData() {
        var widgetDataElement = document.getElementById('priceStakDataModel');
        if (widgetDataElement && widgetDataElement.textContent) {
            this.dataModel = JSON.parse(widgetDataElement.textContent);
        }
        else {
            this.dataModel = new PriceStakDataModel(this.buyTabName);
        }
    }
    setupButtonEvents() {
        document.querySelectorAll(`[${this.tabSelector}]`)
            .forEach((btn) => btn.addEventListener('click', (evt) => {
            var target = evt.target;
            this.scrollAnchorBefore(target);
            this.dataModel.selectedTab = (target).getAttribute(`${this.tabSelector}`);
            pricingTypeCookie/* PricingTypeCookie */.L.setPricingTypeCookie(this.dataModel.selectedTab);
            this.switchAllTabs();
            this.scrollAnchorAfter(target);
        }));
    }
    checkForQuerystringOverrides() {
        var queryString = window.location.search.toLocaleLowerCase();
        if (queryString.includes("?pricerange") || queryString.includes("&pricerange")) {
            this.dataModel.selectedTab = this.buyTabName;
        }
        else if (queryString.includes("financepricerange")) {
            this.dataModel.selectedTab = this.financeTabName;
        }
        else if (queryString.includes("leasepricerange")) {
            this.dataModel.selectedTab = this.leaseTabName;
        }
    }
    switchAllTabs() {
        var _a;
        var allTabContainers = document.querySelectorAll(`[${this.tabContainerSelector}]`);
        let selectedTab = (_a = pricingTypeCookie/* PricingTypeCookie */.L.currentCookieValue) !== null && _a !== void 0 ? _a : this.dataModel.selectedTab;
        allTabContainers.forEach((tabContainer) => {
            //check for tab, if it does not exist in this tab container, try buy
            //CONPLAT-2374: Use the PricingTypeCookie value to determine the selected tab
            var tabSelector = `[${this.tabSelector}=${selectedTab}]`;
            var selectedTabElement = tabContainer.querySelector(tabSelector);
            if (selectedTabElement) {
                this.switchTab(tabContainer, selectedTab);
            }
            else {
                //if there is no "buy" tab, nothing to do
                var defaultTabSelector = `[${this.tabSelector}=${this.buyTabName}]`;
                var defaultTabElement = tabContainer.querySelector(defaultTabSelector);
                if (defaultTabElement) {
                    this.switchTab(tabContainer, this.buyTabName);
                }
            }
        });
    }
    switchTab(tabContainer, newTabName) {
        var _a, _b, _c, _d;
        if (tabContainer) {
            const currentTabWrapper = tabContainer.querySelector(`[${this.tabWrapperSelector}].${this.activeClassName}`);
            const currentTabButton = currentTabWrapper === null || currentTabWrapper === void 0 ? void 0 : currentTabWrapper.querySelector(`[${this.tabSelector}]`);
            const currentTabPane = tabContainer.querySelector(`[${this.tabPaneSelector}].${this.activeClassName}`);
            const newTabWrapper = tabContainer.querySelector(`[${this.tabWrapperSelector}="${newTabName}"]`);
            const newTabButton = tabContainer.querySelector(`[${this.tabSelector}="${newTabName}"]`);
            const newTabPane = tabContainer.querySelector(`[${this.tabPaneSelector}="${newTabName}"]`);
            (_a = currentTabWrapper === null || currentTabWrapper === void 0 ? void 0 : currentTabWrapper.classList) === null || _a === void 0 ? void 0 : _a.remove(this.activeClassName);
            currentTabButton === null || currentTabButton === void 0 ? void 0 : currentTabButton.setAttribute('aria-expanded', 'false');
            (_b = currentTabPane === null || currentTabPane === void 0 ? void 0 : currentTabPane.classList) === null || _b === void 0 ? void 0 : _b.remove(this.activeClassName);
            (_c = newTabWrapper === null || newTabWrapper === void 0 ? void 0 : newTabWrapper.classList) === null || _c === void 0 ? void 0 : _c.add(this.activeClassName);
            newTabButton === null || newTabButton === void 0 ? void 0 : newTabButton.setAttribute('aria-expanded', 'true');
            (_d = newTabPane === null || newTabPane === void 0 ? void 0 : newTabPane.classList) === null || _d === void 0 ? void 0 : _d.add(this.activeClassName);
        }
    }
}
PriceStackTabs.isInitialized = false;
class PriceStakDataModel {
    constructor(selectedTab) {
        this.selectedTab = selectedTab;
    }
}

// EXTERNAL MODULE: ./src/types/types.ts
var types = __webpack_require__(45644);
;// ./src/pages/vehicleDetailsPage/vehicleDetailsPageHoisin.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var vehicleDetailsPageHoisin_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
//support DI






















let VehicleDetailsPageHoisin = class VehicleDetailsPageHoisin {
    constructor(toggleService, shareVehicleModal, evnVideoPlayer, tdgConfirmAndContactButtons) {
        this._headerHeight = 0;
        this._stickyHeaderTop = "0px";
        this._block1Height = 0;
        this._offerBlockHeight = 0;
        this._bonusBlockHeight = 0;
        this.toggleService = toggleService;
        this.shareVehicleModal = shareVehicleModal;
        this.evnVideoPlayer = evnVideoPlayer;
        this.tdgConfirmAndContactButtons = tdgConfirmAndContactButtons;
    }
    initialize() {
        return vehicleDetailsPageHoisin_awaiter(this, void 0, void 0, function* () {
            yield this.toggleService.initialize();
            this._vehicleDetails = new VehicleDetailsHoisin();
            this._priceStak = new PriceStak();
            this._vehicleDealerComments = new VehicleDealerComments();
            this._vehicleHighlights = new VehicleHighlights();
            this._vehiclePackage = new VehiclePackage();
            this._vehicleAllFeatures = new VehicleAllFeatures();
            this._vehicleWarranty = new VehicleWarranty();
            new AutoFi();
            new MoreInfoModal();
            new VehicleDropdown();
            this.shareVehicleModal.initialize();
            new DigitalGarage();
            this.evnVideoPlayer.initialize('DOMContentLoaded');
            new PriceStackTabs();
            this.tdgConfirmAndContactButtons.initialize(uiLocationVersion/* UiLocationVersion */.I.VdpHoisin);
            this._imagesBlock = VehicleImagesBlockFactory.getImageBlock();
            this._siteHeaderElement = document.querySelector(".headerWrapper");
            this._headerHeight = this.getHeaderHeight();
            this._spincarHighlights = document.querySelector("#spincar-feature-highlights");
            //default this to the header height
            this._stickyHeaderTop = `${this._headerHeight}px`;
            //we dynamically load custom blocks on Hoisin so cBlock-1 will only
            //show if it has content. If we don't find it, we want the next lowest
            //element that can be above the VDP content ... which is the bonus block
            //We will get the bottom of this element to know information for sticking
            //and scrolling the vehicle details when its in the second column
            //(i.e. 2 column scrolling)
            this._block1 = document.getElementById("cBlock-1");
            this._offerBlock = document.querySelector(".offerBlock");
            this._bonusBlock = document.querySelector(".bonusBlock");
            this._vehicleDetailsElement = document.getElementById("vehicle-details");
            this._priceDrop = document.querySelector("[data-vdp-element='priceDropBody']");
            this.getTwoColumnObserver();
            this.addHighlightButtonListener();
            this.initializeTooltips();
            // Accessibility: prevent aria-expanded from appearing on collapsible body region
            this.RemoveBootstapAttributesFromPriceDrop();
            if (this.pageHasTwoColumnScrolling()) {
                this.styleTwoColumnScrolling();
                if (this._vehicleDetailsElement) {
                    this._rightColumn = new hideableScrollbar/* HideableScrollbar */.t(this._vehicleDetailsElement, true, false);
                    this._vehicleDetailsElement.style.top = `${this.getHeaderHeight()}px`;
                }
            }
            this.autoCollapsePriceDropOnDesktop();
            this.removeEmptyFeatures();
            if (this._spincarHighlights) {
                window.addEventListener('message', (event) => this.handleSpinCarClick(event.data));
            }
            window.DealerOn_PageName = "Vehicle Details";
        });
    }
    handleSpinCarClick(data) {
        if (data === 'STS:feature-highlights::expand') {
            this._spincarHighlights.classList.add('expanded');
            return;
        }
        if (data === 'STS:feature-highlights::close') {
            this._spincarHighlights.classList.remove('expanded');
        }
    }
    getHeaderHeight() {
        if (this._siteHeaderElement) {
            const height = parseInt(window.getComputedStyle(this._siteHeaderElement).height);
            return height;
        }
        return 0;
    }
    getTwoColumnObserver() {
        const observer = new IntersectionObserver((entries) => {
            //if we're in desktop mode we want 2 column scrolling
            if (getComputedStyle(this._vehicleDetailsElement).position === "sticky") {
                let height = 0;
                for (const entry of entries) {
                    if (entry.target === this._block1) {
                        this._block1Height = this.getEntryHeight(entry);
                    }
                    if (entry.target === this._offerBlock) {
                        this._offerBlockHeight = this.getEntryHeight(entry);
                    }
                    if (entry.target === this._bonusBlock) {
                        this._bonusBlockHeight = this.getEntryHeight(entry);
                    }
                }
                this._stickyHeaderTop = `${this._headerHeight +
                    this._block1Height +
                    this._offerBlockHeight +
                    this._bonusBlockHeight}px`;
                this._vehicleDetailsElement.style.height = `calc(100vh - ${this._stickyHeaderTop})`;
            }
            else {
                //in mobile mode we want 100% visible
                this._vehicleDetailsElement.style.height = "100%";
            }
        });
        if (this._block1) {
            observer.observe(this._block1);
        }
        if (this._bonusBlock) {
            observer.observe(this._bonusBlock);
        }
        if (this._offerBlock) {
            observer.observe(this._offerBlock);
        }
        observer.disconnect;
    }
    getEntryHeight(entry) {
        if (entry.isIntersecting) {
            return entry.boundingClientRect.height;
        }
        return 0;
    }
    pageHasTwoColumnScrolling() {
        const vdpElement = document.getElementsByClassName("vdp");
        if (vdpElement.length === 0) {
            return false;
        }
        const vdpElem = vdpElement[0];
        if (vdpElem) {
            return vdpElem.dataset.twoColumnScrollingEnabled.toLowerCase() == "true";
        }
        return false;
    }
    styleTwoColumnScrolling() {
        const rootHtml = document.getElementsByTagName("html");
        if (rootHtml.length === 0) {
            return;
        }
        const rootElement = rootHtml[0];
        if (rootElement) {
            rootElement.dataset.twoColumnScrollingEnabled = "True";
            if (!this._priceDrop) {
                return;
            }
            rootElement.dataset.hasPriceDrop =
                this._priceDrop !== undefined ? "True" : "False";
        }
    }
    /* TODO: remove when color variables are added to site templates */
    getColor(colorClass, cssProperty) {
        const dummyElement = document.createElement("div");
        const body = document.getElementsByTagName("body")[0];
        dummyElement.classList.add(colorClass);
        body.appendChild(dummyElement);
        let color = getComputedStyle(dummyElement)[cssProperty];
        body.removeChild(dummyElement);
        return color !== null && color !== void 0 ? color : "";
    }
    addHighlightButtonListener() {
        const highlightsButton = document.getElementById("vdp-vehicle-highlights-show-more");
        if (highlightsButton) {
            highlightsButton.addEventListener("click", () => {
                const highlightsList = document.getElementById("vehicle-highlights-list");
                if (highlightsList) {
                    highlightsList.classList.remove("collapsed");
                    highlightsButton.classList.add("hidden");
                }
            });
        }
    }
    initializeTooltips() {
        jQueryHelper/* JQueryHelper */.$.SafeApplyTooltip($('[data-toggle="tooltip"]'));
    }
    autoCollapsePriceDropOnDesktop() {
        if (!this._priceDrop || window.innerWidth < 992) {
            return;
        }
        setTimeout(() => {
            jQueryHelper/* JQueryHelper */.$.SafeApplyCollapse(this._priceDrop, "hide");
        }, 3000);
    }
    /// <summary>
    /// See DO-26362 - Remove empty feature elements (<ul> and <li>) from the vehicle features tab
    /// This was added for ADA compliance
    /// </summary>
    removeEmptyFeatures() {
        var _a, _b;
        (_b = (_a = document
            .querySelector("#vehicleFeaturesTabContent")) === null || _a === void 0 ? void 0 : _a.querySelectorAll("ul, li")) === null || _b === void 0 ? void 0 : _b.forEach((e) => {
            if (e.textContent.trim().length === 0 && e.children.length === 0) {
                e.remove();
            }
        });
    }
    /// <summary>
    /// Divs should not be given the aria-expanded attribute
    /// which is reserved for interactive elements like buttons.
    /// We use a MutationObserver to strip the attribute whenever
    /// Bootstrap adds it back during collapse/expand actions.
    /// </summary>
    RemoveBootstapAttributesFromPriceDrop() {
        if (!this._priceDrop) {
            return;
        }
        new MutationObserver(() => this._priceDrop.removeAttribute('aria-expanded'))
            .observe(this._priceDrop, { attributes: true, attributeFilter: ['aria-expanded'] });
    }
};
VehicleDetailsPageHoisin = __decorate([
    (0,inversify/* injectable */._G)(),
    __param(0, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.IToggleService)),
    __param(1, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.ShareVehicleModel)),
    __param(2, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.EvnVideoPlayer)),
    __param(3, (0,inversify/* inject */.WQ)(types/* TYPES */.Q.TdgConfirmAndContactButtons)),
    __metadata("design:paramtypes", [Object, shareVehicleModal/* ShareVehicleModal */.H,
        evnVideoPlayer/* EvnVideoPlayer */.U,
        tdgConfirmAndContactButtons/* TdgConfirmAndContactButtons */.Y])
], VehicleDetailsPageHoisin);


// EXTERNAL MODULE: ./src/inversify.config.ts + 22 modules
var inversify_config = __webpack_require__(16588);
;// ./src/pages/vehicleDetailsPage/vehicleDetailsPageHoisinLoader.ts
var vehicleDetailsPageHoisinLoader_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
//DEPENDENCY INJECTION
// reflect-metadata should only be called once at the root of the application




class VehicleDetailsPageHoisinLoader {
    initialize() {
        return vehicleDetailsPageHoisinLoader_awaiter(this, void 0, void 0, function* () {
            // Wrap the container.get() call in an async function
            const page = yield this.getPageInstance();
            page.initialize();
        });
    }
    getPageInstance() {
        return vehicleDetailsPageHoisinLoader_awaiter(this, void 0, void 0, function* () {
            // Wrap the container.get() call in a Promise
            return new Promise((resolve) => {
                if (!inversify_config.doIocContainer.isBound(types/* TYPES */.Q.VehicleDetailsPageHoisin)) {
                    inversify_config.doIocContainer.bind(types/* TYPES */.Q.VehicleDetailsPageHoisin).to(VehicleDetailsPageHoisin).inSingletonScope();
                }
                const page = inversify_config.doIocContainer.get(types/* TYPES */.Q.VehicleDetailsPageHoisin);
                resolve(page);
            });
        });
    }
}
function main() {
    return vehicleDetailsPageHoisinLoader_awaiter(this, void 0, void 0, function* () {
        const loader = new VehicleDetailsPageHoisinLoader();
        yield loader.initialize();
    });
}
main(); // Call the main function to start the initialization process

})();

/******/ })()
;